# 第三章。响应式编程-基本理论

响应式编程，包括稍后将讨论的函数式响应式编程，是一种可以在多范式语言中使用的编程范式，例如 JavaScript、Python、Scala 等等。它主要与命令式编程有所不同，在命令式编程中，语句通过所谓的*副作用*来执行某些操作，在文献中，关于函数式和响应式编程。请注意，这里的副作用并不是普通英语中的副作用，其中所有药物都有一些效果，这些效果是服用药物的目的，而其他一些效果是不受欢迎的，但为了主要的益处而被容忍。例如，苯海拉明是为了减轻空气过敏症状而服用的，而事实上，苯海拉明在某种程度上与其他一些过敏药物类似，也会引起嗜睡（或者至少曾经是这样；现在它也作为睡眠辅助剂出售）是一种*副作用*。这是不受欢迎的，但被人们容忍，因为他们宁愿有些疲倦，而不受频繁打喷嚏的困扰。药物的副作用很少是程序员通常会考虑的*副作用*的唯一事情。对于他们来说，*副作用*是语句的主要预期目的和效果，通常通过对程序的存储状态进行更改来实现。

响应式编程源于观察者模式，如 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 的经典著作《设计模式：可复用面向对象软件的元素》中所讨论的（这本书的作者通常被称为*GoF*或*四人帮*）。在观察者模式中，有一个可观察的主题。它有一个监听器列表，并在有发布内容时通知它们所有。这比发布者/订阅者（PubSub）模式要简单一些，不需要潜在复杂的消息筛选，以确定哪些消息到达哪些订阅者，这是一个常见的特性。

响应式编程已经发展成了一种独立的生活，有点像 MVC 模式变成了流行语，但最好是与 GoF 中探讨的更广泛的背景联系在一起。响应式编程，包括 ReactJS 框架（在本书中进行了探讨），旨在避免共享可变状态并且是幂等的。这意味着，就像 RESTful 网络服务一样，无论您调用一次还是一百次，您都将从函数中获得相同的结果。Facebook 的前员工皮特·亨特（现在是 ReactJS 的代表人物）曾说过，他宁愿是可预测的，而不是正确的。如果他的代码中有错误，亨特宁愿接口每次都以相同的方式失败，而不是进行对海森巴格的复杂搜索。这些错误只在一些特殊而棘手的边缘情况下表现出来，并且在本书的后面进行了探讨。

ReactJS 被称为*MVC*的*V*。也就是说，它旨在用于用户界面工作，并且几乎没有提供其他标准功能的意图。但就像画家保罗·塞尚对印象派画家克劳德·莫奈所说的，“莫奈只是一只眼睛，但是多么美的眼睛！”关于 MVC 和 ReactJS，我们可以说，“ReactJS 只是一个视图，但是多么出色的视图！”

在本章中，我们将涵盖以下主题：

+   声明式编程

+   对抗海森巴格

+   Flux 架构

+   从绝望之坑到成功之坑

+   完整的 UI 拆解和重建

+   JavaScript 作为**领域特定语言**（**DSL**）

+   大咖啡符号

本书中探讨的库 ReactJS 是由 Facebook 开发的，并在不久之前开源。它受到 Facebook 关于创建一个安全易于调试的大型网站以及允许大量程序员在不必将复杂性存储在头脑中的情况下工作的一些关注的影响。引用语“简单是缺乏交错”，可以在[`facebook.github.io/react`](http://facebook.github.io/react)的视频中找到，它不是关于绝对尺度上有多少或多少东西，而是关于您需要同时操纵多少个移动部分来工作在一个系统上（有关*大咖啡符号*的更多反思，请参见相关部分）。

# 声明式编程

ReactJS 框架最大的理论优势可能是编程是声明式的，而不是命令式的。在命令式编程中，您指定需要执行哪些步骤；声明式编程是指您指定需要完成什么，而不告诉如何完成。从命令式范式转变到声明式范式可能一开始会很困难，但一旦完成转变，付出的努力就是值得的。

熟悉的声明式范例，与命令式范例相对，包括 SQL 和 HTML。如果您必须指定如何查找记录并适当地过滤它们，更不用说如何使用索引，那么 SQL 查询将会更加冗长，而如果您必须指定如何渲染图像，HTML 将会更加冗长。许多库比起从头开始自己解决问题更具有声明性。使用库，您更有可能只指定需要完成什么，而不是除此之外还要指定如何完成。ReactJS 在任何意义上都不是旨在提供更具声明性 JavaScript 的唯一库或框架，但这是它的卖点之一，还有其他更好的具体功能，可以帮助团队合作并提高生产力。再次强调，ReactJS 是从 Facebook 在管理错误和认知负荷方面的一些努力中出现的。

# 对 Heisenbugs 的战争

在现代物理学中，海森堡的不确定性原理大致表明，有一个绝对的理论限制，即一个粒子的位置和速度可以被了解到多好。无论实验室的测量设备有多好，当您试图过于深入地固定事物时，总会发生一些有趣的事情。

海森堡不确定性原理，口语上来说，是一种微妙的、难以捉摸的错误，很难固定下来。它们只在非常特定的条件下显现，甚至在尝试调查它们时可能甚至不会显现（请注意，这个定义与 jargon 文件在[`www.catb.org/jargon/html/H/heisenbug.html`](http://www.catb.org/jargon/html/H/heisenbug.html)中更狭窄和更具体的定义略有不同，该定义指出尝试测量 heisenbug 可能会抑制其显现）。对海森堡不确定性原理进行宣战的动机源于 Facebook 自己在规模化工作和看到 heisenbug 不断出现的困扰和经验。Pete Hunt 提到的一件事，一点也不令人愉快，是 Facebook 广告系统只有两名工程师能够充分理解并且愿意修改。这是一个需要避免的例子。

相比之下，看看 Pete Hunt 的评论，他宁愿“可预测也不愿意正确”是一个声明，如果一个设计有缺陷的灯可以着火烧毁，他更愿意它立即着火烧毁，以相同的方式，每一次，而不是在月相的错误时刻发生燃烧。在第一种情况下，灯会在制造商测试时失败，问题会被注意到并得到解决，直到缺陷得到适当解决之前，灯不会被运送到公众那里。相反的 Heisenbug 情况是灯只会在恰当的条件下发出火花并着火，这意味着缺陷直到灯被运送并开始烧毁客户的家才会被发现。 “可预测”意味着“如果失败，每次都以相同的方式失败”。 “正确”意味着“成功通过测试，但我们不知道它们是否安全使用[可能它们不安全]”。现在，他最终确实关心正确，但 Facebook 在 React 周围做出的选择源于一种认识，即可预测是成为正确的手段。制造商不可以运送一些在消费者插上电源时总是会发出火花并着火的东西。然而，可预测将问题移到前台和中心，而不是偶尔出现在软件迷宫的隐蔽和难以捉摸的相互作用的结果。Flux 和 ReactJS 中的选择旨在使失败显而易见，并将其显现出来，而不是仅在软件迷宫的角落和缝隙中显现。

Facebook 对共享可变状态的战争在他们对聊天 bug 的经验中得到了体现。聊天 bug 成为用户的一个主要关注点。Facebook 的一个重要的醒悟时刻是当他们宣布一个完全无关的功能时，第一个评论是要求修复聊天；它获得了 898 个赞。此外，他们评论说这是一个比较礼貌的请求之一。问题在于未读消息的指示器在没有消息可用时可能会有一个幻影正消息计数。事情来到一个人们似乎不关心 Facebook 正在添加什么改进或新功能，而只是想让他们修复幻影消息计数的地步。他们继续调查并解决边缘情况，但幻影消息计数不断重现。

除了 ReactJS 之外，解决方案还可以在下一节讨论的 flux 模式或架构中找到。在一种情况下，不太多的人感到舒服进行更改，突然之间，更多的人感到舒服进行更改。这些事情简化了事情，以至于新开发人员通常不需要真正需要之前给予的启动时间和处理。此外，当出现错误时，经验丰富的开发人员可以合理准确地猜测系统的哪个部分是罪魁祸首，而新手开发人员在处理错误后往往会感到自信，并对系统的工作原理有一般的了解。

# Flux 架构

Facebook 在与 ReactJS 相关的一种方式是宣布对 heisenbugs 宣战，这是通过对可变状态宣战来实现的。Flux 是一种架构和模式，而不是一种特定的技术，它可以与 ReactJS 一起使用（或不使用）。它有点像 MVC，相当于该方法的一个松散竞争对手，但它与简单的 MVC 变体非常不同，并且旨在具有提供单向数据流的“成功深渊”，就像这样：从动作到分发器，然后到存储，最后到视图（但有些人说这两者是如此不同，以至于在尝试确定 Flux 的哪个部分对应于 MVC 中的哪个概念挂钩方面，直接比较 Flux 和 MVC 并不是真的有帮助）。动作就像事件-它们被送入顶部漏斗。分发器通过漏斗并不仅可以传递动作，还可以确保在前一个动作完全解决之前不会再发出任何其他动作。存储与模型有相似之处，也有不同之处。它们像模型一样跟踪状态。它们不像模型，因为它们只有 getter，没有 setter，这可以阻止程序的任何部分能够更改 setter 中的任何内容。存储可以接受输入，但以一种非常受控的方式，通常存储不受任何拥有对其引用的东西的控制。视图根据从存储获取的内容显示当前输出。在某些方面，存储与模型相比具有 getter 但没有 setter。这有助于培养一种不受 setter 访问者控制的数据流。事件可以作为动作传播，但分发器充当交通警察，并确保只有在存储完全解决后才处理新动作。这大大降低了复杂性。

Flux 简化了交互，使得 Facebook 开发人员不再遇到微妙的边缘情况和不断出现的错误-聊天错误最终消失了，再也没有出现。

# 从绝望的深渊到成功的深渊

Louis Brandy 警告了 C++的危险，冒着引起争议的风险，他称之为*第二系统效应*的最大例子（[`tinyurl.com/reactjs-second-system`](http://tinyurl.com/reactjs-second-system)），自 OS/360 项目以来。在一个模糊的*XKCD*风格的图形中，他说“永远不要相信一个说他懂 C++的程序员”（[`tinyurl.com/reactjs-cpp-valley`](http://tinyurl.com/reactjs-cpp-valley)）。

以下图表显示了 C++程序员的信心水平：

![从绝望的深渊到成功的深渊](img/B04108_03_1.jpg)

他继续说：

> *“程序员（特别是那些来自 C 语言）可以很快地掌握 C++并感到非常熟练。这些程序员会告诉你他们懂 C++。他们在撒谎。当程序员继续学习 C++时，他会经历这种挫折的低谷，他完全认识到了语言的复杂性。好消息是很容易区分 C++程序员在低谷之前和之后的状态（在这种情况下是面试）。只要提到 C++是一种非常庞大和复杂的语言，低谷后的人会告诉你他们对语言有 127 种不同的小挫折。低谷前的人会说，“是的，我猜。我的意思是，这只是带有类的 C 语言。”*

Eric Lippert 告诉我们的内容并不仅适用于 C++程序员；它导致了比 C++更大的东西：

> *我经常把 C++看作是我自己的绝望之坑编程语言。不受管理的 C++使人很容易陷入陷阱。想想缓冲区溢出、内存泄漏、双重释放、分配器和解分配器不匹配、使用已释放的内存、无数种方式来破坏堆栈或堆——这些只是一些内存问题。C++经常把你扔进绝望之坑，你必须爬上质量之山。（不要与攀登疯狂悬崖混淆。那是不同的。）*
> 
> *现在正如我之前所说的，C#的设计不是一个减法过程。它不是“去掉愚蠢部分的 C++”。但是，不看看其他语言的问题并努力确保这些问题不会出现在 C#用户身上，那我们就太愚蠢了。我希望 C#成为一种“质量之坑”语言，一种鼓励你一开始就编写正确代码的语言。你必须非常努力才能在 C#程序中写出缓冲区溢出的错误，这是有意为之的。*
> 
> *我从未在 C#中编写过缓冲区溢出。我从未在 C#中写过意外地在另一个作用域中隐藏变量的错误。我从未在 C#中在函数返回后使用堆栈内存。我在 C++中做了所有这些事情，这不是因为我是个白痴，而是因为 C++使得做所有这些事情变得容易，而 C#使得这变得非常困难。使得做好事情变得容易显然是好事；考虑如何使做坏事变得困难实际上更重要。*

或者，就像在 Python 邮件列表上发生的那样，一个明显的 133t hax0r 拼写的人问如何在 Python 中编写缓冲区溢出，而更资深的列表成员之一回答说：“很抱歉，但 Python 不支持该功能。”这个梗的重点是，有人询问如何找到特定类型的漏洞，却得到的答复是 Python 的语言设计中已经排除了基本类型的缺陷。正如对 C#所指出的，字符串的处理方式是合理的，没有任何天真的使用会导致缓冲区覆盖漏洞。

Eric Lippert 是 C#中的一个关键人物，他的帖子清楚地阐明了如何明智地反对 Bjarne Stroustrup 的话：

> *“我们思考/编程的语言与我们能够想象的问题和解决方案之间的联系非常紧密。因此，出于消除程序员错误的目的限制语言特性至少是危险的。”*

今天不同意 Stroustrup 的人可能不会质疑这两个句子，但可能只会质疑第二个句子：语言与解决方案之间的联系似乎确实是真实的，但对于语言特性和成功之坑却具有相反的含义。像* Douglas Crockford *的书《JavaScript：好部分》中的决定可能会考虑到这样的因素。这样或那样的细节可能会受到质疑，但使用 JavaScript 的精选子集并完全忽略其他部分的核心思想源于寻求和改装成功之坑的事实几乎是理所当然的一旦可能性被指出。

所有这些都导致了 Rico Mariani 在某种程度上提出的一个观点，与绝望之坑的相反。成功之坑与峰顶、山峰或穿越沙漠寻找胜利的旅程形成鲜明对比。我们希望我们的客户简单地“陷入”使用我们的平台和框架的成功实践。在我们让人陷入麻烦变得容易的程度上，我们失败了。

# 完成 UI 拆解和重建

迪杰斯特拉的一句话，深受 ReactJS 开发者如 Pete Hunt 的喜爱，是：我们的智力更适合掌握静态关系，而我们对于可视化时间演变过程的能力相对较差。因此，我们应该尽最大努力缩短静态程序和动态过程之间的概念差距，使程序（在文本空间中展开）和过程（在时间中展开）之间的对应尽可能简单。

ReactJS 在概念上发挥了这种优势的一种方式是，将所有东西都清除并重新渲染，以便程序和过程之间的对应关系变得简单。您不需要跟踪 DOM 的当前状态和需要记住的 300 个 jQuery 更改，以便准确地从一个状态过渡到另一个状态。您只需要告诉它现在应该看起来如何。实际上，ReactJS 并不会在底层将所有东西都清除；它有相当复杂的功能，可以创建一个闪电般快速的纯 JavaScript 合成 DOM（这个合成 DOM 也使得在 Internet Explorer 8 中实现 HTML5 功能成为可能），并协调和进行尽可能快速的更改（在这种情况下，“快速”包括在非 JIT iPhone 5 上实现每秒 60 帧的更新的令人印象深刻的壮举）。然而，从概念上讲，使用 ReactJS 意味着简单地将所有东西都视为被清除并从头开始重新绘制，并信任 ReactJS 将汇集所有需要的魔法粉来进行最小限度的 DOM 更改。这是为了根据请求更新页面，可能不会丢失现有的输入或惯性滚动。

ReactJS 提供了优化钩子，以提供对渲染内容的更精细控制。这些都有很好的文档说明，但实际上很少需要使用。记住 Knuth 的话，“过早优化是万恶之源。”我自己并没有使用这个优化功能，尽管 ClojureScript 中用于 ReactJS 的 Om 绑定要快得多，因为它们只需要检查引用相等性，而不需要深度相等性，因为在 ClojureScript 中对象是不可变的，尽管我做了一个次要的用法，要求 ReactJS 放弃对 DOM 的某些部分的所有权，以便它能够与第三方功能良好地配合。在第十一章中，*使用实例演示 JavaScript 中的函数响应式编程的一部分 IV – 添加一个草稿并把它全部放在一起*，有一个这样的例子。ReactJS 默认情况下非常高效，而不仅仅是在您定制其默认行为方面。

# JavaScript 作为一种特定领域的语言。

模板系统中的一种广泛实践是为模板提供 DSL。在通常的过程中，比如在前端使用 underscore（[`underscorejs.org`](http://underscorejs.org)）或在后端使用 Django 模板（[`djangoproject.com`](http://djangoproject.com)）时，都提供了一个精心选择但故意功能不足的模板语言。例如，在 Django 中，故意限制了功能，以便将模板交给不受信任的设计师，设计师无法做任何可能损害不希望被损害的任何内容的事情。

这也许是一个吸引人的特点，但它表明了一种有限的模板语言。如果模板需要更强大的东西，它们将束手无策，直到它们的任何要求都能在服务器端进行非标准调整。与哥德尔的不完备定理和停机问题相关的一个基本观点是，如果你把某人的手绑得足够紧，以至于这个人原则上不能造成任何伤害，你就显著地限制了这个人能做的事情。最好的结果至少需要一点信任。如果你希望人们能够做出最有用的贡献，他们可能不会能够在双手被束缚的情况下做到这一点。

在 ReactJS 中，模板的 DSL 是 JavaScript，具有其全部功能。有些人也许会觉得让设计师直接使用原始 JavaScript 很奇怪；ReactJS 的人似乎采取了*给它五分钟*的方法，并说设计师比他们有时被认为的更聪明，非常有能力编写非常特定类型的 JavaScript 代码。但这也意味着，如果你有一个特殊情况，你复杂的情况需要你做一些在某些特定的、故意不够强大的模板语言中被排除的事情，这是个好消息。在 ReactJS 中，你可以充分利用 JavaScript 的全部功能来处理模板。在 ReactJS 中，如果你愿意，你也可以使用一种非常有限的语言子集用于模板，Pete Hunt 和其他人似乎相信设计师足够聪明，能够处理它。但更好的消息是，当你有一个需要真正强大的困难情况时。你拥有 JavaScript 提供的全部功能，这会产生很大的不同。

# Big-Coffee Notation

Steve Luscher 是 Facebook 之外的 ReactJS 大师和爱好者，后来被 Facebook 聘用，他在一段关于 React 的视频中谈到了 Big-Coffee Notation。基本观点是，我们不应该只使用大 O 符号来表示运行时复杂度（运行时随问题规模粗略增长的时间，或者偶尔其他维度，比如内存使用），而是应该有一个 Big-Coffee Notation 来表示对于可怜的开发者来说需求如何增长，他们必须将这些东西保存在自己可怜的、充满咖啡因的大脑中。

Gerald Weinberg 的经典著作《计算机编程心理学》详细阐述了一个基本观点。核心观点是*程序员编程计算机*不仅仅是涉及计算机的活动，也是涉及人的活动，我们最好也将其视为这样的活动。也许我们也应该了解计算机的限制，但人类这一方面并不是微不足道的。魏恩伯格可能是第一个提出这一观察的人，或者可能在他之前有人提出过，但无论哪种情况，这一观察自被吸收以来一直是严肃软件工程文献的基石。例如，在 Steve McConnell 的《代码大全：软件构建实用手册》中，这是一个核心观点。我们不会对这个想法进行全面探讨，但它是值得探索的，特别是如果你以前没有探索过的话，Big-Coffee Notation 正好属于这一领域。核心思想是，除了跟踪大 O 符号或复杂度，我们还应该关注开发者在适当需求方面如何扩展越来越复杂的问题。这些需求是指需要记住多少移动部分。

在大 O 符号表示法中，根据上下文的不同，有各种*运行时复杂度*，它们为运行时间在解决越来越大的问题时提供了一个上限。*O(1)*运行时对于任何用例都有一个固定的上限。*O(log n)*与某些数据结构上的单元操作相关。*O(n)*也被称为**线性**，指的是运行时在运行时间上有一个线性的上限。你可以保证至少有一些常数乘以项目的数量。*O(n log n)*可能是下一个重要的步骤，它与某些排序算法相关。*O(n ^ 2)*被称为**二次**（所有先前提到的复杂度都被称为次二次，意思是比二次更快），当事情真的不能扩展到大量时，它可能被视为一个阈值复杂度。*(O(n * (n – 1))*也被认为是二次，并被包含在*O(n ^ 2)*之下。之后还有一些较慢的多项式时间和指数时间，而不排除还有更慢的升级，比如阶乘。NP 完全性的著名问题是一个问题，即某些已知可以在指数时间内解决的 NP 完全问题是否总是可以在多项式时间内解决。

Steve Luscher 关于命令式 UI 和声明式 UI 之间的区别的演示是，如果有人要制作一个小部件来显示他们队列中未读项目的数量，命令式 UI 在两个状态之间进行一次转换，使可怜的程序员需要跟踪![The Big-Coffee Notation](img/B04108_03_02.jpg)，这意味着相对于状态数量，程序员大脑中的项目数量呈二次或![The Big-Coffee Notation](img/B04108_03_04.jpg)复杂度。如果有三个状态，就有六个转换。如果添加第四个状态，将有 12 个，或者是两倍的转换。添加第五个状态，你将看到 20 个转换。程序员理解代码的解释是*二次*，意味着*陡峭*。然而，如果你以声明方式给出 UI 代码，比如在 ReactJS 编程中，你只需描述每种可能的渲染状态一次。三种状态只需要三种描述。四种状态只需要四种描述。五种状态只需要五种描述。这只是![The Big-Coffee Notation](img/B04108_03_03.jpg)，或者是线性的。对于可怜的程序员的咖啡因大脑来说，这种不断升级的需求来跟踪代码发生的事情要少得多。就像一个快速的算法一样，运行起来要少得多。

我没有听说过 Dijkstra 的《谦逊的程序员》被 ReactJS 社区引用过，但在程序员中，知识谦卑是一种美德，并且在软件工程文献中长期以来一直被认可。它在经典著作中得到强调，比如《代码大全：软件构建的实用手册》，程序员们并不是分为大脑和小脑，而是分为知道自己有小脑的人和有小脑但不自知的人。编程的卓越部分源于对自己认知限制的认识。Dijkstra 写道：

> “胜任的程序员充分意识到自己头脑的严格有限；因此，他以完全谦卑的态度对待编程任务，而且在其他方面，他像瘟疫一样避开了聪明的把戏。在一个众所周知的对话式编程语言的情况下，我从各个方面听说，一旦一个编程社区配备了它的终端，就会出现一个特定的现象，甚至已经有了一个成熟的名字：它被称为“一行代码”。它有两种不同的形式：一个程序员把一行程序放在另一个程序员的桌子上，要么他自豪地告诉它做什么，然后问“你能用更少的符号编码吗？”——好像这对概念有任何重要性一样！——要么他只是问“猜猜它是做什么的！”。从这个观察中，我们必须得出结论，这种语言作为一种工具是聪明把戏的一个开放邀请；虽然这可能是它吸引力的解释之一，即对那些喜欢展示自己有多聪明的人来说，但很抱歉，我必须把这看作是对编程语言说的最严厉的话之一……*

这个挑战，也就是面对编程任务，已经教会了我们一些经验教训，我选择在这次讲话中强调的是：

> 我们将做得更好的编程工作，只要我们以充分的欣赏其巨大困难的态度来对待这项任务，只要我们坚持使用适度和优雅的编程语言，只要我们尊重人类思维的固有局限，并以非常谦卑的程序员的态度来对待这项任务。

# 总结

我们刚刚快速浏览了一些围绕使用 ReactJS 进行响应式编程的理论。这包括声明式编程，这是 ReactJS 的卖点之一，它提供了比命令式编程更容易处理的东西。Heisenbugs 的战争是 Facebook 所做决定的一个主要关注点，包括 ReactJS。这是通过 Facebook 宣布对共享可变状态的战争来实现的。Flux 架构被 Facebook 与 ReactJS 一起使用，以避免一些恶心的 bug 类。成功的陷阱和绝望的陷阱，从他人的痛苦中学习，这种痛苦集中在与 C++编程语言的联系上，并且看看我们应该追求什么。

我们涵盖了完整的 UI 拆卸和重建，提供了一个简单的替代方案来跟踪状态以更新界面。我们还将 JavaScript 作为 DSL，看作是设计 ReactJS 的一个有意的决定，旨在给你尽可能多的权力。然后讨论了大咖啡符号与健康认识自己的限制的关系，而不是让他们摔断腿，这是可以预防的。

在我们的下一章中，我们将继续通过查看使用 ReactJS 构建的用户界面的具体案例来进行讨论。
