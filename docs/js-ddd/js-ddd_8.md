# 第八章。看到一切如何结合在一起

所有软件项目都是特殊的，永远不可能有一种“一刀切”的方法，但正如我们所看到的，对开发的各种不同方法都进行了深思熟虑。一个项目经历了许多开发阶段，通常开始探索基本的想法，有时甚至在那个阶段我们都不能确定项目的领域是什么。然后我们开始分解应用程序的某个核心能力，核心领域开始逐渐发展。在这个阶段，业务专家的参与至关重要，以确保领域与业务需求保持一致，并且项目不会因误解而岔道，同时通用语言也在不断发展。项目往往会从一个或两个开发人员发展成一个更大的团队，团队组织变得更加重要，因为我们需要开始考虑开发中涉及的沟通开销，因为不再成立的假设是每个人都对代码库中的几乎所有内容都很熟悉。在这一点上，团队可以决定采用面向领域的方法，并开始更详细地对现在已经建立的领域进行建模。尽管在后期阶段可能不需要业务专家的每日参与，但持续的参与对确保项目不偏离核心领域需求至关重要。

这种理想化的项目增长形式取决于多种环境因素，团队不仅需要做出所描述的选择，应用程序也需要准备好采用这种方法。我们之前看到，并不是所有项目都适合面向领域的方法，还有许多不同类型的 JavaScript 项目，可以在开发的不同阶段适用这种方法。

在本章中，我们将看看不同的项目、一些领域以及这两个因素，以及面向领域驱动设计如何适应整个画面。我们将探讨：

+   涉及 JavaScript 的不同类型的项目

+   客户端和服务器端开发如何影响项目

+   不同问题及其适用于面向领域驱动设计的程度

+   面向领域驱动设计的示例领域

# 不同类型的 JavaScript 项目

JavaScript 作为一种非常多才多艺的语言，已经在不同的开发阶段取得了成功。最初被构想为在浏览器中实现更动态的行为，它不仅征服了使用浏览器作为平台和运行时的开发复杂的客户端应用程序领域，而且现在也在使用 Node.js 的服务器端应用程序中得到了广泛应用。

从通过加入效果使文档看起来更具交互性，到在客户端渲染整个应用程序，这是一个广泛的复杂性和应用程序的范围。一些可能需要更多关注应用程序设计的方法，一些可能最好通过保持逻辑简单和本地化的较小脚本式方法来提供最佳维护。

## 增强用户体验

许多商业应用程序完全适合由一些页面组成的应用程序。在服务器端渲染所有页面在最长时间内一直是最简单的方法，而且很可能仍然是最简单的方法，因为它将技术堆栈保持在最低水平。一旦页面开始变得复杂，增加一些动态元素可以极大地改善用户体验。这些元素可以用于指出功能或引导用户。例如，对输入进行一些客户端验证可能非常有用，这样用户就不会发送明显无效的请求，并且不必等待服务器的缓慢响应：

```js
<form>
  <label>
    Check Me: <input type="checkbox" id="check-me"></input>
  </label>
  <button id="disable-me">
    I can be clicked if you checked the box
  </button>
</form>
```

这样的表单经常会出现，我们希望在复选框被选中之前阻止用户点击按钮，并且在请求有效之前可能还需要达成一些协议。在服务器端进行验证很重要，但在点击按钮之前向用户提供一些反馈将是一个很大的增强。一个小的 JavaScript 函数，比如下面的例子，可以很容易地实现这一点：

```js
window.onload = function () {
  var checkMeBox = document.getElementById("check-me")
  var disableMeBtn = document.getElementById("disable-me")

  function checkBoxHandler() {
    if(checkMeBox.checked) {
        disableMeBtn.removeAttribute("disabled")
      } else {
        disableMeBtn.setAttribute("disabled", "true")
      }
    }

  checkBoxHandler()
  checkMeBox.onclick = checkBoxHandler
}
```

我们检查复选框的值，并根据需要停用或激活按钮。

这是一个业务规则，我们希望在代码中看到它的体现；另一方面，该规则也在服务器端执行，因此不需要使其在任何情况下都能正常工作。这类问题经常在应用程序中出现，我们不希望立即使用过于强大的工具。例如，如果我们开始将表单对象设计为业务对象，并封装表单是否“可发送”的规则，我们可能会得到一个更清晰的设计，但代码的可读性会受到影响。这是在大部分是 UX 增强的项目中不断权衡的问题。通常来说，将视图代码与业务规则混合在一起是不好的；另一方面，过度设计非常小的增强功能，比如前面的代码，很容易在创建更复杂的基础设施以获得更清晰的模型时失去意义。

像这样的 UX 增强并不适合领域驱动的方法，因为业务逻辑的知识将不得不被复制，需要一个单独的适配器来处理 HTML 表示和服务器模型表示。这样的适配器会带来一些额外的开销，并且根据封装的功能量，它们未必是有意义的。随着客户端代码的增长并向应用程序发展，这种做法开始变得更有意义。

## 单页应用程序

近年来，厚客户端应用程序的概念再次变得更加普遍。在 Web 的早期，网站是静态的，后来使用 JavaScript 进行增强以便于导航或基本用户交互。近年来，浏览器中的客户端应用程序开始增长到一个程度，其中很多业务逻辑都存在于前端，并且前端本身成为了一个真正的应用程序。

### 提示

很久以前，当世界仍然围绕着大型机转动时，计算环境中的客户端通常是接受用户输入并显示输出的哑终端。随着硬件变得更加强大，越来越多的业务逻辑被移至客户端进行处理，直到我们达到了真正的客户端应用程序，比如运行 Microsoft Office。现在我们可以在浏览器中看到同样的情况，随着应用程序变得更加复杂，浏览器的功能也变得更加强大。

单页应用程序通常在 JavaScript 中实现大量的业务逻辑，作为向服务器查询的厚客户端。这样的应用程序有很多例子，从更传统的面向文档的风格到在浏览器中使用 HTML、CSS 和 JavaScript 作为运行环境的应用程序，更多或更少地完全接管了浏览器。

在开发基于浏览器的应用程序时，底层代码的结构比增强网页功能时更加重要。问题空间被分成几个部分。首先，代码需要以一种能够在应用程序增长和变化的情况下保持可维护性的方式进行组织。随着前端应用程序代码现在实现业务逻辑的更大部分，维护负担增加，重写更大部分的风险也随之增加。应用程序对系统的投资很大。其次，尽管客户端的技术堆栈似乎相当固定，包括 HTML、CSS 和 JavaScript，但最佳实践和浏览器对功能的支持正在快速发展。同时，向后兼容性至关重要，因为开发人员对用户的升级过程没有太多控制。第三，客户端应用程序的性能方面很重要。尽管 JavaScript 运行时引擎的速度提升已经很大，但用户对应用程序的期望越来越高，更重要的是，他们也在同时运行越来越多的应用程序。我们不能指望我们的单页应用程序拥有机器的大部分，但我们必须谨慎使用资源。

性能需求增加与灵活性需求之间的对比是驱动框架和技术的发展，以支持客户端应用程序的开发。我们希望框架在保持灵活性的同时避免过度抽象，这可能会在性能方面对我们的应用程序造成成本。另一方面，我们的用户期望有更多的互动，这需要越来越复杂的应用程序代码来管理，因为客户端应用程序的规模不断增长。

### 不同框架及其影响

JavaScript 框架的世界非常广阔，不断发布和放弃具有不同承诺的新框架。所有框架都有它们的用例，并且，虽然提倡不同的架构，但都考虑提供组织 JavaScript 应用程序的方式是必不可少的。

一方面，有一些小型框架或微框架，几乎像库一样，只提供最基本的组织和抽象。其中最知名且可能是最广泛使用的是 Backbone。目标是提供一种在客户端路由用户的方式——处理 URL，并在浏览器中重写和更新应用程序状态。另一方面，状态封装到模型中，提供和抽象对内部客户端状态的数据访问，以及远程服务器端状态，因此可以管理这两者的同步。

在光谱的另一端，我们发现更大的应用程序框架，其中一个流行的是 Ember，在浏览器中提供更集成的开发体验。处理数据同步，在应用程序页面中处理太多不同的控制器，以及通过模板将不同的对象呈现到浏览器的高级视图层，包括界面和后端模型表示之间的数据绑定。这在很大程度上符合 Smalltalk 的老派方法，比如模型视图控制器模式。

使用 Ember 为我们的兽人命名的简单应用程序可能是这样的：

```js
window.App = Ember.Application.create()

App.Orc = Ember.Object.extend({
  name: "Garrazk"
})

App.Router.map(function () {
  this.route(' index' , { path: ' /'  })
})

var orc

App.IndexRoute = Ember.Route.extend({
  templateName: ' orc' ,
  controllerName: ' orc' ,
  model: function() {
    if(!orc) orc = App.Orc.create();
    return orc
  }
});

var names = [ "Yahg", "Hibub", "Crothu", "Rakgu", "Tarod", "Xoknath", "Gorgu", "Olmthu", "Olur", "Mug" ]

App.OrcController = Ember.Controller.extend({
  actions: {
    rename: function () {
      var newName = names[Math.floor(Math.random()*names.length)];
      this.set("model.name", newName)
    }
  }
})
```

顶级应用程序管理上下文，然后我们定义路由和控制器，就像大多数 MVC 应用程序中所做的那样。这种模型相当适用，并允许非常不同的应用程序。优点是我们可以很大程度上依赖预构建的基础设施。例如，在前面的代码中，路由和控制器之间的连接可以相当容易地设置，通过声明性地分配`templateName`和`controllerName`来使用。此外，与视图的连接几乎已经完成，允许我们定义主应用程序模板如下：

```js
<html>
  <head>
    <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
    <script src="http://builds.emberjs.com/release/ember-template-compiler.js"></script>
    <script src="http://builds.emberjs.com/release/ember.min.js"></script>
    <script src="/app.js"></script>
  </head>
  <script type="text/x-handlebars" data-template-name="orc">
    <p> ORC! {{ name }} </p>
    <button {{action "rename"}}>Give me a Name!</button>
  </script>
</html>
```

使用`Handlebars.js`进行模板化，并使用`preassign`模型进行交互，Ember 被设计为能够扩展非常大的前端应用程序，接管浏览器交互并提供完整的应用程序框架。

在这方面，我们几乎可以找到中间的一切。在领域驱动开发的世界中，我们现在必须选择最适合我们的应用程序和我们的开发风格。似乎较小的框架更适合领域驱动设计，因为它允许开发人员有更多的影响力，但这未必是真的。对我们来说重要的是我们如何与框架进行连接。就像我们在服务器端与之交互一样，我们希望将我们的代码抽象为简单的 JavaScript 对象，将框架视为一个层，用于获取用户显示的内容和用户输入返回到我们的领域层。我们希望我们的领域层尽可能地与框架分离。随着当今开发中模型-视图-控制器等组织形式的普及，只要我们不陷入围绕框架开发的陷阱，而是坚持讨论的组织形式，作为框架所需功能的实现方式，框架允许更好地进行组织上的分离。

### 在客户端渲染

根据我们正在开发的应用程序，完全采用客户端应用程序可能不是最佳选择。大多数业务应用程序最终都是非常任务导向的，通过表单操作数据，并根据此输入触发一些逻辑。操作的结果然后以类似文档的方式反映出来。这代表了大多数业务的做法，它涉及一个过程来完成一个任务，并以报告结束。考虑一下我们在整本书中一直在开发的应用程序，我们会发现一个类似的模式。我们一直在开发的应用程序的一部分包括几个步骤，涉及地牢主持人通过填写有关即将发生的运输的细节来触发某个特定操作。然后后端决定是否满足条件，是否可以满足请求，并触发适当的操作。大部分逻辑都存在于应用程序的服务器端，并且由于一致性问题，也需要在那里存在。另一方面，客户端非常注重表单，任务涉及一个或多个表单步骤，需要根据给定任务的流程来完成。流程和任务的逻辑在服务器端，因此完全采用客户端应用程序将需要复制大量服务器知识，以给予客户端应用程序的感觉，但然后我们仍然需要与后端进行确认。这在很大程度上消除了将逻辑移动到客户端的好处。

在这种情况下，采用一种折中的方法是很有道理的，可以确保利用服务器端的高级调试功能和监控，同时仍然使应用程序具有更流畅的感觉。这个想法是渲染要放在页面上的 HTML 片段，但是通过 JavaScript 将它们放在页面上，从而避免完全替换整个页面。最常用的库用于实现这一点是**pjax**，用于请求 HTML 片段，它又使用 jQuery 将片段放在页面上：

```js
var express = require("express")
var app = express()

app.get("/rambo-5", function (req, res) {
  res.send("<p>Rambo 5 is the 5\. best movie of the Rambo series</p>")
})

app.use(express.static(' public' ));

var server = app.listen(3000, function () {
  console.log("App started...")
})
```

在这个例子中，pjax 需要服务器发送一个 HTML 片段，作为请求的结果放在页面上。这只是一个包含有关 Rambo 电影的一些信息的段落标签：

```js
<!DOCTYPE html>
<html>
  <head>
    <script src="/jquery.min.js"></script>
    <script src="/jquery.pjax.js"></script>
    <script>
      $(document).ready(function () {
        $(document).pjax(' a' , ' #container' )
        var date = new Date()
        $("#clock").html(date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds())
      })
    </script>

  </head>
  <body>
    <h1>About Rambo</h1>
    <div id="container">
      Go to <a href="/rambo-5">Rambo 5</a>.
    </div>
    <div>This page rendered at: <span id="clock"></span></div>
  </body>
</html>
```

在客户端，我们只需要让 pjax 劫持容器内的所有链接，使其发送一个 pjax 请求并插入适当的内容。最终结果是一个表现得像一个普通 HTML 页面的页面，但是在点击时不会完全刷新。它只会重新加载适当的部分并更新窗口位置。

当构建服务器密集型应用程序并且仍然能够维护类似应用程序的流畅界面而不需要大量的完全客户端渲染开销时，这种方法可能非常有用。再次，我们可以看到这里有很大的区别，使得前端更像是一个轻客户端，因此这可能不是面向域驱动的首选方法，但是与使用这种方法构建的后端密切合作，因为它现在是关于应用程序逻辑的单一真相来源。

## 在服务器端使用 JavaScript

JavaScript 作为一种语言，尽管它是为浏览器开发的，但并不仅限于在浏览器上下文中执行。浏览器自然包含了一个用于在页面上下文中执行 JavaScript 的环境。当我们想要在浏览器之外运行 JavaScript 时，总是有直接通过 JavaScript 引擎执行的选项。有多种不同的引擎可用，例如 Mozilla 的 Spidermonkey 或 Google 的 V8。显然，仅仅拥有 JavaScript 是不够的，因此我们需要访问文件、套接字和其他许多其他东西，以便能够有效地处理服务器端代码。

Node.js 接管了这一部分，将 Google V8 引擎与标准的 POSIX 函数捆绑在一起，用于访问系统级部分。这绝不是第一个，还有来自 Mozilla 的 Rhino，将 Java 生态系统与 Java 捆绑在一起，以允许访问 JavaScript 标准库之外的所有部分：

```js
Rhino 1.7 release 5 2015 01 29
js> var file = new java.io.File("./test.txt");
js> importPackage(java.nio.file)
js> Files.readAllLines(file.toPath())
[this is a test text file]
```

在 Node.js 中，同样的事情看起来有些不同，更像我们从 JavaScript 期望的：

```js
> var fs = require("fs")
> fs.readFile("./test.txt", "utf8", function (err, data) {
... if(err) {
..... return console.log(err)
....}
... console.log(data)
..})
> this is a test text file
```

有了交互的基础，我们可以构建复杂的服务器端应用程序，并利用服务器端开发的特性，这在书中一直都有。

### 提示

在即将推出的 ECMAScript 6 标准中，将引入一种新的模块语法，以增加客户端和服务器端 JavaScript 应用程序的模块化。ECMAScript 6 几乎已经完成，但在撰写本文时还没有到处都可用。关于即将到来的变化，特别是关于 ECMAScript 6 模块的一个很好的信息来源是[`www.2ality.com/2014/09/es6-modules-final.html`](http://www.2ality.com/2014/09/es6-modules-final.html)。

### 受控环境的优势

本书的大部分依赖 Node.js 作为执行环境的原因是它提供了一组我们可以依赖的固定功能。另一方面，浏览器一直非常灵活和可变。这在开发业务应用程序时是一个很大的优势。作为开发人员，我们当然总是希望利用最新和最好的技术，而在合适的地方依赖这些技术是很有意义的，但我们也需要意识到稳定的平台在很大程度上是一个巨大的优势。

如果我们想要建模应用程序的业务逻辑，我们几乎不依赖于任何新技术。我们需要一个稳定的环境，可以执行我们已有的内容和将来会保留的内容。当然，JavaScript 的优势在于我们可以在客户端和服务器端执行，这意味着如果我们以后决定将某些逻辑转移到客户端，我们可以这样做，并且仍然可以回退到服务器端执行规则以进行验证，如果需要的话。

### 高级模块化

过去，JavaScript 一直被称为浏览器语言，而且在很长一段时间内，加载脚本是超出语言本身范围的，而是由环境的 HTML 部分通过脚本标签处理的。

客户端更高级应用程序的崛起和服务器端 JavaScript 的崛起改变了语言。这种语言正在发展，下一个版本将包括一个模块标准。目前，有多种加载其他资源的方式，使用其中一种是个好主意，具体是什么并不重要。重要的是，加载外部模块使我们能够更好地将代码分离成逻辑单元，摆脱了许多客户端 JavaScript 程序看起来像 1000 多行文件的情况。在服务器端，这个问题已经解决，而客户端还没有远远赶上。

考虑到这些不同类型的 JavaScript 程序和挑战，我们可以思考在设计业务应用程序时我们的目标是什么，以及我们如何看待领域驱动设计在开发过程中的作用。

# 不同类型的复杂性

每个业务应用程序在开发过程中都面临着不同类型的问题。领域驱动设计的目标是通过提供一种语言以及一组对象在领域中的交互规则，来隔离应用程序的复杂性，使其易于更改和维护。

正如我们在整本书中所看到的，领域驱动设计的核心是建模业务逻辑，以便领域专家可以评判和评估。这是应用程序的重要部分，如果做得好，可以在整个开发周期中节省很多麻烦。在通过领域驱动设计驱动应用程序时，我们需要确定核心领域及其子领域。根据我们的领域是什么，纯粹的业务复杂性是需要建模的，但不是唯一的复杂性。

并非每个应用程序都对业务规则复杂，也并非每个应用程序都适合以我们之前所见的面向对象的方式进行建模。有一些复杂性是不同性质的，更接近于计算机科学所考虑的核心问题领域，就像每个领域一样，它有自己特定的交流和建模方式，当我们遇到时，我们也应该使用这些方式。

### 提示

将计算机科学作为另一个业务领域是一种抽象化处理我们在处理计算机科学问题时遇到的复杂性的方式。往往，试图将这些问题暴露给业务领域本身是没有用的，只会导致更多的混乱。我们可以将与计算机科学相关的主题看作是我们与之交互以解决非常具体问题的核心，如果我们想要隔离它，就应该以这种方式发展它。

## 算法复杂性

| *在数学和计算机科学中，算法是一组自包含的逐步操作。* |
| --- |
| --*维基百科* |

从本质上讲，我们所做的一切都可以描述为算法。它们可能非常简短和独特，但它们仍然是一系列步骤。例如，我们在业务应用程序中遇到的算法是必须执行的一系列步骤，比如启动囚犯运输。我们遇到的算法是业务规则，并且最好作为领域本身的一部分进行建模，因为它们直接涉及领域对象。然而，还有其他算法，我们可以从数学或计算机科学中重用，它们更抽象，因此不太适合业务领域。

当我们谈论算法复杂性时，我们最常指的是众所周知的算法，如树搜索或算法数据结构，比如列表或跳表。这些抽象的想法不太适合适应我们正在建模的领域，而是在某种程度上是外部的。当我们在领域中遇到问题，并且已知算法能够很好地解决问题时，我们应该利用这一事实，而不是用这些知识混淆领域，而是保持分开。

有一些应用程序，它们的算法复杂度很高，这些应用程序很可能不是领域驱动设计的最佳候选。一个例子是搜索，其中很多知识都存在于数据结构中，使得搜索变得高效，因此可以在更大范围内使用。重要的想法是，在这样的领域中，业务专家就是开发人员，我们应该以开发人员最擅长的方式处理领域。最基本的想法仍然是一样的——我们可能希望通过共同术语促进沟通，但在这种情况下，共同术语是开发人员特定的，最好的表达方式是通过代码，因此方法是编写代码并尝试。

## 逻辑复杂度

与算法问题密切相关的另一个领域是逻辑问题。根据领域的不同，这些问题可能经常出现，并且具有不同程度的复杂性。这类问题的一个很好的例子是任何类型的配置器，例如，一个允许您订购汽车的应用程序涉及到额外选项可能会发生冲突的问题。根据不同的额外选项和冲突的数量，问题可能会迅速失控。

在逻辑编程中，我们陈述事实，让引擎为我们推导可能的解决方案：

```js
var car = new Car()
var configurator = new Configurator(car)

configurator.bodyType(BodyTypes.CONVERTIBLE)
configurator.engine(Engines.V6)
configurator.addExtra(Extras.RADIO)
configurator.addExtra(Extras.GPS)

configurator.errors() // => {conflicts: [{ "convertible": "v6" }]}
```

在前面的例子中，配置器由规则引擎支持，这使得它能够确定配置中的潜在冲突并将其报告给用户。为了使其工作，我们创建了一个事实或约束的列表：

```js
configurator.engineConstraints = [
new Contstraint(BodyTypes.CONVERTIBLE, Engines.V8, Engines.V6_6L)
]
```

有了这一点，规则引擎可以在我们想要订购汽车时检查约束是否满足。

在应用程序中解决逻辑问题类似于解决算法问题，最适合于为此目的构建一个独立的系统，以领域特定的逻辑语言清晰地表达问题，然后将其包装在领域中。

## 业务规则

在开发业务软件时，我们最常面对的复杂性通常是客户定义的业务规则，我们为其开发软件。这些规则的复杂性往往不是因为规则本身很复杂，而是规则并不是一成不变的，行为可能会改变。更重要的是，它需要快速改变，以使软件对业务保持相关。

实施业务规则意味着跟踪业务需要做什么，这往往是基于业务领域专家头脑中的事实。对于建模领域的重要部分是提取这些知识，并与整个业务验证其有效性。这是一个坚实的领域模型努力产生差异的领域。

当我们能够与最了解领域的人谈论领域时，我们可以快速验证，如果我们与这个人分享共同的语言，他或她可以快速向我们解释新的规则。通常，复杂的数据结构和算法并不是构建应用程序的核心部分，这些部分可以通过外部提供系统进行优化，对领域的理解和灵活的建模是领域模型的力量。

# 适合领域驱动设计的领域

在本书中，我们专注于构建一个业务应用程序，从本质上来说，这确保我们不会过度或不足地预订我们的地牢，更具体地管理因地牢的限制而需要转移的囚犯。作为开发人员，我们必须严重依赖领域专家指导我们开发，因为我们还没有业务领域的必要知识。在这种情况下，建立一种语言非常方便，因为它允许我们以精确的方式讨论问题所在以及我们如何处理新规则。

以前，我们已经看到并非所有领域都适合这种策略，即使适合的领域中也可能包含最好由辅助系统处理的部分。特别是在启动新项目时，我们无法确定是否值得投资于繁重的领域层。

## 银行业应用

一个规范良好，有固定规则集，并且主要涉及数字的领域应该是由成熟软件服务的主要候选者，那么为什么会计软件并不多见，为什么银行要如此大力投资于他们的开发团队呢？

许多人从领域驱动的角度探索会计问题，问题主要出现在类似的领域。首先是一系列规则，尽管这些规则从外部看似乎定义得很好，但实际上包含许多需要覆盖并且正确覆盖的边缘情况，因为大量资金正在系统中流动。这些规则大部分由一组专家所知，他们的工作是在市场变化时调整这些规则。这带来了第二个问题，许多非常微妙的变化需要在整个系统中表达并保持一致。

因此，尽管表面上看来，关系数据库覆盖了银行应用中的许多情况，但对于变化所需的灵活性以及与银行专家进行大量沟通的内在需求使得银行成为领域驱动设计应用的一个很好的候选者，如果他们确实想要开始新的开发。

### 提示

银行业是那些最好由专家来处理的领域之一。如果没有必要构建自己的会计系统，最好购买现成的系统，因为领域的复杂性和错误的可能性非常高。

## 旅行应用

在整本书中，我们一直在关注与另一个领域驱动设计的主要候选者相关的领域，即旅行和相关预订管理。从软件角度来看，将地牢与酒店进行比较可能有点奇怪，但管理方式是相似的。我们试图在同时优化收入的同时管理过度预订和不足预订。

预订酒店是一个表面上看起来简单而明确定义的领域，但在深入挖掘时容易出现许多调整和复杂规则。例如，当适当查看数据库条目时，完全避免过度预订会相当容易，但这又违反了我们酒店最大化收入的目标。为了补偿最终客人的退出，需要一定数量的过度预订。

这并不是管理预订的唯一复杂部分，业务的一个重要部分是适应季节和当前的市场情况。在城市举办贸易展时预订酒店可能会比普通日子显著更昂贵，特别是如果没有预订整个贸易展的时间，因为这意味着房间可能会空着，即使在整个时间段内可以轻松预订。另一方面，合作伙伴折扣可能使这些展会期间的预订对某些人再次变得更便宜，我们希望确保在预订其他客人时有一定数量的房间可供这些人使用。所有预订还有多个需要管理的时间表，例如折扣窗口，退款窗口等。

近年来，使旅行更加有趣的领域驱动设计的原因是，其表示也在很大程度上发展。以前，系统被优化为通过电话或少量预订代理人操作，现在开始通过网络向公众开放。这种暴露导致请求量显著增加，也增加了所需的支持。甚至最近，这些系统不再直接操作，而是需要通过 API 访问以集成到搜索引擎中。

所有这些都使旅行变得复杂，远不止是从数据库中存储和加载操作；特别是，由于许多系统的集成与一般公众的访问结合在一起，对开发系统的能力来说不仅在性能方面，更重要的是在复杂性方面都带来了巨大的负担。

## 域先决条件

我们一直在研究的领域都涉及业务领域中不同形式的复杂性，这些领域都适合使用域驱动设计方法。在前面的章节中，我们已经看到了一些适合这种方法的领域。它们有什么共同之处？

正如之前所见，这一切都关乎我们需要解决的不同形式的复杂性。业务规则集快速变化的领域需要更多关注其建模，因为规则需要随着演变而调整。更重要的是，不断演变的规则意味着开发人员并不完全了解规则，因此业务专家需要大量参与。这意味着我们在域驱动设计中构建的语言很快就会得到回报。因此，域驱动设计的一个重要部分是它关乎开发人员的访问和理解领域的能力。我们希望能够迅速将业务专家整合到流程中，以避免误解。最终，业务专家是推动领域发展的人。我们作为开发人员，提供的是使业务更成功的软件。作为我们域驱动设计方法的一部分，我们确定了对业务现在真正重要的事情，以及如何使其更高效和更少出错。

现在从另一方面来看问题，仍然考虑访问，意味着其他系统对系统的访问需要简单。目前，这对许多领域来说是真实的，因为新设备不断流行，业务普遍朝着更高级别的业务集成发展。域驱动设计如何适应其中？关键再次是访问。我们希望能够提供多个可从外部访问的接口，具有相同的基本逻辑。在域驱动设计中，我们致力于构建强大的服务层，然后可以通过不同的接口将该层暴露给不同的系统，而无需复制逻辑，这将固有地增加部分和逻辑的分歧风险。

# 进一步阅读

正如本书的书名所暗示的那样，它已经受到埃里克·埃文斯在他的书《领域驱动设计：软件核心复杂性的挑战》*Addison-Wesley*中提出的想法的重大影响，我建议这本书作为后续阅读。他通过提供不同的例子，从经典的 Java 后端方法的角度更详细地介绍了一般方法。

另一本关于软件设计的后续阅读中不应该缺少的书是当然《企业应用架构模式》*Martin Fowler*，*Addison-Wesley*，它遵循了大多数面向对象开发中每天使用的模式，并更详细地介绍了这些模式。该书更加侧重于 Java 方面，但正如我们在本书中所看到的，以面向对象的方式使用 JavaScript 是非常可能的，并且在许多建模场景中会被推荐。

# 摘要

随着用 JavaScript 编写的应用程序变得越来越复杂，对更强大的应用程序设计的需求也在增加。浏览器应用程序正在增长，企业对它们的依赖也在增加。因此，曾经是后端开发领域的东西开始变得在前端开发中变得重要起来。长期以来，人们一直在不断演变后端应用程序的建模方式，以便能够灵活发展业务，现在浏览器应用程序也需要做同样的事情。多年来已经开发出了很多方法，有很多值得学习的地方，尽管有些方法并不直接适用于 JavaScript，甚至可能并不需要，但其中的一般思想非常适用。我希望我能在整本书中呈现一些这样的想法。

另一方面，随着 Node.js 作为应用程序开发平台的崛起和采用，JavaScript 也进入了后端，现在需要解决与 Java 或 Ruby on Rails 后端系统相同的挑战，这些挑战现在需要为 JavaScript/Node.js 解决。重要的是要忠于 JavaScript 的本质，因为使用 Node.js，目标通常是使系统更简单，更容易以更小的块进行管理。这反过来意味着 Node.js 后端采用了比传统的企业 Java 系统更轻的建模方法。这对开发人员来说是有力的，因为整体的大规模架构讨论朝着更实用的自下而上的方法发展。这并不意味着架构不重要，但是随着前端和后端系统之间复杂性的分离，采用更轻的方法可以更好地管理复杂性。
