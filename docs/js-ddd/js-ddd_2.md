# 第二章：找到核心问题

每一段软件都是为了解决一个问题而编写的，并且反过来也是这个确切问题的一个完全有效的解决方案。遗憾的是，一段软件完美解决的问题并不总是软件最初创建时的问题，甚至不是程序员在编写软件时所考虑的问题。编程的历史充满了开发人员尝试各种方法来完美陈述问题并实施解决方案的例子。基于瀑布模型开发软件是一个很好的例子，它未能兑现承诺。当你询问参与方失败的原因时，最有可能的原因是问题偏离了规范，或者规范被误解了——根据一方的说法，这是非常明显的。那么，为什么会这样呢？

在开始软件项目时，特别是一个由业务需求驱动的项目，我们着手建模现实世界的一部分，并对其应用一组约束和算法，以便简化业务中一个或多个参与方的工作。问题在于，遇到问题的一方很可能不是开发人员。这意味着开发人员首先必须了解请求的真正内容，才能知道应该开发什么。

我们如何在没有客户多年经验的情况下，对业务的某个部分有足够深入的理解？解决这个问题，也是最可能的问题，就是沟通。我们需要找到一种方式，足够深入地探索问题，并结合我们如何在软件中建模世界的知识，以便能够提出正确的问题。我们需要以一种不失去非技术人员的方式来做到这一点，这样我们就可以从他们的理解中汲取经验。这又回到了开发人员和业务人员之间的语言不匹配，这可能是要克服的最大障碍。在领域驱动设计中，这被称为项目的**普遍语言**，这是所有参与项目的各方共享的语言。建立这种语言允许我们在团队边界之间清晰地进行沟通，正如前面提到的，这是领域驱动设计中的核心思想之一。

回到我们的例子，兽人在地牢中奔跑，我们不知道这是如何做到的；我们甚至完全不了解文化方面涉及或应用的约束条件。兽人的世界是一个我们只能观察、提问并根据我们的理解来建模的外部世界。我们自然必须信任当地的专家。即使在现实世界的问题中，我们也应该尽可能地从外部视角来看待问题，因为在一个经过多年发展的业务中，我们自己的假设可能是错误的。

接下来，我们将探讨问题并介绍一套工具，这将有助于解决问题。我们将涵盖几个方面，但最重要的是以下几点：

+   使用纸和笔进行编程

+   代码尖峰和一次性代码

+   绘制我们的角色——为我们的领域创建一个依赖图

# 探索问题

在软件开发中，很少有问题可以很容易地完全规定。即使有些问题看起来可以，也会留下一些解释的空间。最近在实施数据库适配器项目时，我遇到了这个问题。有一个需要实施的规范，以及一组单元测试，确保实施符合规范。然而，在实施过程中，我发现自己一路上提出了一些问题。主要问题与如果没有规范，我会问的问题非常相似：人们将如何使用这段代码？在许多情况下，有多种实现某个特定功能的方法，但选择一种方法通常意味着权衡不同的折衷方案，比如速度、可扩展性和可读性。

在我们的兽人地牢中，我们必须问同样的基本问题：客户将如何使用我们的软件？遗憾的是，单凭这个问题本身不会得到我们心目中的结果。问题在于我们的用户不了解我们的软件。基本上，我们的未来用户和我们一样有同样的问题：他们不知道软件完成后会是什么样子，只能猜测它的用途。这真的是软件开发的*进退两难*；因此，为了成功，我们需要找到一个解决办法。作为开发人员，我们需要找到一种方法，使未来用户能够理解开发过程，而我们的未来用户需要适应高度描述性语言的概念，以尽可能清晰地陈述意图。

软件实际上是一个抽象的概念，大多数人不习惯谈论抽象的东西。因此，更好理解的第一步是使其对用户更加可接近。我们需要使概念变得*可触摸*；这可以通过各种方式实现，但越触觉越好。

### 提示

使用纸张。作为开发人员，我们经常更喜欢无纸化，但将事物写在纸上可以使大多数人更容易理解概念，因此写下来可以极大地帮助。

## 概述问题

就说明和组织信息的技术而言，*大纲*在许多情况下都很有用。但是，我们如何为软件制定大纲呢？这个想法是将与业务专家交谈时出现的所有信息以易于搜索的格式保存下来。在许多地方，这是一个*维基*，但也可以只是一组共享的文本文件，可以随时添加或检索信息。这里的大纲意味着按主题嵌套存储信息，并根据需要进行深入。

### 知识跟踪

在开始收集信息时，最重要的部分是尽可能收集尽可能多的信息，为此需要使其无缝。保持信息有序添加和根据需要重组也很重要。与我们的软件一样，我们不知道大纲的结构从何开始，所以每当我们识别出一个新的实体、角色或系统的任何重要部分时，我们就添加一个新的部分。因此，不要花太多时间使当前结构完美，而是使其足够好。

### 提示

养成收集所遇到的任何信息的习惯，并随时保持应用程序大纲。在许多公司，走廊交流通常是一个非常宝贵的信息来源，所以一定要好好利用它。

大纲如此有用的原因在于你可以轻松地重新构建它，这也是你在决定保留这些大纲笔记的工具时应该追求的目标。重新排序笔记需要快速和直观。目前的目标是尽可能降低变更成本，这样我们就可以轻松地探索不同的路径。

到目前为止，我们收集的地牢信息可以这样表示：

```js
# Dungeon
receives prisoners
transfers from other dungeons
new captures
loses prisoners
transfers to other dungeons
fleeing
prisoners might flee during transfer
prisoners might flee from the dungeon itself
```

重要的是，这种结构非常容易修改和随着新信息的到来保持最新，我们已经可以看到大纲中出现了一个新的实体——囚犯。有了这些新信息，我们现在将其添加到大纲中，以便有一个地方来保存更多关于囚犯的信息，因为他们显然是我们地牢应用程序中的一个重要概念。

```js
# Prisoner
can flee a dungeon or transport
needs a cell
is transferred between dungeon
```

这本质上就是大纲的内容，记录信息并得出快速结论。

### 媒介

根据情况，可能或者更好的是使用不同的媒介来保存信息。这可以从一张纸到一个完整的维基系统。我喜欢用于大纲的格式是 Markdown，它的优势在于以纯文本形式存储，并且在未经处理的情况下非常易读。此外，为了生成一些要打印的文档，将其先处理成 HTML 是很有用的。这绝不是最终选择，你应该选择任何感觉最自然的东西，只要它简单易编辑，并且在尽可能多的地方都可以读取。重要的是选择一个不会将你限制在其做事方式或难以导出或更改的数据格式中的系统。

## 纸上编程

在我们努力让非程序员参与软件创建的过程中，重要的是让概念易于理解。我们需要说明系统的交互以及参与者，并使它们准备好被移动。通常，当谈论一个主题时，让人们实际拿在手上并在桌子上移动的东西是有帮助的。实现这一点的最佳方法是创建系统元素的纸质表示。创建一个基于纸张、手动操作的版本，可以立即触摸和交互。这通常是 UI 设计中所知的，纸质原型是一件常见的事情，但它也很适合创建应用程序非 UI 部分的版本。

这个想法是将系统的任何部分绘制在卡片上，以便组合、分离和添加。当这样做时，它通常最终会非常接近我们将来在系统中拥有的实体表示。开始使用这种技术时，重要的是要注意最终结果总是处于某种状态。当事物在桌子上移动，元素被修改时，我们需要跟踪生成的信息。确保记下在讨论过程中某些行动是如何发展的，因为最终结果的单一图片只是反映了一个状态。

### 那么这样的纸质程序是如何工作的？

开始时，我们列出我们目前拥有的所有信息，为所有元素绘制出方框，并为它们命名。在我们的情况下，我们将绘制地牢、囚犯、牢房和一个运输工具。目前，这些是我们要交互的实体。在这一点上，我们考虑一个具体的交互，并尝试用我们目前拥有的实体和其他对象来表示它。让我们将一个囚犯从我们的地牢转移到另一个地牢；为了做到这一点，我们需要考虑我们必须做什么：

+   地牢管理员通知其他地牢

+   囚犯从牢房转移到运输工具上

+   一个兽人被指派守卫运输

+   运输到达其他地牢

当在一张纸上绘制出来时，结果可能看起来有点像这样，其中数字是步骤出现的顺序：

![那么这样的纸质程序是如何工作的？](img/B03704_02_01.jpg)

在这一点上，我们已经注意到缺少多个部分，主要是地牢管理员和通知其他地牢的方式。那么，如何添加这些呢？地牢管理员显然是管理地牢的实体，因此应该添加一个单独的卡片。此外，通知是通过消息完成的，因此我们添加一个消息系统。这是一个新的子系统，但我们现在可以将其视为一个黑匣子，我们可以将消息放入其中，让它们到达另一侧。

现在系统已经就位，我们可以为系统的参与者添加所需的方法：地牢管理员需要一种发送消息的方式来请求转移；单元需要放弃囚犯的*所有权*；运输需要接管；等等。随着我们进行这种交互，我们可以清楚地看到这可以被建模的一种可能方式，这对非开发人员来说也更容易接近，因为他们可以看到实际的盒子在桌子上移动。由于这个模型不断变化，请确保在沿途保留大纲中的注释，以免丢失任何新获得的信息。

## 不那么可怕的 UML

我们的论文原型为我们提供了交互的良好图像，我们的大纲捕捉了关于程序在各种情况下应该如何行为的大量信息。它还从业务角度捕捉了命名方面的细节。总的来说，这给了我们很多有益的见解，但仍然有一部分缺失。这使得我们的纸质原型的信息足够持久，因此我们可以更容易地在移动过程中参考它。我们之前绘制的原型缺少了一些对实施重要的信息。我们需要捕捉更多应用程序结构的信息。

这就是**统一建模语言**（**UML**）发挥作用的地方，是的，这个充满瀑布注入实践的可怕东西，大多数人从未想过它有用。谈论 UML 时，通常会提到将所有建模信息编码在图表中的想法；因此，最终可以由基本上具有一定编码技能的每个人生成代码并填写。当然，这是行不通的，但 UML 仍具有一些有趣的属性，使其有用。我们要做的是利用 UML 的一个属性，即捕捉交互的能力。UML 定义了多个类别的图表：

+   结构图

+   行为图

+   交互图

**结构图**主要关注系统中的参与者及其关系。在我们的情况下，它将表达管理员与地牢和其他兽人之间的关系。当涉及许多参与者时，这可能会有所帮助，但不一定是开始时最重要的信息。

![不那么可怕的 UML](img/B03704_02_02.jpg)

用例图提供了系统中参与者的略微更详细的图像，以及他们之间的互动。用例图是行为图系列的一部分，因此侧重于参与者的行为。这不仅是对我们的系统有用的信息，而且在目前来说也太粗粒度，无法表达信息和行动的流程。

![不那么可怕的 UML](img/B03704_02_03.jpg)

由于我们的功能涉及系统中定义的参与者之间的交互，一个有用的探索对象是事件在系统中发生的顺序。为此，我们可以使用序列图，这是 UML 中的一种交互图。这种图表侧重于实现特定目标所需的事件顺序。其中一些可能是异步的，有些需要等待响应；所有这些都在一个图表中捕捉到：

![不那么可怕的 UML](img/B03704_02_04.jpg)

通过这种插图，很容易区分同步和异步消息，因此我们可以确保相应地对方法进行建模。此外，命名事物被认为是计算机科学中最困难的问题之一，因此一定要向领域专家展示这一点，以便从他们的语言中命名现在暴露出来的消息和方法。

到目前为止，每个部分的想法都是拥有工具来从不同的视角探索问题，但不要过分相信！我们不试图创建整个系统的完整描述，而是深入探索一个部分，以便我们能够了解其核心功能以及如何实现它。然后，通过提出正确的问题来消除不确定性，因为我们对领域了解足够，以便与专家一起探索业务领域。

# 涉及专家

当我们从各个角度探索领域时，与尽可能多了解它的人交谈是很重要的。领域驱动设计的核心思想之一是创建一个可以被每个参与方使用的领域语言。在谈论工具时，我们设定了以这样一种方式来创建它们，使得开发人员和领域专家都能够平等参与，这样每个人都可以从对方的知识中解决问题。

口语本身就是一个问题，因此对于开发人员来说，它需要尽可能明确，因为需要表达非常具体和具体的想法。不应该有误解的余地。另一方面，对于业务人员来说，它需要对非技术观众来说是可理解的。现在来到了重要的部分，我们实际上将看到我们迄今为止是否已经实现了这个目标，以及我们如何能够来回沟通领域的想法。

涉及领域专家时，我们应该首先清楚地知道我们试图实现什么，比如获取关于我们目前正在开发的系统的知识。开发人员往往会让他们的系统展现出最好的一面，但我们的目标是暴露我们设计和理解中的误解和不确定性。实际上，我们希望被“出其不意”，可以这么说。对于项目当前阶段来说，这应该被视为一个成就。现在，改变的成本是最低的，所以如果我们暴露了我们知识中的某个空白，我们以后的生活会更轻松。现在暴露一个误解也意味着我们能够提出所有正确的问题，以便成功地沟通这个软件系统的抽象概念；因此，业务方面能够深入了解我们的系统并纠正缺陷。如果我们达到了这一点，非开发人员实际上参与了开发，我们可以继续开发一个非常合适的系统。那么，我们如何才能做到这一点呢？

## 找到空白

我们现在要做的第一件事是开始对话。与大多数问题一样，最好是在一个多元化的团队中思考，这样我们可以得到最多的观点。为了达到这个目标，我们希望创造一个环境，让业务领域的专家向我们解释发生了什么。我们现在可以使用各种不同的技术来以易于理解的方式谈论我们的软件。纸上编程的想法在这个阶段非常有用。

所以首先我们需要准备，确保所有已经确定的单位都做好准备。为每个人准备好卡片，让他们四处移动并在上面写下行动，同时识别出知识中的空白。将当前状态拍照并附上注释以保存状态以供以后参考，因为想法在演变。对话可以从开发者解释他们认为系统如何工作开始，鼓励业务专家在有不清楚或错误的地方插话。这可能真的成为一种游戏。我们如何用现有的部分表达我们想要表达的行动？当然，这不是一个拼图游戏，所以你可以随意创建新的部分并根据需要更改它们。以这种方式引导通过过程很可能会暴露出系统中的几个有价值的属性。

### 提示

准确是最重要的；务必尽可能多地提出诸如“这是 100%的时间都是这样做的吗？”这样的问题。

因此，让我们通过一个软件功能的示例来走一遍：将囚犯转移到另一个地牢。

### 谈论业务

囚犯转移的过程已经被描述为三个步骤：

1.  地牢管理员通知另一个地牢。

1.  囚犯从牢房转移到运输工具上。

1.  运输到达另一个地牢。

所以，我们准备了一些卡片：

+   由信封识别的通知服务

+   地牢牢房

+   囚犯

+   运输工具

有了可用的卡片，我们可以让兽人大师准确描述囚犯转移时需要发生的事情。

兽人大师确定了问题，并发送了一只乌鸦通知地牢转移请求。然后他去牢房将囚犯移出并送上运输工具，指派一名兽人守卫运输工具并将其送往另一个地牢。

在这个简短的描述中，我们看到了与我们的模型有多处不同之处需要解决。

1.  1 和 2 的顺序实际上并不重要，只要地牢中至少有一个囚犯，我们就可以在通知时进行检查。

1.  还会涉及到另一个稀缺资源，那就是押送囚犯的卫兵；他们需要可用，并且他们的进出需要被跟踪。

有了新的见解，我们现在可以相当准确地将这个事件建模为我们系统中的演员。重要的是要注意，当然，我们的系统不需要直接在代码中表示流程，但从高层次来看，有一个一致的流程是有意义的，因为它可能已经通过（可能）多年的实际使用而被确立。因此，至少从某种程度上来说，这是一个很好的起点。

## 谈论演员

当讨论如何实现某个功能时，涉及到多种形式的对象，它们在系统中扮演着不同的角色。许多系统中存在这些角色，尽管它们可能有不同的名称。在领域驱动设计中，对这些角色的分类有很大的影响。原因在于，如果我们对某物进行分类，就可以立即应用一定的模式，因为它已经被证明是有用的。这与命名企业应用程序中出现的模式的想法非常相似，现在几乎已经成为大多数应用程序开发人员的基本知识。

在领域驱动设计中，我们有多个可供选择的构建模块：

+   实体

+   价值对象

+   聚合

+   领域事件

+   服务

+   存储库

+   工厂

这个列表中的大部分元素可能对开发者来说已经很清楚了，但如果不清楚，我们稍后会更明确地定义每一个。现在，让我们专注于我们需要的并且已经在系统中使用的部分：聚合、值对象和领域事件。

一个重要的区别是实体和值对象之间的区别。实体由其身份定义，而值对象由其属性定义。回到我们的囚犯和牢房，我们可以看到可以使用任一分类，但它会改变焦点。如果囚犯是一个实体，每个囚犯都清楚地定义，两个囚犯将始终不同。这样对他们进行分类使得囚犯在整个系统中可追踪，因为他们从一个地牢到另一个地牢，从一个牢房到另一个牢房。这可能非常有用，但也可能过度。这就是当前阶段的全部内容——从领域角度找到项目的焦点。所以让我们一步一步地走完整个过程。

从外到内开始，我们首先要考虑我们的领域事件。顾名思义，这是触发领域特定反应的事件；在我们的情况下，这是囚犯的转移。为了处理这些事件，我们必须向下移动一级，考虑处理我们资源交易的系统部分，即聚合。它们可以说是系统中的行为者，因为它们聚合了所有需要的实体、值对象和其他一切，以向外界呈现一致的视图。聚合还负责根据领域的需要改变系统中的世界状态。就聚合而言，有多个聚合负责这个动作：管理牢房、囚犯和看守的地牢管理员，以及作为移动牢房的交通工具，囚犯和看守。通知其他地牢的服务有点超出系统范围，因此将其分类为服务似乎是自然的事情。好吧，这并不太难，思考不同对象的分类是相当自然的。

使用提供的领域术语让我们清楚地说明部分的关注和级别。其他开发人员，即使他们对系统不熟悉，现在也能够假定每个命名实体的特定功能集。对我们来说，命名是一种文档形式，可以让我们在开始混合概念时迅速注意到。

# 确定难题

在过去的几节中，我们开始对系统中的交互有了很清晰的理解。现在是时候利用这种理解，继续实施我们的软件解决方案。那么，在开发软件时我们应该从哪里开始呢？

通常在启动项目时，我们喜欢从简单的部分开始，也许从模板创建一个项目——例如，在一个新文件夹中运行一个框架代码生成器，比如 Node.js Express，为我们的项目设置脚手架结构。起初，这似乎是一个非常好的选择，因为它创建了大量我们必须编写的样板代码，以便创建一个 Express 项目。但是，这是否让我们更接近解决业务问题？现在我们有一个代码库可以探索，但是，由于它是自动生成的，显然没有任何特定于领域的代码。另一方面，我们已经将自己锁定在一个固定的结构中。对于一些项目来说，这是一件好事；这意味着要考虑的事情更少。然而，如果我们试图解决一个较低级别的问题，将自己锁定在某种思维方式中可能是不好的。

我们需要确定问题，并确定如何尽快为业务提供价值。这将推动用户采用和进一步开发软件。到目前为止，我们已经探索了领域的一部分，这对我们的业务来说似乎很重要，我们探索实施它作为我们的第一个特性。现在，是时候深入研究它，看看核心问题所在，看看将涉及的对象及其与我们的软件的交互。

## 映射依赖关系

通过之前的工作，我们对涉及的对象有了相当清晰的理解，至少在高层次上：

+   通知服务

+   单元

+   囚犯

+   看守

+   兽人大师

+   运输

有了这些想法，我们现在的任务是找到一个开始的地方。当布置这些对象时，很明显它们都与其他部分有一些依赖，我们可以利用这一点。我们绘制每个对象，使用箭头来展示它依赖的对象。这就是所谓的**依赖图**：

![映射依赖关系](img/B03704_02_05.jpg)

该图向我们展示了我们确定的每个角色的依赖关系。例如，看守对于运输和兽人大师来说是必要的依赖。另一方面，兽人大师不仅依赖于看守，还依赖于运输、囚犯和牢房。通过查看图表，我们可以看出元素需要以哪种顺序实现。我们之前确定为聚合物的元素当然会有最多的依赖关系。正如它们的名字所暗示的那样，它们将多个对象聚合成一个单元，以便进行共同访问和修改。

解决问题的一种方法是按以下顺序开始：

1.  看守。

1.  牢房。

1.  囚犯。

1.  运输。

1.  通知服务。

1.  兽人大师。

好处是，一路上，我们可以在其中一个聚合物处于工作状态时立即呈现中间状态。我们可以谈论我们对运输的想法，并将其与预期的功能对齐。工作状态在这里是一个重要的点，因为如果某个部分在多个方面不满足要求，人们很难判断某个特定部分。当然，“工作状态”并不意味着我们实际上看到了什么，但随着软件变得更加复杂，我们能够使用这些聚合物来发挥它们设计用途中的作用。例如，我们可以创建一个快速原型，重播业务团队指定的一些交互。当然，这与测试和功能验收测试或行为驱动开发是相辅相成的。

### 提示

向领域专家展示中间状态需要涉及对功能的指导，以及沿途提出问题。把部分实现的软件“扔过围墙”几乎没有任何用处。

## 用代码绘制-尖峰

现在我们已经有了一个开始开发的想法，我们最终可以探索如何实际做到这一点。当我们思考问题时，我们可能对它的运作方式有一些想法，但也会有一些地方，尽管我们知道高层是如何运作的，但我们对低层仍然不清楚。当开发人员不知道某件事在现实中如何运作时，找出该怎么做的最佳方法就是实际尝试并探索在其中途中被认为有用的库和工具。

这种方法被称为**尖峰**。我们创建一段一次性的代码，只是为了探索某个困难的部分，没有打算让这段代码进入生产。这使我们摆脱了通常涉及创建生产就绪代码的复杂性。代码只是为了解决特定情况并帮助我们获得有关如何以后解决同样问题的知识。大多数开发人员都知道，第一种方法几乎从来都不是问题的完美解决方案，所以让我们通过创建一个打算丢弃的第一个版本来处理这个事实。尖峰是关于知识的获取，而不是关于代码，所以准备好写一些快速而肮脏的东西来让它工作。顺便说一句，这实际上可以是一个非常有趣的练习！

一个常见的试验领域是与外部服务的交互，比如我们的通知服务，其中界面在高层次上是已知的，但开发人员实际上从未使用过。由于我们不知道如何与 Raven 进行接口，我现在打算暂时搁置这个问题。当情况出现时，我们需要重新审视这个问题，但正如我们从 UML 图中学到的，这个过程本身是异步的。因此，我们不指望在我们的第一个原型中，响应可以隐藏在*Mock*后面。

另一个有趣的问题将是创建我们的代码和用户之间的接口。我们无法确定用户希望如何与软件交互，因为他们没有使用类似软件的经验。接口往往能更好地帮助我们了解用户对软件的需求。用户希望如何使用软件会告诉我们很多关于他们关注的重点和期望的功能，因此进行试验是了解系统的好方法。这种试验可以通过多种方式进行，但实际上，有真实的界面元素可以构建，并且以后可以填充更多的交互，这是非常有用的。其中一种方法是使用 HTML 创建界面，它提供了基本的结构，但没有交互性，随着我们的进展，可以用 JavaScript 填补空白。为了简洁起见，代码被省略了。如果您感兴趣，请访问本书的代码存储库并查看。

请记住，这实际上并不是我们打算保留的界面，但现在我们可以向用户展示一些东西，并解释他们将如何进行交互。

# 开始吧，现在是时候了

通过之前的工作，我们现在可以开始着手应用程序的第一个功能了。我们已经探索了我们的想法，现在可以与我们的领域专家讨论细节了。我在这里稍微简化了到达这一点的步骤，实际上，这个过程很可能需要多次迭代，你对问题的理解也会不断发展。有时不仅是你的理解发生变化，而且业务方在这个过程中也会不断完善他们自己的理解。

## 在不创建代码的情况下创造价值

作为程序员，我们经常觉得我们创造的价值与我们创建的代码有关，但事实并非如此，我甚至会说我们的价值在于我们没有创建的代码。我们能够简化问题，项目推进就会更容易，简单是基于与业务团队合作的坚实理解。

### 提示

没有比创造复杂性更容易的事情了，所以要小心！以最简单的方式解决问题是每个软件都应该努力做到的。

当我们像之前那样走过流程，让人们解释他们每天做什么，很容易发现如何简化和改进某些事情。试图改进流程本身是软件开发过程的一部分。当我们探索一个功能的想法，并让业务方讨论他们自己的行动时，他们通常会注意到不必要的开销，甚至是不需要存在的过程继承复杂性。这就是为什么我们试图以文本格式进行之前所做的探索。不要嫌探索需要花费的时间，但要记住，现在你已经为业务创造了价值，这个阶段的改进是一个巨大的成功。

## 决定第一个功能

尽管我们已经在推动业务发展，但现在是时候真正做开发人员最擅长的事情了——编写代码。我们现在所做的探索指引我们开始以下功能集。

我们想要自动化将囚犯从地牢中移出并同时记录移动的囚犯。这似乎非常有价值，因为地牢溢出是兽人大师的主要问题。这也是保持地牢内囚犯记录的更大问题的一部分，我们将其视为我们大纲的一部分。最终，这就是我们要做的事情。完成了这个第一个功能后，囚犯的移动将几乎完全自动化，因此可以节省时间，我们可以投入到地牢运营的其他元素中。

我们设计了一个基本的界面来处理这个问题，看起来很容易使用。所以，让我们开始编码，并使用领域驱动设计的技术来设置项目，推动项目的进展。

# 总结

在本章中，我们学习了如何在编写代码之前开始项目。我们专注于与业务专家的互动，通过阐明我们的思路向他们提供反馈。我们讨论了收集知识的重要性，以及如何组织这些知识，以便在项目后期利用它，以了解我们正在构建的应用程序的目标。

随着我们的前进，我们研究了如何确定核心功能集，并选择一个良好的起点，不仅可以为业务提供早期价值，还可以帮助我们进一步了解业务领域。这个过程类似于敏捷方法的目标，试图尽早解决核心问题，并为业务提供快速价值和反馈。

在下一章中，我们将开始设置项目，并涵盖重要细节，以便在整个开发过程中对管理过程有一个良好的把握。
