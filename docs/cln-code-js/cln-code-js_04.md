# 第三章：清洁代码的敌人

到目前为止，我们应该已经对我们所说的*清洁代码*有了一个相当清晰的认识。在上一章中，我们探讨了可靠性、效率、可维护性和可用性的原则。这些原则共同引导我们朝着更清洁的代码方向前进，但是如果我们不小心，仍然可能会遇到问题。在本章中，我们将探讨清洁代码的*敌人*：可能阻止我们编写可靠、高效、可维护或可用的代码的因素。

这些敌人都不应被视为*您*的敌人；相反，它们应被视为清洁代码的煽动者。我们需要全面看待这些潜在有害因素，并在我们的代码库、团队和工作场所中留意它们。

具体来说，本章我们将涵盖以下敌人：

+   敌人＃1 - JavaScript

+   敌人＃2 - 管理

+   敌人＃3 - Self

+   敌人＃4 - 货物崇拜

# 敌人＃1 - JavaScript

最糟糕的 JavaScript 特性也可以说是它最好的特性。它是一种非常普遍的语言，不得不以非常快的速度增长和适应。语言本身及其在浏览器中的位置促成了这种普及性。

JavaScript 是一种非常富有表现力和多样化的语言，从 Lisp 和 Scheme 中获得了功能上的灵感，从 Self 中获得了原型继承，并且具有类似于 Java 的 C 样式的语法。它是一种具有多种范式的语言。无论您想以经典的面向对象方式、原型方式还是完全功能方式进行编程，JavaScript 都可以胜任。JavaScript 的灵活性以及其在更广泛的 Web 堆栈中的位置也使其非常适合初学者。您可以立即开始使用它，并且这正是 Brendan Eich 最初的意图。它旨在让设计师和程序员都能轻松上手，为他们提供编写曾经是单一用途平台的浏览器脚本的能力。然而，曾经不起眼的浏览器现在已经发展成一个非常广泛和复杂的互补抽象集合。

JavaScript 本身的增长以及其在客户端和服务器端（以及其他领域）的广泛应用意味着该语言已经被推向和拉向了成千上万个不同的方向。大量的框架、库、分支语言（例如 CoffeeScript）、语言扩展（例如 JSX）、编译器、构建工具和其他抽象已经涌现并试图以新的独特方式利用 JavaScript。这些工具共同构成了 JavaScript 的景观，这是一个非常丰富和多样化的景观。有无数种方法来做同样的事情，因此我们几乎无法希望做任何事情都正确。这就是为什么我说 JavaScript 的普及性既是它自己的最大敌人，也是它自己的最大优势。

在本书中，我们将探讨基础概念，这些概念将教会我们对清洁代码的本质进行批判性思考，并允许我们在不总是很好地满足代码清洁度的语言和环境中编写清洁代码。如果使用得当，JavaScript 将以其高效性和表现力让您感到惊讶，并且经过时间和努力，它可以在可靠性和可维护性方面与任何其他语言相媲美。

# 敌人＃2 - 管理

清洁代码与培养它的过程和原则一样重要。无论我们的代码在孤立环境中有多完美和美丽，它通常是作为项目的一部分编写的，与团队一起，并由可犯错误的人和可犯错误的流程管理。只有通过看到和理解这些缺陷，我们才能希望预防或避免它们。

如今，我们都在承担更具挑战性的工作。JavaScript 仅限于普通的宣传手册网站已经成为历史。Web 的创造者们被要求构建更加雄心勃勃的项目。随着技术抽象塔不断增长，这些项目的复杂性只会增加。因此，如果我们真的要写出干净的代码，我们必须广泛考虑这种复杂性。我们必须超越我们的代码库，考虑我们所在团队和组织的背景。

将管理视为敌人可能会暗示经理们本身有过错，但事实并非如此。我们将在本节中发现，是个人文化实践使得发布干净代码变得困难。其中包括发布压力、糟糕的度量标准和缺乏所有权。

# 发布压力

通常情况下，由于截止日期或其他管理规定的压力，发布代码的压力是软件世界中一个经常存在且不好的力量。对外部利益相关者或经理来说，截止日期是一件好事；它似乎提供了确定性和问责制，但对于项目中工作的人来说，它可能只会被视为强加的不受欢迎的妥协。有时，做出的第一个妥协就是代码质量的妥协。这并不是故意发生的，而是将完成优先于质量的自然结果。

在这种情况下，**利益相关者**是指依赖于您工作成果的任何个人或组织。通常的利益相关者包括项目经理、同一组织内的其他团队、外部客户和用户。

当有发布压力时，代码质量可能会慢慢下降。其中包括以下几点：

+   **文档**：当开发人员赶时间时，他们将无法花足够的时间来确保他们的代码及其 API 被正确记录。现有的文档将逐渐荒废。

+   **架构**：开发人员将开始专注于他们需要进行的最必要的更改，忽视代码的更大架构结构以及它们之间的相互关系。依赖关系将变得混乱，架构将随着时间的推移而分裂，最终形成混乱的代码。

+   **一致性**：无论是在架构上还是在语法上，一致性都将开始受到影响。多个不同的开发人员，可能被隔离在一起，被迫以最快的方式构建东西。无意中，他们可能忽视了沟通和建立标准，导致一致性减少。

+   **测试**：编写测试通常需要时间，调整测试以适应新需求也需要时间。现有的测试可能会被禁用或删除。新的测试不会被编写，因为根本没有时间。

+   **最佳实践**：当时间紧张时，开发人员将开始在他们的代码中采取捷径，而不是花费必要的时间和精力来确保他们的软件适合其目的。他们会绕过最佳实践，而选择快速和拼凑在一起的解决方案。在 Web 上，这往往会导致 UI 的可访问性和可用性降低。

当截止日期开始逼近时，上述项目通常会首先被搁置。如果我们不小心，我们可能会遇到以下二阶效应：

+   **Bugginess**：在缺乏测试和文档的情况下，代码的架构基础受到威胁，不稳定和有缺陷的代码将开始成为常态。许多这些错误可能会在质量保证过程中被捕捉到，但还有许多其他错误会出现在用户面前。代码及其 API 和 UI 的脆弱性将增加，给用户带来更大的负担。

+   **不满意的用户**：由于出现在用户面前的错误数量增加，软件的可用性降低，他们的生产力和幸福感也会降低。他们可能会开始避开或放弃该平台，寻找更高质量的替代品。

+   **疲惫的开发者**：疲惫的开发者，不得不不断放弃他们最好的原则，会开始感到疲惫。他们可能会对继续在团队中工作感到沮丧。面临心理健康和一般满足感受到威胁，他们会开始离开。

所有这些影响如果持续时间足够长，就会汇聚在一起，导致项目失败。因此，解决这种鲁莽高速的根本压力是至关重要的。迅速交付代码的压力通常是由那些对软件项目长期退化缺乏深刻了解的力量所发起的。这种缺乏了解可能部分是因为他们与自己决策的长期影响隔离开来。他们可能会认为，一旦交付并得到利益相关者的批准，问题就解决了。但正如我们所知，快速交付的代码满足了即时需求，并不意味着它符合良好的质量水平。低质量的代码可能会产生许多负面的连锁效应，这些效应只有在实施后的几周或几个月后才会完全意识到。几个月后，利益相关者可能会发现自己对减速和质量下降感到恼火，却没有意识到最初施加压力的是他们导致了这一切。

解决这一混乱局面的关键妥协在于*交付时间*和*技术债务*之间。技术债务会随着时间的推移而积累。它描述了需要解决以保持代码库健康和良好运行状态的赤字。这可能包括修复 bug、编写测试、重构旧模块，或者集成工具以提高代码质量。从根本上说，技术债务是所有工作，理想情况下应该是自然开发周期的一部分，但由于时间限制，被推迟到以后。还有其他因素决定了技术债务的增加，但时间是最重要的因素。不偿还我们的技术债务是确保代码衰退和项目最终失败的一种方法。

在项目管理方面，有无数的建议和流程可以利用。我不会在这里详细介绍它们，但我会分享一些启发式方法，以确保代码库的健康：

+   **不要在没有测试的情况下发布功能或修复 bug**。没有测试，可能随时会发生回归。测试是一种防御技术，可以确保我们的代码持续正确。

+   经常**偿还技术债务**。可能每周一次，或者每两周一次，尝试让每个人都处理技术债务，即任何被认为能增加代码健康的工作。

+   **定期与利益相关者沟通**，表达与代码和项目健康相关的限制和成本。不要过度承诺交付，也不要低估问题。

作为开发者，我们并不总是能控制项目管理的方式。尽管如此，我们应该始终感到自如地提出关注并倡导促进代码整洁的流程。第十八章，*沟通和倡导*，详细介绍了我们如何做到这一点。

# 糟糕的指标

世界上似乎没有哪个行业能逃脱指标的束缚。对于衡量事物的狂热迷恋既是一种像邪教一样的迷恋，也是一种产生必要的反省和改变的真正需求。在软件工程领域，我们对这种需求并不陌生。作为程序员，我们对能够为我们提供对代码洞察的指标非常感兴趣：

+   有多少 bug？

+   这段代码运行需要多长时间？

+   我的测试覆盖率有多高？

然而，经理和其他利益相关者通常会怀有自己的利益和指标。其中最臭名昭著的是试图衡量开发者产出或生产力的指标：

+   有多少行代码或提交？

+   我们发布了多少功能？

+   我们写了多少行文档？

如果出于正确的原因提出这些问题，那么这些都是很好的问题。例如，代码行数可以作为一个有用的度量，如果我们将其用作讨论是否重构特定类/实用程序的复杂性的代理。但许多度量完全脱离了它们试图衡量的事物。

非技术经理或利益相关者可能会认为编写一定数量的代码应该总是需要相同的时间。当曾经一天写 200 行代码的开发人员最近花了 10 天才提交了 10 行代码时，他们可能会感到困惑。当然，他们的困惑表明他们对编程过程及其混乱复杂性的理解存在严重误解。但这些误解很普遍，所以我们需要对它们保持警惕。

解决糟糕度量的明确方法是推动并创建更好的度量。要创建好的度量，了解我们试图回答的基本问题是至关重要的，然后集思广益地想出回答这个问题的方法。让我们看一个例子：

| **问题** | **糟糕的度量** | **为什么糟糕** | **更好的度量或方法** |
| --- | --- | --- | --- |
| 我们是否在高效工作？ | 代码行数/提交 | 一个程序员可能需要很多天来解决一个只需要一行更改的关键错误。 | 询问开发人员并探索是什么拖慢了他们的工作效率；进行团队回顾，发现改进的领域。 |
| 我们是否为用户提供了价值？ | 已发布功能数量 | 用户可能会从更少但质量更高的功能中获得更多好处。 | 建立度量或 A/B 实验来判断哪些功能被使用和受欢迎。专注于每个功能的质量。 |
| 我们是否在编写有用的文档？ | 文档行数 | 开发人员可能最终只会记录他们熟悉的事物，而不是最需要记录的代码区域。 | 创建一个跟踪文档使用情况的指标。通过询问开发人员来确定哪些代码区域的文档不足。 |
| 我们是否有一个经过良好测试的代码库？ | 测试覆盖率 | 如果它只衡量某些代码行是否被调用，那么它可能会被一些非常广泛的集成测试所欺骗。 | 结合传统的测试覆盖率和其他度量。跟踪经常出现 bug 的回归区域。 |
| 我们的代码库是否有 bug？ | bug 数量 | 一个代码库可能在一个几乎没有使用的应用程序区域中有很多 bug。某些区域的 bug 可能没有被报告。 | 不要计算 bug 数量；而是专注于并衡量用户和开发人员的满意度。根据 bug 对用户的影响来优先处理 bug。 |

组织或团队内对糟糕的度量的执着可能导致优化了错误的事物。更关心写更多代码行数的开发人员可能对其代码的基本质量不太感兴趣。被迫发布更多功能的开发人员可能会妥协最佳实践和清晰的代码，优化速度和交付。

确保我们跟踪的任何度量都受到现实的制约，并且我们不仅仅根据这些度量来判断成功是非常重要的。特别是当你看到度量与我们的清晰代码原则相对立时要特别小心。随着时间的推移，如果一个度量被过于雄心勃勃地追求，它最终可能会破坏它试图衡量的事物。这是通过一种被称为**古德哈特定律**的效应来实现的：

“当一个度量成为目标时，它就不再是一个好的度量。”

- Marilyn Strathern

# 缺乏所有权

所有权是健康代码库的关键原则，它依赖于个人对其代码健康状况的利益。这里的所有权并不意味着一段代码属于一个人，其他人不能在其上工作。相反，它意味着一段代码是由一个人或一组人培育的，其持续的健康和可靠性是一个关键的优先事项。

缺乏所有权可能会导致以下方式中的清洁代码的关键原则受损：

+   可靠性：随着不知不觉地引入脆弱性的新变化，代码的正确性和稳定性可能会随着时间的推移而衰退。代码的持续稳定性没有得到监控或关注。

+   效率：没有人直接测量或观察代码，基本假设是它只是有效的。随着时间的推移，其效率可能会下降。

+   可维护性：许多非所有者进行迅速和轻率的更改可能导致非连贯的架构，从而使长期维护变得更加困难。

+   可用性：没有人会考虑或监控代码的文档和一般可用性，导致其衰退，最终导致软件变得复杂和使用起来繁琐。

正确应用的所有权可以从根本上改变前述原则的衰退：

+   可靠性：代码的正确性和持续稳定性将得到关注和监控

+   效率：代码将被持续地测量和评估效率

+   可维护性：代码将保持其架构和语法的独特视角

+   可用性：文档将不断更新，代码的可用性将是一个持续关注的问题

从根本上讲，所有权是关于个人或团队对代码的持续关注。为了实现这一点，需要一定程度的自我或自豪感。个人或团队必须对代码的持续健康有一定的利益。通常是组织或管理文化导致了健康或不健康的所有权水平，因此，再次，正确沟通和倡导过程和动态对我们程序员来说是至关重要的，这将使我们能够确保我们的代码的整洁和健康。

缺乏所有权也会导致更严重和意想不到的后果。由于对工作缺乏自豪感和监护责任感，程序员更容易出现疲劳，因为他们无法实现对工作的自豪感和自我价值感。由于没有所有权，团队成员可能无法在任何一个领域培养高水平的理解，这意味着团队或组织的整体知识会受到影响，每个人只能以一种非常肤浅或粗略的方式理解代码库。

小心所有权中的自我过多！自我是一种脆弱的特质。总是存在“过度所有权”的风险，这可能导致顽固和防御性文化，使“内部人”不允许“外部人”进行更改，并且强烈的以自我为中心的观点泛滥。要小心。记住可用性和可维护性的关键原则。这将引导您对那些希望使用您的代码或对其进行更改的人表现出善良和开放的态度。

# 敌人＃3 - 自我

程序员作为创作者，永远在向世界展示他们对事物应该是什么样的版本，因此几乎不可能不时地对我们的工作感到自豪。如果不加以控制，这很容易演变成我们编写代码来给人留下深刻印象，提升自己的优越感，而不考虑我们正在编写的代码是否可维护或可用。但是，如果我们的自然自我不能得到发展，那么我们就不会对自己的工作感到自豪，也不会倾向于在我们所做的事情上培养卓越。因此，在编程中，就像生活的其他领域一样，关键是保持自我平衡，保留其好的部分，而不让其坏的部分影响太多。

在这种情况下，“自我”是指我们的自我；我们如何认同自己以及我们如何在世界上表达自己。所有程序员都有自我，它对他们编写的代码产生了许多影响。

# 炫耀语法

作为一个年轻的程序员，我经常发现我的自我占了上风。我不敢说这是一个普遍的真理。这只是我的经验。每当我发现一个新的 JavaScript 特异功能时，我会尝试在我的下一段代码中加以利用。

其中一个例子是使用位运算符来实现向下取整的效果。传统上，要对数字进行向下取整，即将数字四舍五入到最接近的整数，你会使用语言提供的原生方法：

```js
Math.floor(65.7); // => 65
```

然而，当时，我更喜欢使用位运算符来实现相同的结果：

```js
~~65.7; // => 65
0|65.7; // => 65
```

这里发生了什么？位运算符（包括`~`、`&`、`|`等）用于改变操作数的位，但作为副作用，它们首先会将它们的操作数转换为 32 位整数。这意味着它们会丢弃小数部分。为了利用这种隐式转换为整数而不改变整数值，我们可以执行双重位反转，例如使用双波浪号（`~~`）。这实质上是反转操作数的所有位，然后再次反转。我们也可以执行与零的位或运算（`0|...`），这将始终返回非零操作数的位，从而通过利用副作用（整数转换）而不改变基础值来产生相同的效果。

至关重要的是要注意，这种副作用在负数的情况下并不与`Math.floor`的向下取整行为功能匹配。请注意以下两个表达式的区别：

```js
Math.floor(-25.6); // => 26
~~(-25.6);         // => 25
```

这些神秘技术的吸引力很容易理解。它们的使用似乎表明了对语言的高水平理解，这非常吸引人的自我。这类似于使用不必要的长或复杂的词来表达简单的想法：说起来很有趣，但对听众来说很难理解。

这样的技术通常会导致代码的可维护性降低。我们的代码的维护者不应该被期望理解很少使用的运算符的内部工作原理，并且应该能够相信我们不会轻率地利用语言内部的副作用来实现可以通过更熟悉和明显的方法清晰地实现的结果。

复杂或罕见的语法通常是自我代码的载体。另一个例子是错误使用逻辑运算符来指定控制流：

```js
function showNotification(message) {
  hasUserEnabledNotifications() && (
    new Notification(message).show() &&
    logNotificationShown(message)
  );
}
```

前面的代码可以更常规、更清晰地表达为一个*IF*语句：

```js
function showNotification(message) {
  if (hasUserEnabledNotifications()) {
    new Notification(message).show();
    logNotificationShown(message);
  }
}
```

这样更清晰，更熟悉，更易读，适合更多的人群。

有人认为我们应该能够自由地利用整个语言的全部功能，利用其所有的特异功能和副作用来编写更简洁、更高效的代码。如果我们的唯一目标是编写能够工作的代码，这是一个很好的态度。但编写*干净*的代码是关于采取审慎的方法，使用能够提供更多可读性的技术，并避免那些相反的技术。

还要记住，从根本上说，代码是关于传达意图的。沟通既关乎听众也关乎说话者。自我代码往往在这方面表现不佳；它将你的代码熟悉度限制在少数精通相同知识的精英之中。这并非理想。我们应该始终考虑到将不得不阅读、使用和维护我们代码的人们的多样知识和能力。这种关注应该优先于我们的自我。

# 固执的观点

代码很少是孤立编写的；我们经常与他人合作将项目变为现实。因此，清晰的代码取决于你的方法和整个团队的方法。持续拥有代码库的团队不断决定他们将用来实现目标的工具、约定和抽象。因此，团队成员必须能够良好沟通并分享观点，将这些观点塑造成明确的结果。有时，妥协是必要的。而妥协往往会伤及自尊。

JavaScript 及其工具容易受到强烈意见的影响。随着时间的推移，我们每个人都会在不同的方法中获得经验，并且通常通过辛勤劳动和痛苦，最终形成一套我们认为最好的方法的信念。然而，这些信念可能并不总是与我们的同事相匹配。当存在分歧时，解决的路径是不清晰的。没有解决，团队和代码库可能会分裂，造成更多的损害。

想象一下亚当和苏珊之间的以下情景：

亚当：我们应该使用 Foo 测试框架；它更可靠，而且更好。

苏珊：不，我们一定要使用 Baz；它更优秀，而且有着成熟的记录。

这种分歧可能有很多不同的解决方法。例如，我们可以建议两个人都提出自己的观点，并继续辩论各种测试框架的优点。这可能会解决问题。但同样，也可能不会。争论可能会持续下去，造成两个人之间的裂痕，并使代码库处于一种没有明确选择测试框架的状态。在这种情况下，解决的路径并不总是清晰的，但清楚的是，如果牵涉到不妥协的自尊心，解决的可能性就会降低。如果亚当和苏珊都能开始看到彼此的观点，拓宽自己的视野，摆脱自己的观点，那么解决的路径就会变得更清晰。

# 冒名顶替综合症

自尊心作为一种脆弱的特质，也影响着我们对自己能力和观点的信仰。毫无疑问，对自己的信仰是编程中创造和解决问题的关键。尤其在技术行业，**冒名顶替综合症**似乎是一种普遍现象。冒名顶替综合症的特征是一种感觉，即自己是一个*冒名顶替者*——你在某种程度上不适合或不够胜任你所担任的角色，而你觉得周围的其他人要能力更强。

可以说，软件行业中冒名顶替综合症的普遍存在是由于固有的复杂性和专业知识的丰富性。我们最多只能希望在相对狭窄的领域拥有高水平的熟练程度，但永远不会在所有领域都有专业知识。在日常工作中，我们时刻意识到自己不知道的所有事情，这可以理解地造成一种焦虑和对自己谦卑能力的不信任。这种感觉有时会导致压力、疏远和对自己能力的不信任。

这可能会产生以下负面结果：

+   **缺乏果断**: 对自己能力的信念不足可能导致在决定代码架构时信心水平较低；不知道该选择哪条路线往往意味着采取默认路线，这特别容易形成迷信。

+   **缺乏大胆**: 缺乏果断可能导致更少的冒险和更少的大胆决策，但有时需要做出这样的决定来推动项目或代码库的进展。例如，选择更可靠的 UI 或测试框架可能是一个巨大而大胆的风险，考虑到重构的成本，但可以导致代码健康的整体改善。

+   **缺乏沟通**：对自己的观点和技能缺乏信心可能导致较少重要的沟通发生，例如程序员与项目利益相关者之间的沟通。这里的沟通并不意味着外向或健谈，而是识别关键问题并对其有足够的信心以提倡变革。

编程是一种传达意图的行为，也就是说，以某种方式向世界表达我们认为事物应该运作的方式。这本身就是一种大胆的行动和一种我们不应该视为理所当然的技能。如果你正在阅读这篇文章，并担心自己可能缺乏特定的特质或能力，我提供以下建议：地球上没有人是完全有能力的。每个人都有自己的优点和缺点。正是每个人的多样性和他们不同的能力将决定项目和代码库的成功。即使你感到自己是个骗子，也要承认这种感觉是自然的，而且尽管如此，你所能提供的远远超出你的想象。

# 敌人＃4 - 模仿行为

在 20 世纪初，人们观察到一些美拉尼西亚文化会进行模仿西方技术和行为的仪式，比如用木头和黏土建造跑道和控制塔。他们这样做是希望物质财富，比如食物，会被送到他们那里。这些奇怪的仪式出现是因为他们之前观察到货物是通过西方飞机送来的，错误地得出结论认为是跑道本身召唤了货物。

现在，在编程中，我们使用术语“模仿行为”或“模仿”来广泛描述复制模式和行为，而不完全理解它们真正的目的和功能。当程序员在网上搜索解决方案，并复制并粘贴他们找到的第一段代码，而不考虑其可靠性或安全性时，他们正在进行模仿行为，试图通过使用在其他上下文中似乎负责这个任务的代码来完成某个任务。

模仿行为通常包括以下过程：

1.  人处于一个略微陌生的技术环境中

1.  - 人看到他们希望模仿的效果

1.  - 人复制似乎产生所需效果的代码

这种行为在组织和技术上都可能发生。程序员有时被要求将他们很少了解的不同技术依赖关系联系在一起，通常会别无选择，只能进行模仿。而组织通常没有时间考虑所有的基本原则，往往最终会从其他组织中模仿流行的行为和流程。

# - 模仿代码

为了说明模仿行为，让我们想象一个程序员的任务是向他们的 Node.js 服务器添加一个新的 HTTP GET 路由。他们需要添加`/about_us`路由。他们打开`routes.js`文件，在其中的众多行中找到以下代码：

```js
app.use('/admin', (req, res, next) => {
  const admin = await attemptLoadAdminSection(req, res); 
  if (admin) {
    next();
  } else {
    res.status(403).end('You are not authorized');
  }
});
```

这段代码碰巧使用了一个 Node.js 框架：**Express**。不幸的是，程序员对 Express API 并不很熟悉。他们看到前面的代码，并试图为自己的目的模仿它：

```js
app.use('/about_us', (req, res, next) => {
  attemptLoadAboutSection(req, res);
  next();
});
```

不幸的是，正如你可能已经注意到的，这位程序员已经犯了模仿的行为。他们复制了用于将流量引导到管理员部分的代码，并假设他们应该使用类似的代码来将流量引导到关于页面。

他们在这样做时错过了一些事情：

+   管理员路由实际上是中间件，用于阻止未经授权的用户访问`/admin`。

+   `app.use()`方法应该只用于中间件，而不是用于直接的 GET 路由。

+   调用`next()`只有中间件才会感兴趣

如果程序员花时间阅读 Express 文档，他们会发现正确的方法更接近以下内容：

```js
app.get('/about_us', (req, res) => {
  loadAboutSection(res);
});
```

这只是一个非常简短的例子。货物崇拜的行为通常更加复杂。它可能不涉及直接复制代码，而可能只涉及模式或语法的微妙复制。我们可能会对前面的例子摇头，确信自己永远不会做这样的事情，但我们很可能已经以不那么明显的方式做了。

参与项目的程序员通常会合理地继承现有代码库的命名、语法和空白符约定。他们可能会在不经意间这样做，自然地反映和符合现有范例，而不是在每一步都应用他们的批判性技能。这并不一定是负面的：这是对约定和表现一致性的明智维护。这些都是重要的品质。但同样地，盲目地复制这些东西往往会导致冗余代码的无谓增加，或者更糟糕的是，由于对代码的误解而产生负面影响。

想象一下，你是一名初学者程序员，你想要在以下略微奇怪的对象中添加一个`hobby`字段：

```js
const person = {
  "name": ("James"),
  "location": ("London")
};
```

很容易想象，当您添加新字段时，您可能倾向于复制现有的语法：

```js
const person = {
  "name": ("James"),
  "location": ("London"),
  "hobby": ("kayaking")
};
```

这对于第一次尝试者来说是完全合理的事情。他们处于一个陌生的环境中，看到了他们希望模仿的效果，于是采用了产生这种效果的模式。即使是有经验的人也可以理解这种行为，他们希望对代码进行最小必要的改动，而不影响其周围环境。

这段代码并没有明显的错误。它是可用的。然而，如果我们要编写最大程度上可维护和高效的代码，那么我们应该采用更广泛接受和常规的约定和语法。因此，在这种情况下，前述代码存在两个具体问题：

+   将每个键名都用双引号括起来（不必要！）

+   将每个值都用括号括起来（不必要！）

没有进行货物崇拜的文件版本可能如下所示：

```js
const person = {
  name: "James",
  location: "London",
  hobby: "kayaking"
};
```

然而，这个文件和对象可能会继续存在数月甚至数年。没有人会质疑或挑战它的语法，因为他们会认为它一定有它的原因。遵循已建立的做事方式会带来舒适和便利。挑战它通常更容易。这种形式的货物崇拜是更隐匿的类型，它给项目和团队引入了很多惯性。我们盲目地采用做法，而不质疑它们的持续有效性和适用性。

# 模仿工具和库

就像代码可以被盲目地复制一样，工具也可以。作为 JavaScript 程序员，我们接触到一个快速变化的工具和库的景观。每个月都会发布一个新的实用程序或工具。围绕一些工具产生的兴奋和夸大其词为货物崇拜的爆发创造了肥沃的土壤。程序员可能开始使用这些新工具，相信它们的价值，而没有充分了解它们或正确考虑它们是否适合手头的项目。工具可能被公司或经理指定，非程序员和程序员可能会根据工具的流行度或新颖性发表意见，而不考虑它实际上是如何工作的，或者它与当前方法有何不同。

货物崇拜中的“崇拜”往往是一种非常有说服力的力量，告诉我们，如果我们只是使用这种方法或工具，所有问题都将得到解决。自然地，这很少发生。我们可能最终只是用新问题交换了我们当前的问题。因此，在决定使用工具时，无论是框架、库还是任何第三方抽象或服务，我们都应该始终采用深思熟虑的方法，问自己以下关键问题：

+   **适用性**：它是否是解决手头问题的最合适的工具？

+   **可靠性**：它是否可靠地工作，而且将继续如此？

+   **可用性**：它是否简单易用并且有良好的文档？

+   **兼容性**：它是否与现有的代码库很好地集成？

+   **适应性**：它是否适应我们不断变化的需求？

为了避免装运崇拜，我们应该尽量避免轶事和道听途说，而更倾向于详细的比较分析，通过比较和对比各种可能性来找到最合适的方案。

# 总结

在本章中，我们对一些最普遍的对清晰代码的“敌人”有了一定的了解。我们讨论了 JavaScript 本身是一种语言，当被错误使用时，会导致不清晰的代码。我们还探讨了团队和个人的陷阱。我们了解到，清晰的代码不仅仅是代码的特征，而是一种必须在整个组织和我们自己的思想中培养的文化。

在下一章中，我们将探讨一些众所周知和一些不太为人知的清晰代码原则，并将我们迄今所学的内容整合到一些具体的 JavaScript 抽象中。
