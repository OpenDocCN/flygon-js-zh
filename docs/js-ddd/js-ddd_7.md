# 第七章：并不全是领域驱动设计

|   | *如果我看得更远，那是因为我站在巨人的肩膀上。* |   |
| --- | --- | --- |
|   | --*牛顿* |

与大多数开发中的事物一样，并不仅仅是在开发软件时，大多数概念在之前已经被发现，大多数事情在之前已经完成，但有些微小的变化，或者思想的重新组合，使旧概念更有用，或者实现新的创新用途。软件开发的实践自开始以来一直在不断增长和发展。一段时间以前，结构化编程的概念，使用函数、子程序，以及 while 和 for 循环，被认为是一个新概念。后来，面向对象编程和函数式编程吸收了这些想法，并在此基础上添加了新的想法，以进一步简化可维护性，并允许程序员更好地表达他们在编写程序时的意图。

与这些想法一样，领域驱动设计是从面向对象编程的许多想法中发展而来的，书中已经提到了很多这些想法。还有更多影响这些想法的概念，其中一些与面向对象编程密切相关，例如面向方面的思想，以及使用普通对象来模拟系统中的核心服务层。但也有一些来自其他领域的想法，比如构建领域特定语言。领域特定语言已经存在很长时间了，在 LISP 语言家族中经常见到。

### 注意

LISP 家族知道不同形式的 DSL，大多数 LISP 程序本身可以被看作是非常轻量级的 DSL。访问[`en.wikipedia.org/wiki/Lisp_%28programming_language%29`](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)了解更多细节。

函数式编程也为领域驱动设计增添了一些想法，尤其是不可变性是一个值得追求的东西，有助于调试，并且从总体上考虑领域。

在接下来的章节中，您将详细了解那些影响领域驱动设计以及一般编程的额外概念。本章将涵盖以下主题：

+   理解领域驱动设计的先决条件

+   了解影响，如面向对象和面向方面的编程，使用普通对象进行编程，以及命令查询分离

+   领域特定语言

+   其他编程实践，如函数式编程和基于事件的系统

# 将领域与问题匹配

大部分应用程序的工作意味着考虑如何以机器能理解和处理的方式表达给定的问题。领域驱动设计将这一切重新回到了起点，并确保在领域上工作的人理解问题的机器表示，因此能够对其进行推理和贡献。

在整本书中，我们一直在讨论同时为人类和机器构建一种语言。这意味着采用 JavaScript 给我们的构造，并使其对开发人员和领域专家都具有表现力。

有许多表达问题的方式，其中一些比其他方式更容易理解。例如，在一个非常简单的情况下，可以这样写一个数组中数字的总和：

```js
var ns = [1,2,3,4]
for(var i = ns.length-1, si = ns[i], s = 0; si = ns[i--];) s += si
console.log("sum for " + ns + " is " + s)
```

这个简单的程序通过在`for`循环检查中做了很多工作来工作，分配数组的当前元素，求和的初始起始值，并因此使用它们来实现求和。为了使循环更加混乱，它使用了获取数组边界之外的索引的属性，导致未定义，这是为了在检查中跳出循环。

尽管这样做是有效的，但很难理解发生了什么。这是由于命名以及使用复杂的构造来表达求和的概念。

## 成长为一个领域

考虑前面例子中的领域，我们可以看到 JavaScript 已经为我们提供了更清晰地表达这个领域的术语，假设对数学术语有一定的了解，例如：

```js
var numbers = [1,2,3,4]
sum = numbers.reduce(function (a, b) { return a + b }, 0)
console.log("sum for " + numbers + " is " + sum)
```

通过使用我们可用的工具，我们可以逐渐成长为领域概念的一般性，扩展已有的内容，并构建需要添加的内容。我们现在使用内置的 reduce 函数来执行与以前的`for`循环相同的操作。`reduce`函数将一个函数作为参数，该函数传递到目前为止的结果和当前元素，并且我们还给它一个起始点 0 来启动该过程。对于熟悉该语言的人来说，这更易读，几乎可以立即理解，因为它使用了如何在数组上表达操作的常见概念。

使用相同的基本技术，我们也可以利用内置函数来完成我们领域中的任务。当我们想要计算运输所需的时间时，我们可能只想考虑工作日，因此我们需要过滤周末，使用内置函数，这可以清晰地表达：

```js
var SATURDAY = 6
var SUNDAY = 7

var days = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]

var transportTime = 11

var arrivalDay = days.filter(function (e) {
  if (e % SATURDAY === 0) return false
  if (e % SUNDAY === 0) return false
  return true
})[transportTime]
```

我们使用 filter 方法来过滤掉现在的日期中的周末，假设今天是星期一，然后我们可以选择到达日作为数组中的位置。随着我们在开发中的进展，我们可以使这更加清晰，但是使用内置方法来操作已经使代码具有自然的可读性。

不同的领域具有不同的表现优点，通常情况下，对某个问题的理解越深刻，就越有利于围绕这个想法构建领域设计，以便在一般问题的复杂性实际上导致领域驱动设计的情况下。

## 领域驱动设计的良好领域

到目前为止，我们一直在使用地牢管理系统，该系统管理着进出地牢的单元格和囚犯，如果囚犯在场，地牢就会赚钱。这个领域非常复杂，正如我们已经看到的那样，因为我们到目前为止只是管理了囚犯从地牢中的运输，使地牢在适当的时间有足够的囚犯。当然，这不是一个真实的例子，显然，因为我们一直在谈论兽人。这个例子是基于一个非常真实的应用程序，最初是基于管理酒店预订的想法，包括超额预订和不足预订。

在检查领域时，我们可以看到使其成为领域驱动设计有价值的特性。固有问题非常复杂，涉及许多不同的部分进行协作和建模，以构建一个完整的、可工作的系统。随着系统进一步优化为最佳系统，为使用公司提供最大利润，每个部分也经常会发生变化。

在这种情况下，进一步增加领域设计的价值的是，与系统交互的用户差异很大。不同的用户需要暴露给不同的接口，这些接口被连接在一起。这种共享功能很难做到，拥有一个中心核心模型来模拟共享部分是保持不同子应用程序不会分离的好方法，这在将一组特定于领域的逻辑分割到多个应用程序的项目中是一个常见的问题。

# 面向对象的力量

到目前为止，我们在构建应用程序的过程中利用的概念绝不是领域驱动设计概念的特定发明。许多熟悉软件工程原则的人会注意到许多来自其他领域的想法。许多想法是多年来许多人培养出来的对象导向的一部分。

## 到目前为止的面向对象原则

面向对象是关于封装状态和功能的。这个概念是基本的，我们在整本书中一直在使用它来构建系统，并将不同的部分组合成对象。当涉及到面向对象时，JavaScript 对象是特殊的，因为 JavaScript 是少数几种基于原型继承而不是传统继承的语言之一，大多数其他面向对象的语言都是传统继承。这意味着不仅仅是处理继承的一种特殊方式；它还意味着 JavaScript 在处理对象时有一种非常简单的方式：

```js
var thing = {
  state: 1,
  update: function() {
    this.state++
  }
}

thing.update()
thing.update()
thing.state         // => 3
```

这是创建对象的最简单方式，也是 JavaScript 中最常用的方式。

我们已经使用对象来表示值对象以及实体，特别是值对象。面向对象编程的一个关键点是对象提供的隔离；在构建系统时，我们通过让对象相互发送消息来构建系统。当我们能够将命令消息与查询消息分开时，这种方法特别有效。将命令与查询分开使得测试更容易，对代码的推理也更好，因为它将修改状态的事物（命令）与幂等操作（可以在不引起任何副作用的情况下执行的查询）分开。另一个更重要的优势是，将查询与命令分开允许我们更清楚地表达命令在领域中的意义。当我们向领域对象发出命令时，它在领域中具有重要意义，因此应该独立存在，并且应该在项目中建立的通用语言中。当发出命令时，我们总是希望表达“为什么”，将查询与命令捆绑在一起不允许名称同时表达两者。

### 提示

一个常见的例子是更新对象属性的命令，比如`updateAddress`，这个命名并没有告诉我们“为什么”更新它。`changeDeliveryTarget`更清楚地说明了为什么更新了这个属性。在查询方法中混合这些类型的更改是不自然的。

原型继承为我们提供了另一种很好的建模数据的方式，与传统继承相比，原型继承中的链通常相当浅。原型的重要特征是它们允许我们动态地从任何对象继承。以下代码显示了使用`Object.create`来继承和扩展对象的用法：

```js
var otherThing = Object.create(thing, {
  more: { value: "data" }
})

otherThing.update()
thing.update()

thing.state           // => 2
otherThing.state       // => 2
otherThing.more        // => data
thing.more             // => undefined
```

使用`Object.create`方法允许我们轻松地从其他对象构建。它并不总是存在于 JavaScript 中，在此之前，我们需要做更多的工作才能达到相同的效果，但是使用`Object.create`方法，构建对象非常自然，并且它符合原型继承的概念。

对象非常适合模拟通过系统的数据流，因为它们非常轻量级且可扩展。正如在前面的部分中讨论的那样，我们需要注意一些注意事项。特别是，简单的扩展允许使用浅继承层次结构，同时仍然使用多态来解决控制流。使用多态来控制控制流是面向对象中常见的方法，它允许对象封装知识。当我们向对象发送命令时，我们希望它根据内部的知识和状态来执行，除非我们想发送特定的命令，否则我们不关心它的具体实现。这使我们能够拥有智能对象，它们对针对它们的命令做出不同的响应，例如：

```js
var counter = {
  state: 1,
  update: function() {
    this.state++
  }
}

var jumpingCounter = Object.create(counter, {
  update: { value: function() { this.state += 10 } }
})

jumpingCounter.update()
jumpingCounter.state // => 11
```

我们再次使用基本的 JavaScript 对象作为基础来构建新功能。这一次，我们通过实现一个新函数来扩展我们简单的计数器的新功能，而不修改基础计数器对象。这展示了易于扩展性的力量——我们可以只使用已经存在的对象中封装的功能，并在其基础上构建，而无需太多仪式。这种可能性是 JavaScript 的许多力量的来源，这是一个很好的力量，但也很容易被滥用。

这导致了一个非常简单的依赖于彼此的领域模型的模型，可以直接使用，也可以在途中进行扩展。

## 业务领域的面向对象建模

封装业务领域的面向对象的想法通常是非常有益的，因为它导致了一个耦合度较低、更容易理解和修改的系统。当我们把对象看作是我们传递消息并接收答案的东西时，我们自然地对代码的内部结构耦合度较低，因为 API 变成了一个问题和答案，以及一个命令游戏。

在一个非常简单的例子中，回到我们的地牢和其中的兽人，我们可能想要实现一个与入侵者战斗的方法。因此，我们首先通过使用一个非常轻量级的对象来实现一个带武器的兽人，例如：

```js
var Orc = {
  init: function (name, weapon) {
    this.name = name
    this.weapon = weapon
    return this
  },

  get isArmed () { return !!this.weapon },

  attack: function (opponent) {
    console.log(this.name + " strikes "
        + opponent.name + " with " + this.weapon + ".")
  }
}
```

这里有一个特性并不常用，但非常强大：我们可以通过特殊的`get`或`set`语法在 JavaScript 中为对象定义 getter 和 setter，这允许我们首先限制对我们的属性的修改范围，同时也允许我们通过其他属性构建更复杂的属性。在这种情况下，我们抽象出了一个缺少武器意味着兽人没有武装的知识。

我们认为战斗是自己的领域对象，因此我们也对其进行建模：

```js
var Fight = {
  init: function (orc, attacker) {
    this.orc = orc
    this.attacker = attacker
    return this
  },

  round: function () {
     if(this.orc.isArmed) {
       this.orc.attack(this.attacker)
     } else {
       this.attacker.attack(this.orc)
     }
   }
}
```

战斗封装了只有武装的兽人才能在战斗中实际攻击对手的逻辑。当然，这是非常简单的逻辑，但它可能会变得更加复杂。我们将使用一个对象模型来抽象出系统中如何处理战斗的事实。

### 提示

始终要记住，创建对象，特别是在 JavaScript 中，是非常廉价的。将太多的知识封装到一个对象中并不是一个好主意，往往最好的做法是早期将一个对象分解为不同的责任。一个很好的指标是一个对象有很多私有方法，或者方法的名称与其紧密相关。

现在我们可以用对象来对战斗进行建模：

```js
var agronak = Object.create(Orc).init("Agronak", "sword")
var traugh = Object.create(Orc).init("Traugh")

var fight = Object.create(Fight).init(agronak, traugh)
fight.round() // => Agronak strikes Traugh with sword.
```

这将战斗的逻辑封装在自己的对象中，并使用兽人来封装与兽人相关的逻辑。

## 纯对象导向的场景不足

面向对象的基础在很大程度上非常适合对领域进行建模。特别是在 JavaScript 中，由于其非常轻量级的对象创建和建模，它非常适合对我们所见过的领域进行建模。

面向对象的不足之处在于事务管理的层面，我们有一些跨多个对象的交互需要从更高的层面进行管理。另一方面，我们不希望事务的细节泄漏给所有涉及的对象。这就是领域驱动设计的作用，通过价值对象、实体和聚合的分离来管理工作流。在这种情况下，聚合允许通过成为其他协作者的生命周期管理者来管理工作流。当我们将领域建模为由子领域组成时，即使一个实体可能在不同的协作子领域之间共享，每个子领域也有自己的实体视图。在每个子领域中，聚合可以控制完成任务所需的事务，并确保数据处于一致的状态。

当然，在整本书中我们已经看到了多个其他的添加，但是对对象的低级细节进行更高级管理的添加是一个重要的特性，将面向对象的应用程序结构扩展到面向领域的形式对象导向。

# 保持紧密联系的影响

面向对象不是本书中我们所见过的应用程序开发的唯一影响。许多不同的技术可以用于建模领域概念，并影响应用程序的开发方式。JavaScript 本身是一种非常灵活的语言，可以用于做很多有趣的事情，有时也会被滥用。

根据情况，建模某些方面或解决某些问题时，可以保留不同的想法，这些想法可以很好地应用。

## 面向方面的编程

在软件开发的大部分思想核心，都围绕着如何封装逻辑和状态，使其易于访问，并具有一个可理解和可扩展的公共接口。可扩展性是一个非常重要的方面，特别是在商业软件中，因为需求需要根据现实世界进行调整，软件需要能够快速包含新的需求。

面向方面的编程将软件开发的方面的想法置于程序设计的中心，并特别关注如何在不重复和可维护的方式中实现横切关注点。在面向方面的编程的情况下，方面是可能在不同对象之间共享的各种关注点。

面向方面的编程的典型例子是向系统添加审计日志。审计日志是需要在所有不同的域对象中实现的东西，同时又不是对象的核心关注点。面向方面的编程提取了方面，即审计日志，在这种情况下，并将其应用于应该以这种方式处理的每个对象。通过这种方式，它使方面成为系统的核心部分，与业务对象解耦。

由于 JavaScript 具有非常动态的特性，可以非常简单和动态地实现这一点；一个解决方案是使用特性。

### 注意

所使用的特性基于[`javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/`](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/)。

现在我们可以在先前的示例基础上构建，并向我们的`Fight`对象添加`audit`日志。我们可以直接将调用添加到`fight`类中：

```js
var util = require("util")

var Fight = {
  init: function (orc, attacker, audit) {
    this.audit = audit
    if (this.audit) {
      console.log("Called init on " + util.inspect(this) + " with " + util.inspect(arguments))
    }
    this.orc = orc
    this.attacker = attacker
    return this
  },

  round: function () {
    if (this.audit) {
      console.log("Called round on " + util.inspect(this) + " with " + util.inspect(arguments))
    }
     if(this.orc.isArmed) {
       this.orc.attack(this.attacker)
     } else {
       this.attacker.attack(this.orc)
     }
   }
}
```

为了确保我们可以审计战斗，我们将添加一个标志，然后检查和记录适当的调用。这会给对象添加相当多的管道，因为我们现在还需要依赖一种检查的方式，并因此向`util`库添加一个依赖。

### 提示

在大多数情况下，我认为标志参数是一个警示信号，因为它们表明多个关注点混合在一个地方，需要进行切换。通常，这可能是使用面向方面的方法更好地解决横切关注点的指示器。

向兽人战斗添加日志的更好方法是向战斗添加一个可记录的特性。该特性将是以下内容：

```js
var util = require("util")

var asLoggable = function () {
  Object.keys(this).forEach(function (key) {
    if (this.hasOwnProperty(key) && typeof this[key] === ' function' ) {
      var that = this
      var fn = this[key]
      this[key] = function () {
        console.log("Called " + key + " on " + util.inspect(that) + " with " + util.inspect(arguments))
        return fn.apply(that, arguments)
      }
    }
  }, this)
  return this
}
```

该代码将每个函数包装在一个函数中，首先记录其参数，然后将其转发给函数。由于 JavaScript 允许我们通过内省能力枚举要扩展的对象的所有属性，因此可以以一种抽象的方式实现这一点，而无需触及对象本身。

当应用于对象时，`asLoggable`特性会将对象的每个方法包装在一个记录方法中，写出调用了什么函数，以及使用了什么类型的参数，并且为了输出更有意义的信息，它使用了`inspect`库。

让我们将这应用于先前构建的代码，这意味着用`LoggableFight`对象替换`Fight`对象：

```js
var LoggableFight = asLoggable.call(Fight)
var fight = Object.create(LoggableFight).init(agronak, traugh)
fight.round()
```

现在调用将被记录，输出将如下，但为了可打印性而缩短：

```js
Called init on { init:…, round:…} with { … }
Called round on {…, orc: {…}, attacker: {…} } with {}
Agronak strikes Traugh with sword.
```

这个添加并不改变整体行为，而是对系统的纯扩展。

以这种方式扩展对象是一种非常强大的技术，但同时也可能非常危险。尽管代码创建起来相当简单，但要理解代码的某些属性来自何处并不容易，很大程度上取决于正确的命名。例如，如果我们完全替换了`Fight`对象，摆脱了`LoggableFight`对象名称，那么就不会有任何迹象表明为什么方法突然应用了日志记录，而在一个大型项目中，跟踪代码中的错误将会让开发人员感到困难。

## 命令查询分离

虽然面向方面是关于在对象级别上分离关注点，命令查询分离是关于在方法级别上分离关注点。我们之前已经看到处理状态是困难的，因此值对象比实体更简单。对于方法也是如此：向对象发送查询意味着只要对象保持相同的状态，查询就会以相同的方式回答，而且查询不会修改状态。这使得为查询编写测试非常容易，因为简单设置对象，并断言方法的输出就可以了。

命令可能更复杂，因为它们修改了被发送到的对象的状态。一般来说，命令没有返回值，但应该只导致对象的状态发生变化。这使得我们更容易测试命令的结果，因为我们可以设置一个对象，发送一个命令，并断言适当的变化已经被应用，而不必同时断言正确的返回值已经在途中返回。在编写命令时，我们需要牢记的是管理它们的失败状态，根据应用程序的不同，有多种处理方式。最简单的方式可能是引发异常，或者在使用`async`命令时，将错误返回给回调函数。这允许管理聚合，以便对问题做出反应，要么回滚，要么适当地处理问题。无论哪种方式，我们都不希望返回更复杂的结果，因为这很快就会导致依赖从命令返回的数据。

命令查询分离是编写可维护的、可测试和可扩展的代码时要牢记的核心原则之一。

## 普通旧对象

随着分离的出现，人们倾向于尽可能简化事物，尤其是在 JavaScript 中，大多数应用程序的最佳选择是使用 JavaScript 提供的简单、普通对象。我们在 JavaScript 中构建对象的方式有多种，本书中我们一直在使用经典的和更类似类的模式：

```js
function Orc(name) {
  this.name = name
}

Orc.prototype.introduce = function () {
  console.log("I AM " + this.name + "!")
}
```

在本章中，我们还使用了更类似 JavaScript 的模式，使用`Object.create`和示例对象。

在所有这些中需要注意的重要事情是，代码远离使用复杂的容器来管理对象、生命周期等。使用普通对象，无论使用什么模式来构建它们，意味着它们可以在隔离的情况下进行测试，并且在应用程序中简单地跟踪，同时根据需要广泛地使用核心语言的模式。

# 领域特定语言

使用特定关键词来描述领域的部分是我们在使用领域驱动设计构建系统时设定的主要目标之一。特别是 LISP 社区对 JavaScript 产生了影响，有一种强烈的倾向将语言与问题融合在一起。这自然地导致进一步尝试使语言适应领域，最终目标是拥有一种完美解决特定问题的语言。

这种开发被称为使用**特定领域语言**，简称**DSL**。在日常工作中，我们经常遇到许多 DSL，无论是用于描述 HTML 文档样式的 CSS，还是用于与数据库交互的 SQL。语言是 DSL，还是通用语言的界限通常有些模糊。例如，SQL 通常被认为是一种“真正”的编程语言，即使它具有修改和查询关系数据库的非常具体的目的。

DSL 通常是在主机语言和库上定义和实现的，首先提供功能，然后通过添加特殊语法来进一步完善。最近的一个例子可以在 Ruby 世界中看到，服务器管理工具 Chef 最初是一组函数库，用于控制服务器配置，但随着系统的发展，它变得更像 DSL，到现在为止，描述配置的语言仍然托管在 Ruby 上，但有自己的词汇来描述服务器管理的具体内容。当然，这种模式的优势在于底层语言仍然是 Ruby，一种通用语言，因此当 DSL 达到极限时，总是可以使用主机语言进行扩展。

## 创建 DSL

在我看来，这种模式是我们想要在系统中遵循的。在构建新应用程序时，从实际角度来看，开始设计 DSL 来解决领域的核心问题——在这一点上可能仍然未知——是不切实际的。但我们希望开始构建一个词汇库，用来描述我们的问题，将这种词汇库越来越紧密地粘合在一起，同时填补空白。这就是大多数（好的）DSL 的演变方式。它们起初是一个库，然后不断发展，直到达到一个实际上可以将语言本身提取为核心领域部分的程度。

JavaScript 本身充满了 DSL，因为语言设计非常适合构建将其功能公开为 DSL 的库。再次强调，界限并不总是清晰，但当我们看到以下代码时，我们可以看到某种 DSL 的特性。以下片段是来自[`jquery.com/`](https://jquery.com/)的一个例子：

```js
var $hiddenBox = $( "#banner-message" );
$( "#button-container button" ).on( "click", function( event ) {
  $hiddenBox.show();
});
```

代码使用**jQuery**选择引擎来定义元素上的点击处理程序，并在其中触发操作。

jQuery 已经成为几乎无处不在的库，并且被一些 Web 开发人员认为是必不可少的。jQuery 首先介绍了通过其选择器选择特定页面元素的方法，无论是通过`#`选择元素 ID，还是通过`.`选择类别元素。这种重用 CSS 中的选择器定义来选择页面元素的方式，因此能够使用一个函数——$，来创建一种语言来操作各种页面元素，这就是 jQuery 的真正力量。

### 领域驱动设计中的 DSL

当我们看其他领域特定语言时，我们应该意识到我们自己的开发方法并没有离真正领域特定语言的力量太远。当然还有很长的路要走，但即使是本章开头的简单示例也显示了我们在正确命名事物方面的发展，以便能够发展一种我们可以与领域专家交流的语言。这是领域特定语言的另一个优势，因为目标是使语言尽可能易于理解，以便于不被视为系统核心开发人员的人使用。

就像 jQuery 使得网页设计师可以开始使用 JavaScript 操纵他们的网页一样，我们项目中的语言应该使业务所有者能够检查系统应该反映的规则是否真正如他们所期望的那样。以下代码显示了我们如何使用我们的构建函数，清楚地展示了代码如何执行囚犯转移：

```js
prisonerTransfer = function (prisoner, otherDungeon, ourDungeon, notifier, callback) {
  var keeper = ourDungeon.getOrc()
  var carriage = ourDungeon.getCarriage()
  var transfer = prepareTransfer(carriage, keeper, prisoner)
  if (transfer) {
    notifier.message(otherDungeon, transfer)
    callback()
  } else {
    callback(new Error("Transfer initiation failed."))
  }
}
```

即使业务专家可能不会直接理解前面的代码，但它使我们能够进行解释。我们可以向专家解释输入，说：“囚犯转移涉及到囚犯被送往的地牢，囚犯来自的地牢，我们还需要通知地牢”。通过代码，我们可以解释沿途的步骤：

1.  一个囚犯应该被转移到另一个地牢。

1.  我们需要一个看守和一辆马车来执行转移。

1.  如果转移成功，将向地牢发送一条消息。

我们的目标是尽可能接近普通英语的简单易懂的规则。即使我们可能不会在日常代码审查中涉及业务专家，但在需要时能够尽可能接近代码来交叉检查规则是有用的，也能减少我们自己的心智负担。

# 获取知识

面向对象和它的特定形式当然不是我们唯一的影响，也不是我们应该拥有的唯一影响。在软件开发领域，已经发现了许多不同的开发软件的方法都是有用的，并且具有价值。根据我们想要构建的系统类型，甚至不总是最好的模拟为对象。

有一些非常常见的方法非常适合特定的问题，无论是在面对并发问题时采用更加函数式的方法，还是在尝试构建规则引擎时采用更加逻辑的方法。所有这些方法都会影响我们思考系统的方式，而我们工具箱中有更多不同的方法，我们就能更好地选择适合的方法。

### 提示

当然，某些方法对个人来说感觉更好；例如，我面对纯函数式、静态类型的方法时，例如 Haskell 用于开发软件时，我很难表达我对问题的想法。不过，不要因为这种挣扎而感到沮丧，因为即使你的日常工作似乎不适合这种方法，你可能会遇到一个完全适合的问题。

因此，我认为除了了解面向对象解决问题的方法之外，与领域驱动设计的密切关系并不是全部，介绍其他思考方式可能非常有帮助，可以从中获取知识。

## 函数式编程

| | *函数式编程是一种将计算建模为表达式求值的编程风格。* | |
| --- | --- | --- |
| | --*[`wiki.haskell.org/Functional_programming`](https://wiki.haskell.org/Functional_programming)* |

函数式编程在过去几年中获得了很大的影响力，它不仅在利基社区中获得了关注，而且一些公司也是基于函数式编程的理念创立的。

尽管它已经存在很长时间，但对函数式编程思想的兴趣最近出现了激增，但在开发需要同时为大量用户提供服务并尽可能无错的大规模系统时会出现问题。函数式编程的前提是，开发的大部分工作可以以纯函数式的方式完成，避免状态的变异以及传递函数到其他函数上执行，或者将值对象转换为最终结果。

随着我们的系统变得更加并行，并且需要处理更多并发请求，我们的代码越函数式，与不可变数据结构的交互越多，管理这种日益复杂的情况就越容易。我们可以避免对更复杂的锁定的需求，以及难以调试的竞争条件。

### 函数式编程和 JavaScript

JavaScript 受到了许多影响，无论是面向语言本身的原型继承机制，还是函数作为第一类公民的方式，就像**Scheme**，一个 LISP 方言中一样。

尽管这可能不是许多人使用该语言的主要关注点，但来自 Scheme 的这种影响使 JavaScript 在某种程度上具有函数式特性：

```js
var numbers = [1,2,3,4,5,6]

var result = numbers.map(function(number) {
  return (number * 2)
}).filter(function(e) {
  return (e % 2) === 0
}).reduce(function(acc, val) {
  return acc + val
})

result // => a number, like 40
```

在本章的开头，我们已经在数组上使用了`reduce`函数，现在我们可以继续使用`filter`和`map`来创建更复杂的操作链。这些方法都非常相似，并且抽象了迭代应该如何处理的知识，但它们让你表达要执行的动作。在映射的情况下，将每个元素转换为其平方，而在过滤的情况下，筛选出不符合特定标准的元素。

JavaScript 有基本的方法以函数式的方式操作元素。使用 map、reduce 和 filter 等方法，我们可以快速修改集合，例如，这种编程方式经常用于以类似的方式修改一组 HTML 元素。

当然，这样的程序也可以写成`for`循环，但在这种情况下，意图会在循环的设置以及循环变量的管理中丢失。专门用于修改集合的函数式方法是将问题简化为核心步骤并将其描述为要应用的函数的非常有效的方法，而无需担心如何映射每个元素，从原始集合中选择元素，以及最重要的是存储结果的位置。

为了增加可读性，我们可以根据需要命名被应用的函数，以减少读者理解函数体的心智负担。结合更高的抽象级别，这些集合方法，如之前介绍的`filter`和`reduce`等方法，意味着我们可以快速创建非常表达性的 API。

### 值对象

我们不想担心存储结果的位置，只是简单地操作输入，让语言来处理中间结果以及如何管理元素的传递，这是函数式编程的核心优势。尽管这对于 JavaScript 来说并非如此，但很容易看出编译器如何优化前面的代码，以批处理方式传递项目，甚至在单独的工作线程上操作项目，而不是让主进程做所有工作。

当我们不必直接处理并发问题时，这些优化很容易实现。并发的主要问题是程序不同部分之间的共享状态。因此，从功能方法中可能学到的主要内容是我们之前所说的“值对象”，即仅通过其属性而不是其身份来识别的对象，是一件好事。我们可以轻松地传递它们并使用函数修改它们的集合，并与任何人分享，因为它们不会改变。

值对象使依赖关系变得浅显，因为它们终止了我们必须考虑的链条。一旦到达值对象，我们可以确信，如果想要测试某些东西，只需要构造一个。不需要模拟、存根或任何复杂的东西。

值对象不仅是功能方法的核心，也许与函数是第一类事物的想法一样重要，而且它们还用于表示要通过系统传递的数据。正如我们之前所看到的，这些数据可以流动，而不必停下来作为一个整体进行评估。这种思维自然地导致了我们工具箱中的另一个工具，即使用事件来模拟系统的状态。

## 事件

现实世界的功能是通过对行动和事件的反应系统来实现的。如果有人想让我打开公寓的门，他们会按门铃，如果我在家，我会对此做出反应并去开门。这是一个明确定义的事件流程：首先有人决定触发我打开门，所以他们需要发现发送事件的服务，在这种情况下是门铃，然后按门铃触发事件。当我听到铃声时，我首先需要检查事件是否真的是给我的，对于门铃的情况取决于我是否独自在家。在决定事件确实是给我的之后，我可以决定如何做出反应，选择适当的处理程序，我会起身去开门。

在执行的每个点上，我可以决定如何处理下一步。例如，如果我在淋浴，我可能决定忽略事件，继续淋浴。完成后，我可能稍后检查门，排队处理事件。同样，在门铃的情况下，事件被多个消费者广播；例如，如果我妻子在家，她也可以去开门。从事件发送方面来看，我们也有多种选择：如果我在别人家外面，我可以决定按门铃，但如果没有反应，我可以检查是否有其他方法触发信号；例如，我可以敲门。以下图表显示了描述的事件流程：

![Events](img/B03704_07_01.jpg)

这个小例子展示了通过小组件之间通过事件通信来建模系统的强大力量。每个组件可以根据其当前负载或同时触发的其他事件来决定如何响应事件。可以通过在发送方或消费方重新排序事件来实现优先级，以确保系统对于约定的服务水平协议具有最佳的响应能力。

JavaScript 在其核心提供了这种事件处理，NodeJS 的`EventEmitter`是对核心思想的一个很好的抽象，导致非常清晰的代码，例如：

```js
var EventEmitter = require("events").EventEmitter
var util = require("util")

function House() {
  EventEmitter.call(this)

  var that = this

  this.pleaseOpen = function() {
    // use the EventEmitter to send the ring event
    that.emit("ring")
  }
}

util.inherits(House, EventEmitter)

var me = {
  onRing: function(ev) {
            console.log("opening door")
          }
}

var myHouse = new House()
// subscribe to the ring event, and dispatch it
myHouse.on("ring", me.onRing)

myHouse.pleaseOpen()
```

`EventEmitter`函数允许我们向任何需要的对象添加常见的与 JavaScript 文档对象模型交互的功能。在前面的代码中，我们使用`inherits`助手使我们的`House`成为`EventEmitter`。有了这个，我们可以对事件进行操作并分派它们。我们可以定义我们希望其他对象能够对其做出反应的事件，就像我们对点击或悬停事件做出反应一样。

### 事件存储与实体关系映射

根据我们的系统应该实现的目标，保存事件可能很重要。在我们的门铃示例中，当我在淋浴时，可能会出现我听不到事件的问题，以及我决定不予回应的问题。根据触发事件的人的原因，这可能是可以接受的，也可能不可以接受。

如果是邮递员试图投递包裹，而他们不想等待，他们可以设置一个短暂的超时等待回应，如果他们没有得到回应，他们可以在他们那一端再次排队投递包裹，重新上车，然后明天再试一次。在其他情况下，当我们希望系统传递事件来处理这种情况时，这也很常见，例如，当我错过一个电话时，我会收到一条包含通话详情的短信，或者一条保存事件详情的语音邮件，当我准备处理时，我可以这样做。

在许多软件系统中，我们希望事件传递系统尽可能地抽象化。甚至可以将系统构建为纯粹通过存储事件而从不实际修改任何数据，只是生成新事件再次存储。在这一点上，系统只需要知道消费者在事件流中的时间点，然后可以重播所需的内容，从而避免了将实体映射到数据库中存储可修改数据的需要。在这种情况下，唯一的实体是每个消费者在事件日志中的指针。由于这种系统只是最终一致性的，因此这并不容易实现，因为它会引发问题。毕竟，在系统之间发送事件需要时间，但对于一个相当复杂的系统来说，解决这个问题可能是值得的。

### 提示

这样的系统的一个很好的例子是**Kafka**，它是一个用于建模、消费、事件创建和存储的整个生态系统，但也有其他类似的例子。Martin Kleppman 在各种场合都写过关于这个的文章，并做过演讲，例如在 2014 年的 Spanconf：[`www.youtube.com/watch?v=b_H4FFE3wP0`](https://www.youtube.com/watch?v=b_H4FFE3wP0)。

创建这样的系统可能不是开发业务应用程序时最简单或首选的选择，因为支持它的基础设施的要求相当高。应用程序需要处理高可用性的越多，系统出于任何原因开始分布，这样的系统就变得越来越合理。JavaScript 作为一种语言非常适合处理事件，因为它是该语言构建的核心领域——在浏览器中对用户事件做出反应。

# 进一步阅读

在本章中，介绍了许多不是主要焦点但仍然增进了对领域驱动设计演变的理解的内容。受到解决方法的启发，可以真正改进一般的软件开发实践，因此我推荐进一步阅读。为了进一步理解面向对象，特别是寻找可用的设计模式，我推荐一本名为《四人帮》的书，以及《设计模式：可复用面向对象软件的元素》，作者是*Erich Gamma*, *Richard Helm*, *Ralph Johnson*, *John Vlissides*, *Pearson Publishing.* 尽管这本书很老，但它仍然代表了面向对象的经典作品，并确立了许多术语。另外，《Smalltalk 最佳实践模式》，作者是*Kent Becks*, *Prentice Hall*，真正拥抱了面向对象的设计，尽管这两本书自然不是专注于 JavaScript，但它们仍然可以在提高您的设计技能方面提供很大帮助。

在本章的另一端，我们详细介绍了如何开始建模事件流，这是目前非常热门的话题。Martin Kleppmann 在这个领域做了很多工作，因此密切关注他的工作将为您带来一些关于如何建模不断增长的应用程序的深刻见解（[`martin.kleppmann.com/`](https://martin.kleppmann.com/)）。

显然还有很多要跟进，但开始进行上述工作自然会导致更多的工作，可能超出短时间内的消化范围，因此我建议您继续跟进并深入研究。

# 总结

在本章中，我们探讨了领域驱动设计受到影响并可以通过相关软件开发模式进行增强的各种方式。有些模式比其他模式更接近，比如 DSL，有些则更正交，比如将系统建模为一系列事件。

重要的是要确保我们不要陷入尝试仅应用特定模式中看到的技术，而是要看看周围的情况，以确保我们使用合适的工具来完成工作。在其核心，领域驱动设计是关于建模商业软件的，虽然大多数商业软件遵循类似的模式和规则，但一些内部细节可能非常适合作为整个软件集成的功能核心，甚至是开发允许非技术业务专家清晰表达其规则的 DSL。

在下一章中，我们将总结我们遇到的所有细节，并思考如何处理像大多数商业软件一样不断变化的产品。
