# 第十四章：写清晰的测试

在上一章中，我们讨论了软件测试的理论和原则。我们深入探讨了单元测试、集成测试和端到端测试中固有的好处和挑战。在本章中，我们将把这些知识应用到一些现实世界的例子中。

仅仅理解测试是什么，并从商业角度看到它的优点是不够的。我们编写的测试构成了我们代码库的重要部分，因此应该以与我们编写的所有其他代码一样小心的方式来制作。我们希望编写的测试不仅能让我们对代码的预期工作方式有信心，而且它们本身也是可靠的、高效的、可维护的和可用的。我们还必须警惕编写过于复杂的测试。这样做会让我们陷入一种情况，使我们的测试增加了理解的负担，并导致代码库的整体复杂性和脆弱性增加，降低了整体生产力和满意度。

如果小心谨慎地使用，测试可以使代码库变得清晰和干净，从而使用户和同事能够以更快的速度和更高的质量进行工作。在接下来的章节中，我们将探讨编写测试时应遵循的最佳实践以及要避免的潜在陷阱。

在本章中，我们将涵盖以下主题：

+   测试正确的事情

+   编写直观的断言

+   创建清晰的层次结构

+   提供最终的清晰度

+   创建清晰的目录结构

# 测试正确的事情

在编写任何测试时，无论是细粒度的**单元测试**还是广泛的**端到端测试**，最重要的考虑之一是要测试*什么*。完全有可能测试错误的东西；这样做会让我们对我们的代码产生错误的信心。我们可能编写了一个庞大的测试套件，然后面带微笑离开，认为我们的代码现在满足了所有期望，并且完全容错。但我们的测试套件可能并没有测试我们认为它测试的东西。也许它只测试了一些狭窄的用例，让我们暴露在许多破坏的可能性中。或者它可能以一种在现实中从未模拟的方式进行测试，导致我们的测试无法保护我们免受生产中的故障。为了防范这些可能性，我们必须了解我们真正希望测试什么。

考虑一个我们编写的函数，从任意字符串中提取指定格式的电话号码。电话号码可以是各种形式，但始终有 9 到 12 位数字：

+   `0800-144-144`

+   `07792316877`

+   `01263 109388`

+   `111-222-333`

+   `0822 888 111`

这是我们当前的实现：

```js
function extractPhoneNumbers(string) {
  return string.match(/(?:[0-9][- ]?)+/g);
}
```

我们决定编写一个测试来断言我们代码的正确性：

```js
expect(
  extractPhoneNumbers('my number is 0899192032')
).toEqual([
  '0899192032'
]);
```

使用的断言至关重要。测试正确的事情很重要。在我们的例子中，这应该包括包含完整输入的示例字符串：包含电话号码的字符串，不包含数字的字符串，以及包含电话号码和非电话号码的字符串。仅测试正例太容易了，但实际上检查负例同样重要。在我们的场景中，负例包括没有电话号码可提取的情况，因此可能包含以下字符串：

+   `"this string is just text..."`

+   `"this string has some numbers (012), but no phone numbers!"`

+   `"1 2 3 4 5 6 7 8 9"`

+   `"01-239-34-32-1"`

+   `"0800 144 323 492 348"`

+   `"123"`

当编写这样的示例案例时，我们很快就会看到我们的实现将不得不迎合的复杂性范围。顺便说一句，这突显了采用**测试驱动开发**（***TDD**）来明确定义期望的巨大优势。现在我们有了一些包含我们*不希望*提取的数字的字符串的案例，我们可以将这些表达为断言，就像这样：

```js
expect(
  extractPhoneNumbers('123')
).toEqual([/* empty */]);
```

目前这个测试失败了。`extractPhoneNumbers('123')`调用错误地返回`["123"]`。这是因为我们的正则表达式尚未对长度做出任何规定。我们可以很容易地进行修复：

```js
function extractPhoneNumbers(string) {
  return string.match(/([0-9][- ]?){9,12}/g);
}
```

添加`{9,12}`部分将确保前面的组（`([0-9][- ]?)`）只匹配 9 到 12 次，这意味着我们对`extractPhoneNumbers('123')`的测试现在将正确返回`[]`（一个空数组）。如果我们对每个示例字符串重复进行这个测试和迭代过程，最终我们将得到一个正确的实现。

从这种情况中得出的关键是，我们应该寻求测试我们可能期望的所有输入。根据我们正在测试的内容，通常可以说我们编写的任何代码都将适用于有限的一组可能场景。我们希望确保我们有一组测试来分析这一系列场景。这一系列场景通常被称为给定函数或模块的**输入空间**或**输入域**。如果我们将其暴露给其*输入空间*中的代表性各种输入，我们可以认为它经过了充分测试，这种情况下，包括具有有效电话号码和不具有有效电话号码的字符串：

![](img/9c2c1545-fd35-4b16-b761-856e0abf89e1.png)

不需要测试每种可能性。更重要的是测试它们的代表性样本。为此，首先要确定我们的*输入空间*，然后将其分成单个代表性输入，然后逐个进行测试。例如，我们需要测试电话号码`"012 345 678"`是否被正确识别和提取，但对同一格式的变化进行详尽测试（如`"111 222 333"`，`"098 876 543"`等）是没有意义的。这样做不太可能揭示代码中的任何其他错误或漏洞。但我们确实应该测试具有不同标点符号或空格的其他格式（如`"111-222-333"`或`"111222333"`）。另外，建立可能超出预期*输入空间*的输入也很重要，例如无效类型和不受支持的值。

对软件需求的充分理解将使您能够产生一个经过正确实现并经过充分测试的实现。因此，在我们开始编写代码之前，我们应该始终确保我们清楚地知道我们的任务是什么。如果我们发现自己不确定完整的*输入空间*可能是什么，那就是一个强烈的指示，表明我们应该退一步，与利益相关者和用户交谈，并建立一套详尽的需求。再次强调，这是测试驱动的实施（TDD）的一个强大优势，因为这些需求的不足会在成本投入到无意义的实施之前被及早发现和解决。

当我们心中有了需求，并对整个*输入空间*有了很好的理解后，就可以开始编写我们的测试了。测试的最基本部分是其断言，因此我们要确保能够有效地制定直观的断言，以清晰地传达我们的期望。这将是接下来要讨论的内容。

# 编写直观的断言

任何测试的核心都是其断言。断言准确地规定了我们期望发生的事情，因此不仅要准确地制定它，而且要以一种清晰地表达我们期望的方式来制定它。

通常，单个测试会涉及多个断言。测试通常遵循以下形式：*给定输入 X，我是否收到输出 Y*？有时，建立*Y*是复杂的，可能不限于单个断言。我们可能希望内省*Y*，以确认它确实是期望的输出。

考虑一个名为`getActiveUsers(users)`的函数，它将从所有用户中仅返回活跃用户。我们可能希望对其输出进行多个断言：

```js
const activeUsers = getActiveUsers([
  { name: 'Bob', active: false },
  { name: 'Sue', active: true },
  { name: 'Yin', active: true }
]);

assert(activeUsers.length === 2);
assert(activeUsers[0].name === 'Sue');
assert(activeUsers[1].name === 'Yin');
```

在这里，我们清楚地表达了对 `getActiveUsers(...)` 输出的期望，作为一系列断言。鉴于更全面的断言库或更复杂的代码，我们可以轻松地将其限制为一个单一的断言，但将它们分开可能更清晰。

许多测试库和实用程序提供了抽象来帮助我们进行断言。例如，流行的测试库 Jasmine 和 Jest 都提供了一个名为 `expect` 的函数，它提供了许多 *匹配器* 的接口，每个匹配器都允许我们声明值应该具有的特征，如以下示例所示：

+   `expect(x).toBe(y)` 断言 `x` 与 `y` 相同

+   `expect(x).toEqual(y)` 断言 `x` 等于 `y`（类似于抽象相等）

+   `expect(x).toBeTruthy()` 断言 `x` 为真（或 `Boolean(x) === true`）

+   `expect(x).toThrow()` 断言当作为函数调用 `x` 时，会抛出错误

这些匹配器的确切实现可能因库而异，提供的抽象和命名也可能不同。例如，Chai.js 提供了 `expect` 抽象和简化的 `assert` 抽象，允许您以以下方式进行断言：

```js
assert('foo' !== 'bar', 'foo is not bar');
assert(Array.isArray([]), 'empty arrays are arrays');
```

制作断言时最重要的是要非常清晰。就像其他代码一样，很不幸，写一个难以理解或难以解析的断言是相当容易的。考虑以下断言：

```js
chai.expect( someValue ).to.not.be.an('array').that.is.not.empty;
```

由于 Chai.js 提供的抽象，这个语句看起来像是一个可读性强、易于理解的断言。但实际上，确切地理解正在发生什么是相当困难的。让我们考虑这个语句可能正在检查以下哪一个：

+   *该项不是数组？*

+   *该项不是空数组？*

+   *该项的长度大于零且不是数组？*

实际上，它正在检查该项既不是数组，又不为空——这意味着，如果该项是对象，它将检查它至少有一个自己的属性，如果是字符串，它将检查它的长度是否大于零。这些断言的真正基本机制被掩盖了，因此当程序员接触到这些东西时，可能会陷入一种幸福的无知状态（*认为断言按照他们希望的方式工作*）或痛苦的困惑状态（*想知道它到底是如何工作的*）。

也许我们一直想要断言的是 `someValue` 不仅不是数组，而且是“类似数组”，因此具有大于零的长度。因此，我们可以使用 Chai.js 的 `lengthOf` 方法来创建一个新的断言，以增加清晰度：

```js
chai.expect( someValue ).to.not.be.an('array');
chai.expect( someValue ).to.have.a.lengthOf.above(0);
```

为了避免任何疑惑和混淆，我们可以更直接地进行断言，而不依赖于 Chai.js 的类似句子的抽象：

```js
assert(!Array.isArray(someValue), "someValue is not an array");
assert(someValue.length > 0, "someValue has a length greater than zero");
```

这可能更清晰，因为它向程序员解释了正在进行的确切检查，消除了更抽象的断言风格可能引起的疑虑。

一个好的断言的关键在于它的清晰度。许多库提供了复杂和抽象的断言机制（例如通过 `expect()` 接口）。这些可以增加清晰度，但如果过度使用，可能会变得不太清晰。有时，我们只需要“保持简单，愚蠢”（KISS）。测试代码是最不适合使用自负或过度抽象的代码的地方。简单直接的代码每次都胜出。

现在我们已经探讨了制作直观断言的挑战，我们可以稍微“放大”一下，看看我们应该如何制作和组织包含它们的测试。下一节将介绍 *层次结构* 作为一个有助于通过我们的测试套件传达含义的机制。

# 创建清晰的层次结构

要测试任何代码库，我们可能需要编写大量的断言。从理论上讲，我们可以有一个很长的断言列表，除此之外什么也没有。然而，这样做可能会使阅读、编写和分析测试报告变得非常困难。为了避免这种混乱，测试库通常会在断言周围提供一些支撑抽象。例如，Jasmine 和 Jest 等 BDD 风格的库提供了两个支撑部分：`it`块和`describe`块。这些只是我们传递描述和回调的函数，但它们一起可以创建一个测试的分层树，使我们更容易理解发生了什么。使用这种模式来测试`sum`函数可能会这样做：

```js
// A singular test or "spec":
describe('sum()', () => {
  it('adds two numbers together', () => {
    expect( sum(8, 9) ).toEqual( 17 );
  });
});
```

**行为驱动开发**（**BDD**）是一种测试风格和方法，类似于 TDD，它强制我们先编写测试，然后再实现。然而，它更注重*行为*而不是*实现*的重要性，因为行为更容易沟通，从用户（或利益相关者）的角度来看更重要。BDD 风格的测试通常会使用诸如*描述 X»当 Z 发生时，它会执行 Y...*的语言。

非 BDD 库往往用更简单的无限嵌套的`test`块来包围断言组，如下所示：

```js
test('sum()', () => {
  test('addition works correctly', () => {
    assert(sum(8, 9) == 17, '8 + 9 is equal to 17');
  });
});
```

正如你所看到的，BDD 风格的`it`和`describe`术语的命名可以帮助我们为测试套件编写描述，这些描述读起来像完整的英语句子（例如*描述一个苹果»它又圆又甜*）。这并不是强制的，但可以帮助我们更好地描述。我们还可以无限嵌套`describe`块，以便我们的描述可以反映我们正在测试的事物的分层结构。因此，例如，如果我们正在测试一个名为`myMathLib`的数学工具，我们可以想象以下测试套件及其各种子套件和规范：

+   描述`myMathLib`：

+   描述`add()`：

+   它可以添加两个整数

+   它可以添加两个分数

+   对于非数字输入，它返回`NaN`

+   描述`subtract()`：

+   它可以减去两个整数

+   它可以减去两个分数

+   对于非数字输入，它返回`NaN`

+   描述`PI`：

+   它在十五位小数处等于`PI`

这种层次结构自然地反映了我们正在测试的抽象的概念层次结构。测试库提供的报告将有用地反映这种层次结构。以下是**Mocha**测试库的一个示例输出，其中`myMathLib`的每个测试都成功通过：

```js
myMathLib
  add()
    ✓ can add two integers
    ✓ can add two fractions
    ✓ returns NaN for non-numeric inputs
  subtract()
    ✓ can subtract two integers
    ✓ can subtract two fractions
    ✓ returns NaN for non-numeric inputs
  PI
    ✓ is equal to PI at fifteen decimal places
```

单个断言汇聚在一起形成测试。单个测试汇聚在一起形成测试套件。每个测试套件都为我们提供了关于特定单元、集成或流程（在 E2E 测试中）的清晰和信心。这些测试套件的组成对于确保我们的测试简单和可理解至关重要。我们必须花时间考虑如何表达我们正在测试的概念层次结构。我们创建的测试套件还需要直观地放置在代码库的目录结构中。这是我们接下来要探讨的内容。

# 提供最终的清晰度

可以说，测试的目标只是描述你所做的事情。通过描述，你被迫断言关于某事操作方式的*假设*真相。当这些断言被执行时，我们可以辨别出我们的描述，我们的*假设的真相*是否正确地反映了现实。

在描述的过程中，我们必须谨慎选择措辞，以便清晰和易于理解地表达我们的意思。测试是我们对模糊和复杂性的最后一道*防线*。有些代码是不可避免地复杂的，我们理想情况下应该以减少其模糊性的方式来构建它，但如果我们无法完全做到这一点，那么测试的作用就是消除任何剩余的困惑，并提供*最终*的清晰度。

在测试时保持清晰的关键是纯粹专注于必须阅读测试（或其记录输出）的人的视角。以下是一些特定的清晰度要点需要注意：

+   **使用测试的名称**准确描述测试的内容，必要时过度描述。例如，不要说*测试* `Navigation` *组件是否渲染*，而是说*测试* `Navigation` *组件是否正确渲染所有导航项*。我们的名称也可以传达我们问题域的概念层次结构。回想一下我们在第五章的*一致性和层次结构*部分中所说的内容，*命名是困难的*。

+   **使用变量**作为意义的载体。在编写测试时，使用变量名过于明确或者甚至在可能不需要的地方使用变量，以充分传达你的意图是一个好主意。例如，考虑`expect(value).toEqual(eulersNumber)`比`expect(value).toEqual(2.7182818)`更容易理解。

+   **使用注释**来解释奇怪的行为。如果你正在测试的代码以一种意外或不直观的方式执行某些操作，那么你的测试本身可能会显得不直观。作为最后的手段，提供额外的上下文和解释是很重要的。但是要注意，不要让注释变得陈旧，而不随着代码的更新而更新。

考虑`AnalogClockComponent`的以下测试：

```js
describe('AnalogClockComponent', () => {
  it('works', () => {
    const r = render(AnalogClockComponent, { time: "02:50:30" });
    expect(rendered.querySelector('.mm-h').style.transform)
      .toBe('rotate(210deg)');
    expect(rendered.querySelector('.hh-h').style.transform)
      .toBe('rotate(-30deg)');
    expect(rendered.querySelector('.ss-h').style.transform)
      .toBe('rotate(90deg)');
    expect(/\btheme-default\b/).test(rendered.className)).toBe(true);
  });
});
```

正如你所看到的，这个测试对特定元素的`transform` CSS 属性做出了几个断言。我们可能可以对这些做出一个知情的猜测，但是清晰度肯定可以得到改善。为了使其更清晰，我们可以使用更好的名称来反映我们正在测试的内容，将测试分开以代表不同的被测试概念，使用变量名来清楚地说明我们正在做断言的值，使用注释来解释任何可能不直观的事情：

```js
describe('AnalogClockComponent', () => {

  const analogClockDOM = render(AnalogClockComponent, {
    time: "02:50:30"
  });

  const [
    hourHandTransform,
    minuteHandTransform,
    secondHandTransform
  ] = [
    analogClockDOM.querySelector('.hh-h').style.transform,
    analogClockDOM.querySelector('.mm-h').style.transform,
    analogClockDOM.querySelector('.ss-h').style.transform
  ];

  describe('Hands', () => {

    // Note: the nature of rotate/deg in CSS means that a
    // time of 03:00:00 would render its hour-hand at 0deg.

    describe('Hour', () => {
      it('Renders at -30 deg reflecting 2/12 hours', () => {
        expect(hourHandTransform).toBe('rotate(-30deg)');
      });
    });
    describe('Minute', () => {
      it('Renders at 210 deg reflecting 50/60 minutes', () => {
        expect(minuteHandTransform).toBe('rotate(210deg)');
      });
    });
    describe('Second', () => {
      it('Renders at 90deg reflecting 30/60 seconds', () => {
        expect(secondHandTransform).toBe('rotate(90deg)');
      });
    });
  });

  describe('Theme', () => {
    it('Has the default theme set', () => {
      expect(
        /\btheme-default\b/).test(analogClockDOM.className)
      ).toBe(true);
    });
  });

});
```

你可能会观察到*更清晰*的方式要长得多，但是在测试时，最好偏向于这种冗长的描述。过度描述要比不足描述好，因为在后一种情况下，你的同事们会缺乏信息，他们会摸不着头脑，可能会对功能性做出错误的猜测。当我们提供大量的清晰度和解释时，我们正在帮助更广泛的同事和用户。然而，如果我们模糊和简洁，我们特别是限制了能理解我们代码的人群，从而限制了其可维护性和可用性。

现在我们已经探讨了通过良好结构的测试套件来展示*最终的清晰度*，我们可以再次*放大*，讨论我们如何通过目录结构和文件命名约定来传达我们正在编写的测试的目的和类型。

# 创建清晰的目录结构

我们的测试套件通常应该限制在单个文件中，以划分出我们的程序员同事关注的领域。尽管将这些测试文件组织成更大代码库的一部分可能是一个挑战。

想象一个具有以下目录结构的小型 JavaScript 代码库：

```js
app/
  components/
    ClockComponent.js
    GalleryComponent.js
  utilities/
    timer.js
    urlParser.js
```

将与特定代码相关的测试放置在靠近该代码所在位置的子目录中是相当典型的。在我们的示例代码库中，我们可以创建以下`tests`子目录来包含我们`components`和`utilities`的单元测试：

```js
app/
  components/
    ClockComponent.js
    GalleryComponent.js
    tests/
      ClockComponent.test.js
      GalleryComponent.test.js
  utilities/
    timer.js
    urlParser.js
    tests/
      timer.test.js
      urlParser.test.js
```

以下是一些关于约定的额外说明，正如我们现在应该知道的那样，这些约定对于增加代码库的熟悉度和直观性至关重要，因此也对整体清晰度至关重要：

+   有时测试被称为规范（*specifications*）。规范通常与测试没有什么不同，尽管作为名称，在 BDD 范式中稍微更受青睐。使用你感到舒适的那个。

+   通常会看到测试文件的后缀是`.test.js`或`.spec.js`。这样你的测试运行器可以轻松识别要执行的文件，对我们的同事也是一个有用的提醒。

+   看到测试目录的命名模式涉及下划线或其他非典型字符并不罕见，例如`__tests__`。这些命名模式通常用于确保这些测试不会作为主要源代码的一部分被编译或捆绑，并且可以很容易地被我们的同事辨别。

+   端到端或集成测试更常放置在更高的层次，这暗示了它们对多个部分的依赖。很常见看到一个高级别的`e2e`目录（或一些改编）。有时，集成测试被单独命名并存储在高层；其他时候，它们与单元测试交错存放在代码库中。

一次又一次，层次结构在这里是关键。我们必须确保我们目录的层次结构有助于反映我们代码和问题域的概念层次结构。作为代码库中平等且重要的一部分，测试应该被小心地和适当地放置在代码库中，而不是作为事后的想法。

# 总结

在本章中，我们将我们对测试的理论知识应用到了构建真实、有效和清晰的测试套件的实际技艺中。我们看了一些在这样做时存在的陷阱，并且我们强调了要努力追求的重要品质，比如清晰、直观的命名和遵循惯例。

在下一章中，我们将探讨各种工具，从代码检查器到编译器，以及更多，来帮助我们编写更干净的代码！
