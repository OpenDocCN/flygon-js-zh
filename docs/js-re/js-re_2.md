# 第二章：基础知识

在前一章中，我们已经看到为了匹配一个子字符串，你只需要在正则表达式中写入这个字符串。例如，要匹配`hello`，你可以创建这个变量：

```js
var pattern = /hello/;
```

我们还学到，如果我们想要匹配正则表达式的字符串或字符的所有出现，我们可以在正则表达式中使用`g`标志。然而，像这样具有明确模式的情况是罕见的，即使当它们出现时，是否需要**正则表达式**还是值得商榷的。当你有更少具体信息时，你才能真正看到正则表达式的真正力量。

正则表达式引擎实现了两个主要功能，可以正确表示你模式的 80%。我们将在本章介绍这两个主要功能：

+   模糊匹配器

+   乘数

# 在正则表达式中定义模糊匹配器

在这个主题中，我们将介绍**字符类**，告诉正则表达式匹配一个模糊字符。在**模糊匹配**中，可以是一个字符、数字或字母数字字符。

## 匹配通配符字符

假设我们想找到一个序列，其中我们有`1`，然后是任何其他字符，然后是`3`，这样它将包括`123`，`1b3`，`1 3`，`133`等等。对于这种情况，我们需要在我们的模式中使用一个*模糊匹配器*。

在前面的例子中，我们希望能够使用尽可能宽泛的匹配器；如果我们希望的话，我们可以选择不对其进行任何约束，它可以包括任何字符。对于这种情况，我们有`.`匹配器。

在正则表达式中，句号将匹配除了换行符以外的任何字符，因此它可以包括字母、数字、符号等等。为了测试这一点，让我们在我们的 HTML 实用程序中实现上述例子。在文本字段中，让我们输入一些组合来测试模式对`123 1b3 1 3 133 321`的匹配，然后对于模式，我们可以指定`/1.3/g`。运行它应该会给你类似于这样的结果：

![匹配通配符字符](img/2258OS_02_01.jpg)

## 匹配数字

**通配符字符**不是匹配模糊模式的唯一字符，也不总是正确的选择。例如，继续上一个例子，假设`1`和`3`之间的字符是一个数字。在这种情况下，我们可能不在乎哪个数字最终出现在那里，我们只需要确保它是一个数字。

为了实现这一点，我们可以使用`\d`。模糊匹配器`d`反斜杠或数字特殊字符将匹配 0 到 9 之间的任何字符。用反斜杠 d 字符替换句号将给我们以下结果：

![匹配数字](img/2258OS_02_02.jpg)

## 匹配字母数字字符

前面提到的四个匹配中，只有两个符合新的约束。最后一个主要的模糊匹配器是`\w`，它是一个**单词字符**。它将匹配下划线字符、数字，或者字母表的 26 个字母（无论是小写还是大写字母）。在我们的应用程序中运行这个将给我们以下结果：

![匹配字母数字字符](img/2258OS_02_03.jpg)

## 否定字母数字字符和数字

此外，如果你想要最后两个匹配器的否定版本，你可以使用它们的大写对应版本。我的意思是`\d`将匹配任何数字，但`\D`将匹配除数字之外的任何东西，因为它们是互补的，对于`\w`和`\W`也是一样。

# 在正则表达式中定义范围

在正则表达式中的**范围**允许你创建自己的自定义约束，就像我们刚刚讨论的那样。在一个范围内，你可以精确指定可以使用的字符，或者如果更快的话，你可以指定反向，也就是不匹配的字符。

为了举例说明，假设我们只想匹配`abc`。在这种情况下，我们可以创建类似于`[abc]`的范围，它将匹配一个单个字符，要么是`a`，`b`，要么是`c`。让我们用`bicycle`文本和`/[abc]/g`模式来测试一下：

![在正则表达式中定义范围](img/2258OS_02_04.jpg)

## 定义范围

现在，这将起作用，但是，如果您需要匹配很多字符，您的范围将很快变得很长。幸运的是，正则表达式允许您使用（`-`）破折号字符指定一组字符，而无需将它们列出。例如，假设我们要检查三个字母的名称是否格式正确，并且我们希望第一个字母是大写字母，后面跟着两个小写字母。我们可以将每个范围中的所有 26 个字母都指定为`[a-z]`或`[A-Z]`。因此，要实现三个字母名称验证器，我们可以创建类似于`/[A-Z][a-z][a-z]/g`的模式：

![定义范围](img/2258OS_02_05.jpg)

## 匹配破折号字符

如果您要匹配破折号字符本身，并且不希望 JavaScript 将其解释为指定集合，则可以使用破折号字符开始/结束范围，或者用反斜杠对其进行转义。例如，要匹配`"hello world"`和`"hello-world"`，我们可以编写类似于`/hello[- ]world/`或`/hello[\- ]world/`的模式。

我们还可以在范围内使用一个通配符，即简单的点。例如，当我们想匹配数字字符并且不介意有一个句点时（暂时忘记数字只能有一个句点时），就会出现这种情况。因此，要匹配`123`以及`2.4`和`.45`，我们可以指定`/[\d.][\d.]\d/`模式，然后第一个和第二个数字都可以是句点。请注意，JavaScript 不认为我们是在范围内引用通配符句点，因为这将破坏范围的目的，因此 JavaScript 将其视为标准句点。

## 定义否定范围

范围中最后要涵盖的是**否定范围**。否定范围正是其听起来的样子。与其指定要匹配的内容，我们指定不要匹配的内容。这与在 JavaScript 中为**布尔值**添加否定（`!`）字符非常相似，因为它只是翻转了您之前得到的返回值。

要创建否定范围，可以使用（`^`）插入符号字符开始范围以匹配任何字符；但是，对于字母表的前五个字母，您可以使用类似于`/[^a-e]/`的内容。

这本身可能看起来并不那么有用，但是您可能，例如，希望为文件名删除所有非字母字符。在这种情况下，您可以键入`/[^a-z]/gi`，并与 JavaScript 的`replace`函数结合使用，可以删除所有这些字符。

# 在正则表达式中定义乘数

匹配器很棒，但它们只能在一个方向上“扩展”您的模式。我喜欢将匹配器看作是垂直扩展模式的东西，允许您匹配更多适合相同模式的字符串，但它们仍然受长度限制，或者扩展模式的水平。**乘数**允许您匹配可能作为输入接收的任意大小的字符串，从而为您提供更大范围的自由度。

在正则表达式中有三种基本的乘数：

+   `+`：这匹配一个或多个出现

+   `?`：这匹配零次或一次出现

+   `*`：这匹配零个或多个出现

我们将在本节中介绍这三种乘数，并向您展示如何创建自定义乘数。

## 匹配一个或多个出现

最基本的乘数必须是（`+`）加号运算符。它告诉 JavaScript 正则表达式中使用的模式必须出现一次或多次。例如，我们可以在之前使用的格式化名称模式上构建，并且不仅匹配三个字母的名称，还可以使用`/[A-Z][a-z]+/g`匹配任何长度的名称：

![匹配一个或多个出现](img/2258OS_02_07.jpg)

此模式表示任何以大写字母开头并至少有一个小写字母的内容。加号将继续重复该模式，直到不再匹配（在我们的情况下，当它达到空格字符时）。

## 匹配零次或一次出现

下一个乘数，我猜可以称为更多的量词，是（`?`）问号。恰当地，这个乘数允许前面的字符要么出现要么不出现，几乎就像我们在说它的存在是可疑的。我认为最好的解释方法是通过一个例子来说明。假设我们想要接收`Apple`的单数形式或复数形式，为此，我们可以使用这个模式：

```js
/apples?/gi
```

![匹配零次或一次出现](img/2258OS_02_08.jpg)

现在这可能看起来像问号更像是一个条件运算符而不是一个乘数，但它真正做的是说前面的字符可以出现一次或零次。

## 匹配零次或多次出现

我们工具链中的下一个乘数是（`*`）星号。这个星号是前两个乘数的组合，允许前面的字符出现零次到无限次。因此，如果您的输入包含一个单词或字符多次，模式将匹配。如果您的输入不包含单词或字符，模式仍然匹配。例如，如果您正在解析某种`update`的日志，这可能会很有用。在这种情况下，您可能会得到`update`或者`update!!!`，根据一天的时间，甚至可能得到`update!!!!!!!!!!!!!!!!`。为了匹配所有这些字符串，您可以简单地创建模式`/update!*/g`。

![匹配零次或多次出现](img/2258OS_02_09.jpg)

这些是三种标准的乘数，类似于内置字符集（`\d`）范围的乘数。同样，正则表达式允许您指定和创建自己的乘数。

# 定义自定义量词

只有一种语法来指定自己的乘数，但由于可用的不同参数选项，您可以获得三种不同的功能选项。

如果你想匹配给定字符的具体次数，你可以在花括号内指定允许的重复次数。这不会使您的模式更灵活，但会使它们更易于阅读。例如，如果我们要实现一个电话号码，我们可以输入`/\d\d\d-\d\d\d\d/`。然而，这有点长，相反，我们可以使用自定义乘数，输入`/\d{3}-\d{4}/`，这样可以使它更简洁，更易读。

## 匹配 n 次或更多出现

接下来，如果你只想设置模式可以出现的最小次数，但实际长度并不重要，你可以在数字后面加上逗号。例如，假设我们想创建一个模式，以确保用户的密码至少有六个字符长；在这种情况下，您可能不想强制最大字符限制，因此可以输入类似`/.{6,}/`的内容：

![匹配 n 次或更多出现](img/2258OS_02_10.jpg)

## 匹配 n 到 m 次出现

我们自定义乘数的第三种变化是当您想要设置一组完整的选项，匹配最小和最大出现次数时。您可以在逗号后面简单地添加另一个数字。例如，如果我们有某种评论系统，并且我们希望限制评论在 15 到 140 个字符之间，我们可以创建一个正则表达式字符串来匹配这个设置，例如`/.{15,140}/`。

现在，我并不是说前面提到的两个例子是这种正则表达式的最佳用法，因为显然，检查文本长度有更简单的方法。然而，在更大模式的上下文中，这可能非常有用。

# 匹配交替选项

在这个阶段，我们知道如何使用模糊匹配器匹配任何一组字符，并且我们有能力使用乘法器重复模式以匹配任何类型的序列，这为你匹配几乎任何东西提供了一个相当不错的基础。然而，即使有了这一切，还是有一种情况经常出现并且可能会成为问题。当处理两种不同且完全独立的可接受输入形式时就会出现这种情况。

假设我们正在解析某种表单数据，对于每个问题，我们想要提取一个存储在某处的 yes 或 no。凭借我们目前的专业知识，我们可以创建一个类似于`/[yn][eo]s?/g`的模式，它将匹配`yes`和`no`。真正的问题在于它也会匹配这些字母的其他六种组合，而我们的应用程序可能不知道如何处理：

![匹配交替选项](img/2258OS_02_11.jpg)

幸运的是，正则表达式有一个完全不同的系统来处理这种情况，它就是(`|`)管道字符。它类似于你在`if`语句中使用的*OR*运算符，只不过这里只使用一个。它的工作原理是，你用管道分隔你想要匹配的不同模式，然后任何一个模式都可以返回匹配。将我们之前的正则表达式模式改为`/yes|no/g`将会显示正确的结果：

![匹配交替选项](img/2258OS_02_12.jpg)

好吧，至少几乎可以，尽管它仍然会匹配`nos`中的`no`。然而，这是因为我们一直在使用开放模式，而没有真正强制完整的单词（这是下一章的主题）。

管道字符不仅限于两个选项，我们可以通过用管道字符分隔它们来轻松匹配大量的值。此外，我们不仅限于使用纯文本，我们的正则表达式分割中的每个部分都可以使用范围和乘法器来定义自己的模式。

# 为电话号码创建一个正则表达式

为了总结这一章，让我们将刚刚学到的一些特性结合起来，构建我们在上一章中使用的电话号码模式。总之，我们希望能够匹配以下所有的数字模式：

```js
123-123-1234
(123)-123-1234
1231231234
```

首先，我们可以看到前三个数字（区号）周围有可选的括号，数字之间也有可选的破折号。这是一个问号字符派上用场的情况。对于数字本身，我们可以使用内置的匹配器来指定它们必须是数字，并使用强大的乘法器来指定我们需要多少个。我们需要知道的唯一特殊之处是括号包含特殊字符，所以我们需要对它们进行转义（添加反斜杠）：

```js
/\(?\d{3}\)?-?\d{3}-?\d{4}/g
```

### 注

括号在正则表达式中用于定义组，这就是它们为什么是特殊字符的原因。我们将在第三章中学习如何定义组，*特殊字符*。

使用我们在第一章中开发的测试应用程序以及本主题开头提到的示例来测试这个正则表达式，将会显示出这个正则表达式匹配所有的示例：

![为电话号码创建一个正则表达式](img/2258OS_02_13.jpg)

# 总结

在本章中，我们学习了如何使用字符类来定义通配符匹配、数字匹配和字母数字匹配。我们还学习了如何定义量词，它们指定了字符或组在输入中可以出现的次数。

在下一章中，我们将学习边界（可用于匹配正则表达式的位置）和定义组。
