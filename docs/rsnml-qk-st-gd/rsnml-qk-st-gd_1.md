# 第一章：介绍 ReasonML

过去十年，我们构建用户界面的方式发生了许多范式转变。Web 应用程序已经从服务器端框架转移到客户端框架，以提供更好的用户体验。设备和浏览器已经足够强大，可以运行强大的客户端应用程序，而 JavaScript 语言本身多年来也有许多改进。渐进式 Web 应用程序提供了类似本机的用户体验，WebAssembly 允许在 Web 平台上获得类似本机的性能。越来越多的应用程序正在为浏览器构建，导致需要维护更大的客户端代码库。

在这段时间内，几个框架、库、工具和一般最佳实践获得了然后失去了流行，导致许多开发人员出现了**JavaScript 疲劳**。由于对招聘和留住工程人才、生产力和可维护性的影响，公司越来越谨慎地承诺使用新技术。如果您向团队引入错误的技术（或者在错误的时间引入正确的技术），这可能是一个昂贵的错误。

对于许多公司和开发人员来说，React 已被证明是一个可靠的选择。2013 年，Facebook 在 2011 年内部使用了这个库后，将其开源。他们挑战我们重新思考最佳实践（[`www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be`](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be)），自那时起，它已经接管了前端开发（[`medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76`](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76)）。将标记、行为和样式封装到可重用的组件中已成为巨大的生产力和可维护性优势。DOM 的抽象化使得组件变得简单、声明式，易于理解、组合和测试。

通过 React，Facebook 在教育前端开发人员社区方面做得非常出色，传统的函数式编程范式使得更容易理解和维护代码。现在，Facebook 认为是使用 ReasonML 的时机。

这是来自[npmtrends.com](https://www.npmtrends.com/)的两年图表，显示了一些顶级 JavaScript 库和框架的每周 npm 下载次数。ReactJS 似乎是一个明显的赢家，每周下载量已经超过 250 万次：

![](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)

npmtrends.com

在本章中，我们将做以下事情：

+   讨论 ReasonML 是什么，以及它试图解决什么问题

+   了解 Facebook 选择 ReasonML 作为 ReactJS 未来的一些原因

+   在在线游乐场中尝试 ReasonML，并检查其编译（JavaScript）输出

# 什么是 ReasonML？

Reason 是 OCaml 语言的一层语法和工具，Facebook 积极使用这种语言。实际上，乔丹[沃尔克]在 React 之前就开始了 Reason 的概念。我们正在将其用作实际的前端语言（以及其他用途），因为我们认为在三年半之后，React 实验已经成功，人们现在已经准备好使用 Reason...

- 郑楼，2017 年 1 月

([`www.reactiflux.com/transcripts/cheng-lou/`](https://www.reactiflux.com/transcripts/cheng-lou/))

让我们扩展一下这个引用。ReasonML 不是一种新语言；它是 OCaml 语言的一种新语法，旨在让 JavaScript 开发人员感到熟悉。从现在开始，我们将称之为 Reason，它与 OCaml 具有完全相同的 AST，因此 Reason 和 OCaml 只在语法上有所不同。语义是相同的。通过学习 Reason，您也在学习 OCaml。事实上，有一个命令行工具可以在 OCaml 和 Reason 语法之间转换，称为`refmt`，它格式化 Reason/OCaml 代码类似于 JavaScript 的 prettier——事实上，prettier 受`refmt`启发。

OCaml 是一种以表现力和安全性为重点的通用编程语言。它最初发布于 1996 年，具有先进的类型系统，可以帮助捕捉错误而不妨碍编程。与 JavaScript 一样，OCaml 具有垃圾回收功能，用于自动内存管理，并且具有一流函数，可以作为参数传递给其他函数。

Reason 也是一个工具链，使得那些来自 JavaScript 背景的人更容易入门。这个工具链允许我们充分利用 JavaScript 和 OCaml 生态系统。我们将在第二章中深入探讨这一点，*设置开发环境*。现在，我们将直接在在线游乐场进行实验，访问 Reason 的在线游乐场[`reasonml.github.io/try`](https://reasonml.github.io/try)。

尝试在在线游乐场中输入这个 Hello World 的例子：

```js
let message = "World";
Js.log("Hello " ++ message);
```

有两件事你会注意到：

+   OCaml 语法会自动生成在编辑器的左下角（未显示）

+   Reason/OCaml 代码直接在浏览器中编译为 JavaScript：

```js
// Generated by BUCKLESCRIPT VERSION 3.2.0, PLEASE EDIT WITH CARE
'use strict';

var message = "World";

console.log("Hello World");

exports.message = message;
/* Not a pure module */
```

也许你会想知道 Reason/OCaml 代码是如何在浏览器中编译的。BuckleScript 是 Reason 的合作项目，它将 OCaml AST 编译为 JavaScript。由于 Reason 和 OCaml 都转换为相同的 OCaml AST，BuckleScript 同时支持 Reason 和 OCaml。此外，由于 BuckleScript 本身是用 OCaml 编写的，它可以被编译为 JavaScript 并直接在浏览器中运行。

检查编译后的 JavaScript 代码，你会发现它是多么易读。更仔细地观察，你会注意到编译后的输出也经过了优化：在`console.log`语句中，`"Hello World"`字符串直接内联，而不是使用`message`变量。

BuckleScript 利用 OCaml 类型系统和编译器实现的特性，在离线编译期间能够提供许多优化，使得运行时代码非常快速。

- BuckleScript 文档

([`bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript`](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)

值得注意的是，BuckleScript 还支持字符串插值([`bucklescript.github.io/docs/en/common-data-types.html#interpolation`](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation))：

```js
/* The message variable is interpolated */
{j|Hello $message|j}
```

# 为什么选择 Reason？

Reason 有什么让人着迷的？Reason 能做到 TypeScript 或 Flow 做不到的吗？它只是拥有静态类型检查器吗？这些是我刚开始接触 Reason 时的一些问题。

# 对不可变性和纯度的支持

理由不仅仅是拥有静态类型系统。同样重要的是 Reason 默认是不可变的。不可变性是函数式编程中的重要概念。在实践中，使用不可变数据结构（无法更改的数据结构）比可变数据结构产生更安全、更易于推理和更易于维护的代码。这将是本书中的一个重要主题。

纯度是函数式编程中的另一个重要概念。如果一个函数的输出仅由其输入决定，没有可观察的副作用，那么这个函数就是纯的。换句话说，纯函数除了返回一个值之外不做任何事情。以下是一个纯函数的例子：

```js
let add = (a, b) => a + b;
```

这是一个不纯的函数的例子：

```js
let add = (a, b) => {
  Js.log("side-effect");
  a + b;
};
```

在这种情况下的副作用是写入浏览器的控制台。这就是为什么在我们之前的 Hello World 例子中，BuckleScript 在编译输出的末尾包含了`/* Not a pure module */`注释。

改变全局变量也是一种副作用。考虑以下 JavaScript：

```js
var globalObject = {total: 0};
const addAndMutate = (a, b) => globalObject.total = a + b;
addAndMutate(40, 2);
/* globalObject now is mutated */
```

全局对象被改变了，现在它的`total`属性是`42`。现在我们必须意识到在使用它时，所有可以改变`globalObject`的区域。忘记这个对象既是全局的又是可变的，可能会导致难以调试的问题。解决这个问题的一种成语解决方案是将`globalObject`移到一个不再是全局的模块中。这样，只有该模块才能访问它。然而，我们仍然需要意识到这个模块内所有可以更新对象的区域。

如果`globalObject`是不可变的，就不会有改变它的方法。因此，我们不需要意识到所有可以改变`globalObject`的区域，因为不会有这些区域。我们将看到，使用 Reason，通过创建原始数据的更新副本来构建真实应用程序是相当简单和自然的。考虑以下内容：

```js
let foo = 42;
let foo = foo + 1;
Js.log(foo);
/* 43 */
```

语法感觉非常自然。正如我们将在本书的后面看到的，不可变性——通过返回更新的副本而不是在原地应用破坏性的更改——非常适合 React/Redux 的做事情方式。

原始的`foo`没有被改变；它被遮蔽了。一旦被遮蔽，旧的`foo`绑定就不可用了。绑定可以在局部作用域和全局作用域中被遮蔽：

```js
let foo = 42;

{
  let foo = 43;
  Js.log(foo); /* 43 */
};

Js.log(foo); /* 42 */

let foo = 43;
Js.log(foo); /* 43 */
```

尝试改变`foo`会导致编译错误：

```js
let foo = 42;
foo = 43;
/* compilation error */
```

我们可以看到，不可变性和纯度是相关的主题。拥有支持不可变性的语言可以让你以无副作用的方式编程。然而，如果纯度会导致代码变得比使用副作用更复杂和难以理解，怎么办？你可能会松一口气地得知，Reason（在本书的其余部分可以与 OCaml 互换使用）是一种实用的语言，让我们在需要时引起副作用。

使用像[Reason]这样的语言时，关键是不要避免副作用，因为避免副作用等同于避免做任何有用的事情。事实证明，在现实中，程序不仅仅是*计算*事情，它们*做*事情。它们发送消息，写文件，做各种各样的事情。做事情自动涉及副作用。支持纯度的语言给你的是，它让你能够在很大程度上将具有副作用的部分分割到代码的清晰和可控的区域，这样更容易推理。

- Yaron Minsky

（[`www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s`](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s)）

还要知道的是，不可变性并不会影响性能。在底层，有优化措施可以保持 Reason 的不可变数据结构快速。

# 模块系统

Reason 有一个复杂的模块系统，允许模块化开发和代码组织。在 Reason 中，所有模块都是全局可用的，当需要时，模块接口可以用来隐藏实现细节。我们将在第五章中探讨这个概念，*Effective ML*。

# 类型系统

Reason 的类型系统是可靠的，这意味着一旦编译，就不会有运行时类型错误。语言中没有`null`，也没有与`null`相关的任何错误。在 JavaScript 中，当某个东西是`number`类型时，它也可以是`null`。Reason 使用一个特殊类型来表示那些也可以是`null`的东西，并通过拒绝编译来强制开发人员适当处理这些情况。

到目前为止，我们已经写了一些，尽管基本的 Reason 代码，甚至没有谈论类型。Reason 会自动推断类型。正如我们将在本书中学到的那样，类型系统是一个工具，可以在不妨碍我们的情况下提供保证，并且当正确使用时，可以让我们将一些事情交给编译器，而不是留在我们的脑海中。

Reason 对不可变编程、健全类型系统和复杂的模块系统的支持是 Reason 如此出色的重要原因，而且在一个语言中同时使用所有这些特性，这是有意思的。当 Facebook 最初发布 React 时，他们要求我们给它五分钟（[`signalvnoise.com/posts/3124-give-it-five-minutes`](https://signalvnoise.com/posts/3124-give-it-five-minutes)），希望这种心态在这里也会有所收获。

# 跨平台

使用 Reason 构建 React 应用是一种愉快的体验，而且由于 OCaml 能够编译成本地代码，我们将能够利用这些技能构建编译成汇编、iOS/Android 等更多应用。事实上，Jared Forsyth 已经从一个 Reason 代码库中创建了一个名为 Gravitron 的游戏，可以编译成 iOS、Android、Web 和 macOS（[`github.com/jaredly/gravitron`](https://github.com/jaredly/gravitron)）。话虽如此，就目前而言，前端 JavaScript 的情况要更加完善。

# 可维护性

Reason 可能需要一些时间来适应，但你可以把这段时间看作是对未来产品维护和信心的投资。尽管渐进式类型系统的语言，如 TypeScript，可能更容易入门，但它们无法提供 Reason 这样健全类型系统所能提供的保证。Reason 的真正优势无法完全通过简单的例子来传达，只有在节省你在推理、重构和维护代码方面的时间和精力时才能真正展现出来。换句话说，如果有人告诉我他对我的床上没有蜘蛛有 99%的把握，我仍然会检查整个床，因为我不喜欢虫子！

只要你百分之百使用 Reason 并且你的代码编译通过，类型系统保证不会有运行时类型错误。当你与非 Reason 代码（例如 JavaScript）进行互操作时，会引入运行时类型错误的可能性。Reason 的健全类型系统使你可以相信应用程序的 Reason 部分不会引起运行时类型错误，因此可以专注于确保这些应用程序区域是安全的。根据我的经验，在动态语言中编程可能会感觉明显危险。另一方面，Reason 总是给人一种有保障的感觉。

# 互操作性

话虽如此，有时候，特别是在初学类型系统时，你可能不确定如何使你的代码编译通过。通过 BuckleScript，Reason 允许你在需要时直接使用原始 JavaScript，无论是通过绑定还是直接在你的 Reason（.re）文件中。这使你可以在 JavaScript 中逐步解决问题，然后一旦准备好，将代码部分转换为类型安全的 Reason。

BuckleScript 还让我们以一种非常合理的方式绑定到惯用的 JavaScript。正如你将在第四章《BuckleScript、Belt 和互操作性》中了解到的那样，BuckleScript 是 Reason 的一个非常强大的部分。

# ES2030

使用 Reason 感觉就像在编写 JavaScript 的未来版本。一些 Reason 语言特性，包括管道操作符（[`github.com/tc39/proposal-pipeline-operator`](https://github.com/tc39/proposal-pipeline-operator)）和模式匹配（[`github.com/tc39/proposal-pattern-matching`](https://github.com/tc39/proposal-pattern-matching)），目前正在向 TC39 委员会提议将其添加到 JavaScript 语言中。通过 Reason，我们可以立即利用这些特性以及更多。

# 社区

Reason 社区无疑是我参与过的最乐于助人、支持和包容的社区之一。如果你有问题或遇到困难，Reason Discord 频道是实时支持的好去处。

原因 Discord 频道：

[`discord.gg/reasonml`](https://discord.gg/reasonml)

通常，当开始使用新技术时，与有经验的人交谈五分钟可以节省你几个小时的挫败感。我个人在一天（和夜晚）的所有时间都问问题，并对有多快有人帮助我感到非常感激和惊讶。花点时间加入 Discord 频道，介绍自己，提问，并分享如何使 Reason 变得更好的反馈！

# ReactJS 的未来

实际上，很少有真实世界的应用程序仅使用 ReactJS。通常会引入其他技术，如 Babel、ESLint、Redux、Flow/TypeScript 和 Immutable.js，以帮助增加代码库的可维护性。Reason 通过其核心语言特性取代了对这些额外技术的需求。

ReasonReact 是一个与 ReactJS 绑定并提供了一种更简单、更安全的构建 ReactJS 组件的 Reason 库。就像 ReactJS 只是 JavaScript 一样，ReasonReact 只是 Reason。此外，它很容易逐步采用，因为它是由创建 ReactJS 的同一个人制作的。

ReasonReact 带有内置路由器、类似 Redux 的数据管理和 JSX。如果你来自 ReactJS 背景，你会感到非常亲切。

值得一提的是，Reason/ReasonReact 已经被一些公司在生产中使用，包括世界上最大的代码库之一。Facebook 的 messenger.com 代码库已经超过 50%转换为 ReasonReact。

ReasonReact 的每个功能都在 messenger.com 代码库上进行了广泛测试。

- Cheng Lou

([`reason.town/reason-philosophy`](https://reason.town/reason-philosophy))

因此，Reason 和 ReasonReact 的新版本都配备了代码修改，自动化了大部分甚至全部的代码库升级过程。在发布给公众之前，新功能在 Facebook 内部经过了彻底的测试，这带来了愉快的开发者体验。

# 探索 Reason

请问以下是一个语句还是一个表达式：

```js
let foo = "bar";
```

在 JavaScript 中，它是一个语句，但在 Reason 中，它是一个表达式。另一个表达式的例子是`4 + 3`，也可以表示为`4 + (2 + 1)`。

Reason 中的许多东西都是表达式，包括`if-else`、`switch`、`for`和`while`等控制结构：

```js
let message = if (true) {
  "Hello"
} else {
  "Goodbye"
};
```

我们在 Reason 中也有三元运算符。以下是表达前述代码的另一种方式：

```js
let message = true ? "Hello" : "Goodbye";
```

即使是匿名块作用域也是表达式，其结果为最后一行的表达式：

```js
let message = {
  let part1 = "Hello";
  let part2 = "World";
  {j|$part1 $part2|j};
};
/* message evaluates to "Hello World" */
/* part1 and part2 are not accessible here */
```

`元组`是一个不可变的数据结构，可以容纳不同类型的值，并且可以是任意长度的：

```js
let tuple = ("one", 2, "three");
```

让我们利用我们已经知道的知识，从 Reason 的在线游乐场中的`FizzBuzz`示例开始。`FizzBuzz`曾是一个流行的面试问题，用来确定候选人是否能编程。挑战是编写一个问题，打印从`1`到`100`的数字，但对于三的倍数打印`Fizz`，对于五的倍数打印`Buzz`，对于三和五的倍数打印`FizzBuzz`：

```js
/* Based on https://rosettacode.org/wiki/FizzBuzz#OCaml */
let fizzbuzz = (i) =>
  switch (i mod 3, i mod 5) {
  | (0, 0) => "FizzBuzz"
  | (0, _) => "Fizz"
  | (_, 0) => "Buzz"
  | _ => string_of_int(i)
  };

for (i in 1 to 100) {
  Js.log(fizzbuzz(i))
};
```

在这里，`fizzbuzz`是一个接受整数并返回字符串的函数。一个命令式的`for`循环将其输出记录到控制台。

在 Reason 中，函数的最后一个表达式成为函数的返回值。`switch`表达式是唯一的`fizzbuzz`表达式，所以无论它评估为什么都成为`fizzbuzz`的输出。与 JavaScript 一样，`switch`评估一个表达式，并执行第一个匹配的分支。在这种情况下，`switch`评估元组表达式：`(i mod 3, i mod 5)`。

给定`i=1`，`(i mod 3, i mod 5)`变为`(1, 1)`。由于`(1, 1)`不匹配`(0, 0)`、`(0, _)`或`(_, 0)`，按顺序，最后一个`_`（也就是*任何东西*）被匹配，返回`"1"`。类似地，当给定`i=2`时，`fizzbuzz`返回`"2"`。当给定`i=3`时，返回`"Fizz"`。

或者，我们可以使用`if-else`来实现`fizzbuzz`：

```js
let fizzbuzz = (i) =>
  if (i mod 3 == 0 && i mod 5 == 0) {
    "FizzBuzz"
  } else if (i mod 3 == 0) {
    "Fizz"
  } else if (i mod 5 == 0) {
    "Buzz"
  } else {
    string_of_int(i)
  };
```

然而，switch 版本更易读。正如我们将在本章后面看到的那样，switch 表达式，也称为**模式匹配**，比我们迄今为止看到的更强大。

# 数据结构和类型

类型是一组值。更具体地说，`42`具有`int`类型，因为它是包含在整数集合中的值。浮点数是包含小数点的数字，即`42.`和`42.0`。在 Reason 中，整数和浮点数有不同的运算符：

```js
/* + for ints */
40 + 2;

/* +. for floats */
40\. +. 2.;
```

对于`-.`, `-`, `*.`，`*`，`/.`和`/`也是如此。

Reason 使用双引号表示`string`类型，单引号表示`char`类型。

# 创建我们自己的类型

我们也可以创建我们自己的类型：

```js
type person = (string, int);

/* or */

type name = string;
type age = int;
type person = (name, age);
```

这是我们如何创建`person`类型的人：

```js
let person = ("Zoe", 3);
```

我们还可以用它的类型注释任何表达式：

```js
let name = ("Zoe" : string);
let person = ((name, 3) : person);
```

# 模式匹配

我们可以在我们的人身上进行模式匹配：

```js
switch (person) {
| ("Zoe", age) => {j|Zoe, $age years old|j}
| _ => "another person"
};
```

让我们使用记录而不是元组来表示我们的人。记录类似于 JavaScript 对象，只是它们更轻量，并且默认情况下是不可变的：

```js
type person = {
  age: int,
  name: string
};

let person = {
  name: "Zoe",
  age: 3
};
```

我们也可以在记录上进行模式匹配：

```js
switch (person) {
| {name: "Zoe", age} => {j|Zoe, $age years old|j}
| _ => "another person"
};
```

与 JavaScript 一样，`{name: "Zoe", age: age}`可以表示为`{name: "Zoe", age}`。

我们可以使用扩展（`...`）运算符从现有记录创建新记录：

```js
let person = {...person, age: person.age + 1};
```

记录在使用之前需要类型定义。否则，编译器将出现以下类似的错误：

```js
The record field name can't be found.

```

记录必须与其类型具有相同的形状。因此，我们不能向我们的`person`记录添加任意字段：

```js
let person = {...person, favoriteFood: "broccoli"};

/*
  We've found a bug for you!

  This record expression is expected to have type person
  The field favoriteFood does not belong to type person
*/
```

元组和记录是产品类型的例子。在我们最近的例子中，我们的`person`类型需要一个`int`和一个`age`。几乎所有 JavaScript 的数据结构都是产品类型；唯一的例外是`boolean`类型，它要么是`true`，要么是`false`。

Reason 的变体类型是求和类型的一个例子，它允许我们表达这个或那个。我们可以将`boolean`类型定义为一个变体：

```js
type bool =
  | True
  | False;
```

我们可以有尽可能多的构造函数：

```js
type decision =
  | Yes
  | No
  | Maybe;
```

`Yes`，`No`和`Maybe`被称为构造函数，因为我们可以使用它们来构造值。它们也通常被称为**标签**。因为这些标签可以构造值，变体既是一种类型，也是一种数据结构：

```js
let decision = Yes;
```

当然，我们也可以在`decision`上进行模式匹配：

```js
switch (decision) {
| Yes => "Let's go."
| No => "I'm staying here."
| Maybe => "Convince me."
};
```

如果我们忘记处理一个情况，编译器会警告我们：

```js
switch (decision) {
| Yes => "Let's go."
| No => "I'm staying here."
};

/*
  Warning number 8

  You forgot to handle a possible value here, for example: 
  Maybe
*/
```

在第二章中，我们将学习*设置开发环境*，编译器可以配置为将此警告转换为错误。让我们看一种方法，通过利用这些穷尽性检查来帮助使我们的代码更具弹性，以应对未来的重构。

接下来的例子中，我们的任务是根据座位的区域来计算音乐会场地的座位价格。地板座位价格为 55 美元，而其他座位价格为 45 美元：

```js
type seat =
  | Floor
  | Mezzanine
  | Balcony;

let getSeatPrice = (seat) =>
  switch(seat) { 
  | Floor => 55
  | _ => 45
  };
```

如果以后音乐会场地允许在管弦乐区出售座位，价格为 65 美元，我们首先会向`seat`添加另一个构造函数：

```js
type seat =
  | Pit
  | Floor
  | Mezzanine
  | Balcony;
```

然而，由于使用了通配符`_`，我们的编译器在此更改后没有投诉。如果它这样做会更好，因为这将在重构过程中帮助我们。在更改类型定义后，逐步浏览编译器消息是 Reason（以及 ML 语言系列）如何使重构和扩展代码成为一个更安全、更愉快的过程。当然，这不仅限于变体类型。向`person`类型添加另一个字段也会导致相同的逐步浏览编译器消息的过程。

相反，我们应该保留使用`_`来处理无限数量的情况（例如我们的`fizzbuzz`示例）。我们可以重构`getSeatPrice`以使用显式情况：

```js
let getSeatPrice = (seat) =>
  switch(seat) { 
  | Floor => 55
  | Mezzanine | Balcony => 45
  };
```

在这里，我们欢迎编译器友好地通知我们未处理的情况，然后添加它：

```js
let getSeatPrice = (seat) =>
  switch(seat) {
  | Pit => 65
  | Floor => 55
  | Mezzanine | Balcony => 45
  };
```

现在让我们想象，即使在同一区域的座位（即具有相同标签的座位）也可以有不同的价格。好吧，Reason 变体也可以保存数据：

```js
type seat =
  | Pit(int)
  | Floor(int)
  | Mezzanine(int)
  | Balcony(int);

let seat = Floor(57);
```

我们可以使用模式匹配访问这些数据：

```js
let getSeatPrice = (seat) =>
  switch (seat) {
  | Pit(price)
  | Floor(price)
  | Mezzanine(price)
  | Balcony(price) => price
  };
```

变体不仅限于一个数据。假设我们希望我们的`seat`类型存储其价格以及它是否仍然可用。如果不可用，它应该存储持票人的信息：

```js
type person = {
  age: int,
  name: string,
};

type seat =
  | Pit(int, option(person))
  | Floor(int, option(person))
  | Mezzanine(int, option(person))
  | Balcony(int, option(person));
```

在解释`option`类型之前，让我们看一下它的实现：

```js
type option('a)
  | None
  | Some('a);
```

上述代码中的`'a`称为**类型变量**。类型变量总是以`'`开头。这种类型定义使用类型变量，以便它可以适用于任何类型。如果没有，我们将需要创建一个`personOption`类型，它只适用于`person`类型：

```js
type personOption(person)
  | None
  | Some(person);
```

如果我们想要另一种选项呢？我们可以声明一个多态类型，而不是一遍又一遍地重复这个类型声明。多态类型是包含类型变量的类型。在我们的例子中，`'a`（读作 alpha）类型变量将与`person`交换。由于这种类型定义非常常见，Reason 的标准库中已经包含了它，所以在你的代码中不需要声明`option`类型。

回到我们的`seat`示例，我们将其价格存储为`int`，持票人存储为`option(person)`。如果没有持票人，它仍然可用。我们可以有一个`isAvailable`函数，它将接受一个`seat`并返回一个`bool`：

```js
let isAvailable = (seat) =>
  switch (seat) {
  | Pit(_, None)
  | Floor(_, None)
  | Mezzanine(_, None)
  | Balcony(_, None) => true
  | _ => false
  };
```

让我们退一步，看看`getSeatPrice`和`isAvailable`的实现。很遗憾，当它们与座位的价格或可用性无关时，这两个函数都需要知道不同的构造函数。再看一下我们的`seat`类型，我们发现对于每个构造函数，`(int, option(person))`都是重复的。此外，在`isAvailable`中没有一个很好的方法来避免使用`_`情况。这些都是另一种类型定义可能更好地满足我们需求的迹象。让我们从`seat`类型中删除参数，并将其重命名为`section`。我们将声明一个新的记录类型，称为`seat`，其中包含`section`、`price`和`person`字段：

```js
type person = {
  age: int,
  name: string,
};

type section =
 | Pit
 | Floor
 | Mezzanine
 | Balcony;

type seat = {
  section, /* same as section: section, */
  price: int,
  person: option(person)
};

let getSeatPrice = seat => seat.price;

let isAvailable = seat =>
  switch (seat.person) {
  | None => true
  | Some(_person) => false
  };
```

现在，我们的`getSeatPrice`和`isAvailable`函数的信噪比更高，当`section`类型发生变化时，它们不需要改变。

顺便说一句，`_`用于在变量前加前缀，以防止编译器警告我们未使用变量。

# 使无效状态不可能

假设我们想要向`seat`添加一个字段来保存座位购买日期：

```js
type seat = {
  section,
  price: int,
  person: option(person),
  dateSold: option(string)
};
```

现在，我们在我们的代码中引入了一个无效状态的可能性。以下是这种状态的一个例子：

```js
let seat = {
  section: Pit,
  price: 42,
  person: None,
  dateSold: Some("2018-07-16")
};
```

理论上，`dateSold`字段应该只在`person`字段持有票持有者时保存日期。票有一个售出日期，但没有所有者。我们可以查看我们的想象实现，以验证这种状态永远不会发生，但仍然有可能我们遗漏了一些东西，或者一些微小的重构引入了一个被忽视的错误。

由于我们现在可以利用 Reason 的类型系统的功能，让我们把这项工作交给编译器。我们将使用类型系统来强制执行代码中的不变量。如果我们的代码违反这些规则，它将无法编译。

一个暗示这种无效状态可能存在的信号是在我们的记录字段中使用`option`类型。在这些情况下，可能有一种方法可以使用变体，使得每个构造函数只包含相关的数据。在我们的情况下，我们的售出日期和持票人数据应该只在座位被售出时存在：

```js
type person = {
  age: int,
  name: string,
};

type date = string;

type section =
  | Pit
  | Floor
  | Mezzanine
  | Balcony;

type status =
  | Available
  | Sold(date, person);

type seat = {
  section,
  price: int,
  status
};

let getSeatPrice = (seat) => seat.price;

let isAvailable = (seat) =>
  switch (seat.status) {
  | Available => true
  | Sold(_) => false
  };
```

看看我们的新`status`类型。`Available`构造函数不包含数据，`Sold`包含售出日期以及持票人。

有了这个`seat`类型，就没有办法表示之前的无效状态，即没有票持有者的售出日期。我们的`seat`类型也不再包含`option`类型，这是一个好迹象。

# 摘要

在本章中，我们对 Reason 是什么以及它试图解决什么问题有了一定的了解。我们看到 Reason 的类型推断消除了与静态类型语言相关的许多负担。我们了解到类型系统是一个可以用来为代码库提供强大保证的工具，从而提供出色的开发者体验。虽然可能需要一些时间来适应 Reason，但对于中等规模到较大规模的代码库来说，这是非常值得投资的。

在下一章中，当我们设置开发环境时，我们将了解 Reason 的工具链。在第三章《创建 ReasonReact 组件》中，我们将开始构建一个应用程序，这个应用程序将贯穿本书的其余部分。通过本书的学习，您将能够在 Reason 中轻松构建真实世界的 React 应用程序。
