# 第五章：命名事物很难

名字无处不在。它们是我们大脑抽象宇宙复杂性的方式。在软件世界中，我们总是在努力创造新的抽象来描述我们的日常现实。编程世界中的一个常见警句是*命名事物很难*。想出一个名字并不总是很难，但想出一个*好*名字通常是很难的。

在之前的章节中，我们已经探讨了抽象背后的原则和理论。在本章中，我们将提供这个谜题的最后一把钥匙。一个抽象如果没有好的命名，就不能成为一个好的抽象。在我们使用的名字中，我们在提炼一个概念，而这种提炼将定义人们最终理解这个概念的方式。因此，命名事物不仅仅是提供任意标签；它是提供理解。只有通过一个好的名字，用户或其他程序员才能完全内化我们的抽象，并以全面的理解来使用它。

在本章中，我们将使用一些例子来探讨一个好名字的关键特征。我们还将讨论在 JavaScript 这样的动态类型语言中命名事物的挑战。通过本章，我们应该清楚地了解如何提出干净和描述性的名字。

具体来说，我们将涵盖以下主题：

+   名字中有什么？

+   命名反模式

+   一致性和层次结构

+   技术和考虑*事项*

# 名字中有什么？

分解一个好名字的关键元素是困难的。它似乎更像是一门艺术而不是一门科学。一个*相当好*的名字和一个*非常好*的名字之间的界限模糊不清，容易受主观意见的影响。

考虑一个负责将多个 CSS 样式应用于按钮的函数。想象一种情况，这是一个独立的函数。以下哪个名字你认为最合适？

+   `styleButton`

+   `setStyleOfButton`

+   `setButtonCSS`

+   `stylizeButton`

+   `setButtonStyles`

+   `applyButtonCSS`

你可能已经选择了你喜欢的。在阅读本书的人中，肯定会有分歧。这些分歧中的许多将根植于我们自己的偏见。我们的许多偏见将受到诸如我们说什么语言、我们之前接触过哪些编程语言以及我们花时间创建哪种类型的程序等因素的影响。我们之间存在许多差异，但是，不知何故，我们必须提出一个关于好名字或干净名字的非模糊概念。至少可以说，一个好的名字可能具有以下特征：

+   **目的**：某物的用途和行为方式

+   **概念**：它的核心思想以及如何思考它

+   **合同**：关于它如何工作的期望

这并不能完全涵盖命名的复杂性，但是有了这三个特征，我们有了一个起点。在本节的其余部分，我们将学习这些特征如何对命名事物的过程至关重要。

# 目的

一个好的名字表明了**目的**。目的是某物做什么，或者某物*是*什么。在函数的情况下，它的目的就是它的行为。这就是为什么函数通常以动词形式命名，比如`getUser`或`createAccount`，而存储值的东西通常是名词，比如*account*或*button*。

一个概括清晰目的的名字永远不需要进一步解释。它应该是不言自明的。如果一个名字需要注释来解释它的目的，那通常意味着它没有完成作为名字的工作。

某物的目的是高度上下文化的，因此将受到周围代码和该名字所在代码库区域的影响。这就是为什么通常可以使用通用名字，只要它周围有助于说明其目的的上下文。例如，比较`TenancyAgreement`类中的这三个方法签名：

```js
class TenancyAgreement {

  // Option #1:
  saveSignedDocument(
    id,
    timestamp
  ) {}

  // Option #2:
  saveSignedDocument(
    documentId,
    documentTimestamp
  ) {}

  // Option #3:
  saveSignedDocument(
    tenancyAgreementSignedDocumentID,
    tenancyAgreementSignedDocumentTimestamp
  ) {}

}
```

当然，这是有主观性的，但大多数人会同意，当我们有一个能够很好地传达其目的的周围上下文时，我们不需要详细命名该上下文中的每个变量。考虑到这一点，我们可以说前面代码中的`Option #1`过于局限，可能会引起歧义，而`Option #3`过于冗长，因为其参数名称的一部分已经由其上下文提供。然而，`Option #2`，使用`documentId`和`documentTimestamp`，是恰到好处的：它充分传达了参数的目的。这就是我们需要的。

目的对于任何名称来说绝对是至关重要的。没有描述或目的的指示，名称只是装饰而已，通常意味着我们的代码使用者只能在文档和其他代码片段之间翻找，才能弄清楚某些事情。因此，我们必须记住始终考虑我们的名称是否能很好地传达目的。

# 概念

一个好的名称表明**概念**。名称的概念指的是其背后的想法，其创建的意图，以及我们应该如何思考它。例如，一个名为`relocateDeviceAccurately`的函数不仅告诉我们它将做什么（它的目的），还告诉我们关于其行为周围概念的概念。从这个名称中，我们可以看到设备是可以被定位的东西，并且可以以不同的精度定位这些设备。一个相对简单的名称可以在阅读它的人的头脑中唤起丰富的概念。这是命名事物的重要力量的一部分：名称是理解的途径。

一个名称的概念，就像它的目的一样，与它存在的上下文紧密相关。上下文是我们的名称存在的*共享空间*。围绕我们感兴趣的名称的其他名称绝对有助于帮助我们理解它的概念。想象一下以下名称一起出现：

+   `rejectedDeal`

+   `acceptedDeal`

+   `pendingDeal`

+   `stalledDeal`

通过这些名称，我们立即理解到*deal*是一种至少可以有四种不同状态的东西。这暗示着这些状态是相互排斥的，不能同时适用于一项交易，尽管目前还不清楚。我们可能会假设是否有特定条件与交易是否待定或停滞有关，尽管我们不确定这些条件是什么。因此，即使存在歧义，我们已经开始建立对问题领域的丰富理解。这仅仅是通过查看名称，甚至没有阅读实现。

我们已经谈到上下文作为名称的一种*共享空间*。在编程术语中，我们通常说在一个区域中命名的事物占据一个单一的命名空间。命名空间可以被认为是一个地方，其中事物彼此共享一个概念区域。一些语言已经将命名空间的概念正式化为自己的语言构造（通常称为**包**，或者简单地称为命名空间）。即使没有这样的正式语言构造，JavaScript 仍然可以通过对象等分层构造来构建命名空间，如下所示：

```js
const app = {};
app.transactions = {};
app.transactions.dealMaking = {};
app.transactions.dealMaking.states = [
  'REJECTED_DEAL',
  'ACCEPTED_DEAL',
  'PENDING_DEAL',
  'STALLED_DEAL'
];
```

大多数程序员倾向于将命名空间视为一个非常正式的构造，但这并不经常是这种情况。通常，我们在编写函数时会在其中使用函数来组成暗示的命名空间，而不自知。在这种情况下，命名空间不是由对象层次结构的级别界定的，而是由我们函数的作用域界定的，如下所示：

```js
function makeFilteredRequest(endpoint, filterFn) {
  return fetch(`/${endpoint}/`)
    .then(response => response.json())
    .then(data => data.filter(filterFn);
}
```

在这里，我们通过`fetch`向一个端点发出请求，在返回之前，我们通过利用`fetch`返回的 promise 来收集所需的数据。为了做到这一点，我们使用了两个`then(...)`处理程序。

**Promise**是一个原生提供的类，为处理异步操作提供了有用的抽象。通常可以通过其 then 方法来识别 promise，就像我们在前面的代码中使用的那样。在利用异步操作时，通常会使用 promise 或回调。您可以在*异步控制流*部分的第十章中了解更多信息。

我们的第一个`then(...)`处理程序将其参数命名为*response*，而第二个处理程序将其参数命名为`data`。在`makeFilteredRequest`的上下文之外，这些术语将非常模糊。然而，因为我们在与制作过滤请求相关的函数的暗示命名空间内，术语*response*和*data*足以传达它们的概念。

我们的名称传达的概念，就像它们的目的一样，与它们指定的上下文密切相关，因此重要的是不仅要考虑名称本身，还要考虑其周围的一切：它所在的复杂逻辑和行为的错综复杂。所有代码都涉及一定程度的复杂性，对这种复杂性的概念理解对于能够掌握它至关重要。因此，在命名某物时，有助于问自己：*我希望他们如何理解这种复杂性？*如果您正在为其他程序员创建一个简单的接口，编写一个深度嵌入的硬件驱动程序，或者为非程序员创建一个 GUI，这是相关的。

# 合同

一个好的名称表示与周围抽象的其他部分的**合同**。通过其名称，变量可能指示它将如何使用或包含什么类型的值以及我们对其行为应有的一般期望。通常不会考虑，但是当我们命名某物时，实际上正在建立一系列隐含的期望或*合同*，这些期望或合同将定义人们如何理解和使用该物。以下是 JavaScript 中存在的隐含合同的一些示例：

+   以*is*开头的变量，例如`isUser`，预期是布尔类型（`true`或`false`）。

+   全大写的变量预期是一个常量（只设置一次且不可变），例如`DEFAULT_USER_EXPIRY`。

+   以复数命名的变量（例如 elements）预期包含一个或多个项目的集合对象（例如数组），而以单数命名的变量（例如 element）只预期包含一个项目（不在集合中）。

+   以`get`、`find`或`select`开头的函数通常预期会向您返回一些东西。以`process`、`build`或`run`开头的函数更加模糊，可能不会这样做。

+   属性或方法名称以下划线开头，例如`_processConfig`，通常意味着是内部实现或伪私有的。它们不打算公开调用。

不管我们喜欢与否，所有名称都携带着关于其值和行为的不可避免的期望。重要的是要意识到这些约定，以免意外违反其他程序员依赖的合同。当然，每个约定都会有例外，但尽管如此，我们应该尽量遵守它们。

不幸的是，并没有一个可以定义所有这些合同的规范列表。它们通常相当主观，并且将取决于代码库。尽管如此，在我们遇到这种约定的地方，我们应该遵循它们。正如我们在第二章中提到的，*《清洁代码的原则》*，确保熟悉性是增加代码可维护性的好方法。而确保熟悉性的最佳方法莫过于采用其他程序员已经采用的约定。

许多这些暗示的合同与类型有关，而 JavaScript，正如你可能知道的，是动态类型的。这意味着值的类型将在运行时确定，并且任何变量包含的类型可能会有所改变：

```js
var something;
something = 1;    // a number
something = true; // a boolean
something = [];   // an array
something = {};   // an object
```

变量可以引用许多不同的类型这一事实意味着我们采用的名称所暗示的合同和约定更加重要。没有静态类型检查器来帮助我们。我们只能在自己和其他程序员的混乱心情中独自面对。

在本章的后面，我们将讨论**匈牙利命名法**，这是一种在动态类型语言中有用的命名方式。另外，值得知道的是，对于 JavaScript，有各种静态类型检查和类型注释工具可用，如果你发现处理其动态性很痛苦。这将在第十五章中进行介绍，*更干净代码的工具*。

合同不仅因为 JavaScript 的动态类型而重要。它们在给予我们对某些值的行为以及在程序运行时可以从中期望什么方面上是基本有用的。想象一下，如果有一个名为`getCurrentValue()`的方法的 API 并不总是返回当前值。那将违反其暗示的合同。通过合同的视角看名字是一种很有意思的方式。很快，你将开始在各处看到合同 - 变量之间的合同，接口之间的合同，以及整个架构和系统之间的集成级别的合同。

现在我们已经讨论了一个好名称的三个特征（目的、概念、合同），我们可以开始探讨一些反模式，也就是我们应该尽量避免的命名方式。

# 命名反模式

与 DRY 和 YAGNI 的抽象构建警告类似，命名也有自己的警告和反模式。有许多组成糟糕名称的方式，几乎所有这些方式都可以分为三种广泛的命名反模式：**不必要的短名称**，**不必要的奇异名称**和**不必要的长名称**。

名称是我们和其他人将查看我们构建的抽象的初始镜头。因此，了解如何避免创建最终只会模糊理解并为其他程序员复杂化事情的镜头是至关重要的。让我们从探讨不必要的短名称开始，以及它们如何最终极大地限制我们理解某些事物的能力。

# 不必要的短名称

名称太短通常使用程序特定知识或领域特定知识，这些知识可能不适用于代码的受众。一个孤独的程序员可能认为写下以下代码是合理的：

```js
function incId(id, f) {
  for (let x = 0; x < ids.length; ++x) {
    if (ids[x].id === id && f(ids[x])) {
      ids[x].n++;
    }
  }
}
```

我们能够辨别出它与 ID 相关，并且其目的是有条件地增加`ids`数组中特定对象的`n`属性。因此，在功能层面上，我们可以辨别出它在做什么，但其含义和意图很难理解。程序员使用了单个字母的名称（`f`，`x`，`n`），并且还使用了缩写的函数名称（`incId`）。这些名称大多未能满足我们从名称中期望的基本特征：指示目的、概念和合同。我们只能通过它们的使用方式来猜测这些名称的目的和概念。用更有意义的名称重构将大大有助于这一点。

```js
function incrementJobInstancesByIdIfFilter(id, filter) {
  for (let i = 0; i < jobs.length; i++) {
    let job = jobs[i];
    if (job.id === id && filter(job)) {
      job.nInstances++;
    }
  }
}
```

现在我们对情况有了更清晰的了解。被迭代的数组包含作业。函数的目的是找到具有指定 ID 的作业，并且在该作业满足指定过滤器的条件下递增作业的`nInstances`属性。通过这些新名称，我们已经对这个抽象有了更丰富的概念理解。我们现在明白作业是可以有任意数量实例的项目，并且当前实例的数量通过`nInstances`属性进行跟踪。通过名称提供的视角，我们能够更清晰地理解底层问题领域。现在，我们可以看到名称不仅仅是装饰或不必要的冗长；名称是你抽象的本质。

不必要的短名称在很多方面只是一个意义不足的名称。然而，名称的短并不一定表示问题。我们在前面的代码中使用的迭代变量`i`是完全可以的，因为这是一个几十年来已经确立的惯例。世界各地的程序员都理解它的概念和约定义：它只用于遍历数组，并在每个迭代阶段访问数组元素。

总的来说，除了我们的迭代变量等极少数例外情况外，避免使用短名称带来的意义不足非常重要。它们通常是匆忙或懒惰地组成的，甚至可能会让程序员感到有所成就。毕竟，能够运用晦涩的逻辑是一种自我陶醉的礼物。但正如我们所讨论的，自我陶醉并不是清晰代码的朋友。每当你感到想要使用短名称的冲动时，抵制这种冲动，花时间选择一个更有意义的名称。

# 不必要的异国情调的名称

自我陶醉的另一个方面是异国情调的名称的泛滥。异国情调的名称是那些不必要地吸引注意力的名称，通常在意义上是模糊或难以理解的，比如：

```js
function deStylizeParameters(params) {
  disEntangleParams(params, p => !!p.style).obliterate();
}
```

这是一个表面上简单的行为，却因不必要的异国情调的名称而变得模糊。我们只需稍加努力，就可以大大提高这些抽象的可理解性：

```js
function removeStylingFromParams(params) {
  filterParams(params, param => !!param.style).remove();
}
```

总的来说，名称应该是无聊的。它们不应该吸引注意力。它们应该只展示它们的简单含义，而不会让其他程序员感到*哦，原来是这个意思！*或*哈哈，好聪明！*我们的自我可能对命名有自己的想法，但我们应该记住限制自我，纯粹考虑那些必须忍受尝试理解我们的代码和我们创建的接口的人。总的来说，以下建议将使我们走上正确的道路：

+   **避免使用普通词的花哨或更长的同义词**：例如，使用`kill`或`obliterate`而不是`delete`

+   **避免不存在的词**：例如，`deletify`，`elementize`或`dedupify`

+   **避免双关语或巧妙的暗示**：例如，使用化学元素名称来指代 DOM 元素

过度异国情调会冒险疏远我们的受众。你可能很容易理解你采用的名称，但这并不意味着其他人也能轻松理解。程序员社区非常多样化，有许多不同的文化和语言背景。最好坚持使用描述性和无聊的名称，以便你的代码能够被尽可能多的人理解。

# 不必要的冗长的名称

正如我们已经发现的，不必要的短名称实际上是没有足够意义的名称。因此，不必要的长名称是一个意义过多的名称。你可能会想一个名称怎么会有太多的意义。意义是好事，但是过多的意义压缩到一个名称中只会导致混淆；例如：

```js
documentManager.refreshAndSaveSignedAndNonPendingDocuments();
```

这个名称很难理解：它是在刷新和保存已签署和非挂起的文档，还是在刷新和保存既已签署又非挂起的文档？不清楚。

这个长名称给了我们一个线索，表明底层抽象是不必要地复杂。我们可以将名称分解为其组成部分，以充分了解其接口：

+   **refresh (verb)**：文档上发生的刷新动作

+   **save (verb)**：文档上发生的保存动作

+   **signed (adjective)**：文档的已签署状态

+   **non-pending (adjective)**：文档的非挂起状态

+   **document (noun)**：文档本身

在这里我们有一些不同的事情发生。对于这么长的名称，一个很好的指导原则是重构底层抽象，以便我们只需要一个最多包含一个动词，一个形容词和一个名词的名称。例如，我们可以将我们的长名称拆分为四个不同的函数：

```js
documentManager.refreshSignedDocuments();
documentManager.refreshNonPendingDocuments();
documentManager.saveSignedDocuments();
documentManager.saveNonPendingDocuments();
```

或者，如果意图是对携带多种状态（`SIGNED`和`NON_PENDING`）的文档执行操作，那么我们可以为刷新实现这样的方法（保存动作也可以类似）：

```js
documentManager.refreshDocumentsWithStates([
  documentManager.STATE_SIGNED,
  documentManager.STATE_NON_PENDING
]);
```

关键是，长名称是一个破碎或混乱抽象的线索。使名称更易理解通常与使抽象更易理解相辅相成。

与短名称一样，问题不在于名称本身的长度：而是长度通常所指的含义。长名称所指的是将太多的含义压缩到一个名称中，表明了混乱的抽象。

# 一致性和层次结构

到目前为止，我们已经谈到了名称的三个最重要的特征：*目的*，*概念*和*合同*。赋予名称这些特征的最简单的方法之一是利用一致性和层次结构。这里的一致性是指在代码的给定区域内使用相同的命名模式。另一方面，层次结构是指我们构建和组合不同代码区域以形成整体架构的方式。它们共同使我们能够为名称提供丰富的上下文，可以用来对其目的，概念和合同进行强有力的推断。

这最好通过查看虚构应用程序的 JavaScript 目录来解释。我们有一个满是文件的目录，如下所示：

```js
app/
|-- deepClone.js
|-- deepEquality.js
|-- getParamsFromURL.js
|-- getURL.js
|-- openModal.js
|-- openModalWithTemplate.js
|-- setupAppWithCustomConfig.js
|-- setupAppWithDefaultConfig.js
|-- setURL.js
|-- ...
```

没有层次结构，因此我们只能从名称本身和它们似乎相关的内容中推断上下文。例如，有一个`getURL`和一个`setURL`文件，它们都可能与 URL 相关，并且可以被视为*实用程序*。因此，将这些占据相同层次结构的部分或共享命名空间，例如`app/utils/url`，将是有帮助的。我们还可以将目录结构的其他部分重构为更具上下文丰富的层次结构：

```js
app/
|-- setup/
|   |-- defaultConfig.js
|   |-- setup.js
|-- modal/
|   |-- open.js
|   |-- openWithTemplate.js
|-- utils/
    |-- url/
    |   |-- getParams.js
    |   |-- get.js
    |   |-- set.js
    |-- obj/
        |-- deepEquality.js
        |-- deepClone.js
```

立即，事情变得更清晰。理解所有这些文件及其功能的认知负担现在因每个文件都有其丰富的上下文而减轻了。您还会注意到，我们已经能够简化层次结构的各个部分的名称；例如，我们已将`openModal.js`重命名为`modal/open.js`。这是使用名称层次结构的额外好处：在每个命名级别，我们可以简化和缩短名称，减少理解时间。

层次结构内的名称自然地从其所在的上下文中获得一部分含义。这意味着名称本身不需要包含所有含义。始终寻找机会为类似的抽象提供共同的上下文，以减轻理解的负担。

就像我们通过目录结构的层次结构提供了含义一样，我们也可以在代码本身中提供含义。例如，在一个函数内部，名称自然会从函数的名称本身和它在更大模块中的情境中获得很多上下文。想象一下，如果写出这样的代码会很不寻常：

```js
function displayModalWithMessage(
  modalDisplayer_Message,
  modalDisplayer_Options
) {
  const modalDisplayer_ModalInstance = new Modal();
  modalDisplayer_ModalInstance.setMessage(modalDisplayerMessage);
  modalDisplayer_ModalInstance.setOptions(modalDisplayerOptions);
  modalDisplayer_ModalInstance.show();
  return modalDisplayer_ModalInstance;
}
```

函数内部的名称不必要地加上了上下文信息（比如`modalDisplayer_...`），而代码的读者已经可以从函数本身获取这些信息。通常，我们编写的代码会利用变量所处的位置以及从上下文中获得的含义。前面的代码更正常的写法应该是这样的：

```js
function showModalWithMessage(message, options) {
  const modalInstance = new Modal();
  modalInstance.setMessage(message);
  modalInstance.setOptions(options);
  modalInstance.show();
  return modalInstance;
}
```

在之前的一章中，我们讨论了抽象原则以及模块的实现应该独立于其接口。我们可以看到这个原则在这个函数中得到了体现。函数的范围（其实现）应该完全独立（甚至无知！）于其接口。因此，可以说，`modalInstance`变量不需要知道它位于哪个函数中，因此前缀为`modalDisplayer_...`的命名技术将违反抽象原则。

考虑到抽象的层次结构是关键。层次结构不仅仅在组织上有用。它们应该理想地反映出我们代码中存在的抽象层次。更高级的抽象位于层次结构的顶部，我们进入层次结构的深处，就会变得更低级。这是一个很好的一般规则：**让你的层次结构反映你的抽象**。

命名事物时要保持一致性，这符合这个规则。在我们的抽象的一个层次内，也就是在层次结构的一个层级内，我们应该采用常见的命名模式，这样我们代码的读者就可以轻松地浏览和理解其中的概念。例如，如果我们正在创建一个用于向数据结构添加和删除项目的接口，那么我们应该避免以不一致的方式命名类似的操作。考虑以下类的示意图：

```js
class MyDataStructure {
  addItem() {}
  pushItems() {}
  setItemIfNotExists() {}
  // ...
}
```

非常令人困惑的是，这个抽象提供了三种不同的*添加*概念的变体：*添加*、*推送*和*设置*。实际上，这些名称都指的是同一个概念，所以我们应该采用一个常见的命名模式，比如以下方式：

```js
class MyDataStructure {
  addItem() {}
  addItems() {}
  addItemIfNotExists() {}
  // ...
}
```

这个接口现在更容易理解了。使用起来更加清晰，认知负担更小。作为这个抽象的用户，我不再需要记住我应该使用*add*、*set*还是*push*。一致性是通过避免不必要的差异而产生的特征。不一致会让人感到不适，因此它们只应该用于标示真正的功能或概念差异。

# 技术和考虑因素

由于 JavaScript 的不断变化，它积累了大量相互冲突的约定。其中许多约定在支持或反对方面都引起了强烈的意见。然而，我们已经就一些基本的命名约定达成了一致，这些约定或多或少地得到了全球范围内的接受：

+   常量应该用下划线分隔的大写字母命名；例如，`DEFAULT_COMPONENT_COLOR`

+   构造函数或类应该采用驼峰命名法，首字母大写；例如，`MyComponent`

+   其他所有内容都应该采用驼峰命名法，首字母小写；例如，`myComponentInstance`

除了这些基本约定之外，命名的决定很大程度上取决于程序员的创造力和技能。你最终使用的名称将在很大程度上由你解决的问题所定义。大多数代码将继承与其接口的 API 的命名约定。例如，使用 DOM API 通常意味着你采用诸如*element*、*attribute*和*node*之类的名称。许多流行的可用框架也会倾向于规定我们采用的名称。从你所在的生态系统中采用这样的常规范式是非常有用和必要的，但同时拥有一些基本的技术和概念也是很有用的，这样你就可以在新的和陌生的问题领域中构建出命名得体的抽象。

# 匈牙利命名法

JavaScript 是一种动态类型语言，这意味着值的类型将在运行时确定，并且任何变量包含的类型可能在运行时发生变化。这与静态类型语言相反，后者在编译时会警告你关于类型的使用。这意味着，作为 JavaScript 程序员，我们需要在使用类型和命名变量的方式上更加小心。

众所周知，当我们命名事物时，我们是在暗示一个约定。这个约定将定义其他程序员如何使用该事物。这就是为什么在各种语言中，匈牙利命名法非常流行的部分原因。它涉及在名称本身中包含类型注释，就像这样：

+   我们可以使用`elButton`或`buttonElement`，而不是`button`

+   我们可以使用`nAge`或`ageNumber`，而不是`age`

+   我们可以使用`objDetails`或`detailsObject`，而不是`details`

匈牙利命名法有以下几个原因：

+   确定性：它为您的代码读者提供了更多关于名称目的和约定的确定性

+   **一致性**：它会导致更一致的命名方式

+   强制执行：它可能导致代码内更好地执行类型约定

然而，它也有以下缺点：

+   **运行时更改**：如果底层类型在运行时被糟糕的代码更改（例如，如果函数将`nAge`变成字符串），那么该名称将不再有用，甚至可能误导我们。

+   **代码库的僵化**：它可能导致代码库变得僵化，难以对类型进行适当的更改。重构旧代码可能变得更加繁重。

+   **缺乏含义**：仅知道变量的类型并不能告诉我们它的目的、概念或约定，就像一个真正描述性的非类型变量名那样。

在 JavaScript 的领域中，我们看到匈牙利命名法在一些地方被使用：最常见的是在命名可能指向 DOM 元素的变量时。这些名称的标注通常以`elHeader`、`headerEl`、`headingElement`或者`$header`的形式出现。以美元符号为前缀的后者最著名地用在 jQuery 库中。它在那里的名声导致它成为各种其他地方的标准。例如，**Chromium DevTools**在元素引用和与查询 DOM 相关的方法中使用了美元前缀（例如，`$$(...)`被别名为`document.querySelectorAll(...)`）。

匈牙利命名法是一种可以部分利用的东西，当你担心可能存在歧义时。例如，你可以在一个作用域内同时引用复杂类型和原始类型来使用它：

```js
function renderArticle(name) {
  const article = Article.getByName(name);
  const title = article.getTitle();
  const strArticle = article.toString();
  // ...
}
```

在这里，我们有一个指向`Article`类实例的`article`变量。除此之外，我们还想使用我们文章的字符串表示。为了避免潜在的命名冲突，我们使用了一个`str`前缀来表示该变量是指向一个字符串值。在这样的孤立情况下，匈牙利命名法是有用的。你不需要完全使用它，但它是一个有用的工具。

# 命名和抽象函数

在 JavaScript 中，大多数抽象最终都会体现在函数中。即使在大型架构中，也是单个函数和方法在工作，而且在它们的构思中，一个好的抽象开始显现出来。因此，值得深入思考我们应该如何命名我们的函数以及在这样做时应该考虑哪些因素。

函数的名称通常应该使用语法中所谓的**命令形式**。当我们给出指示时，就是我们使用的命令形式，比如*走到商店*，*买面包*，*停在那里*。

尽管我们通常在命名函数时使用*命令*形式，但也有例外。例如，惯例上也会在返回布尔值的函数前加上*is*或*has*；例如，`isValid(...)`。在创建构造函数（它们也是函数）时，我们会根据它们将生成的实例来命名；例如，`Route`或`SpecialComponent`。

在编程环境中，命令形式的直接性是最容易理解和阅读的。要找到特定问题的正确命令形式，最好想象一下发布军事命令的过程，也就是说，不要拐弯抹角，准确地说明你想要发生的事情：

+   如果你想显示提示，使用`displayPrompt()`

+   如果你想要移除元素，使用`removeElements()`

+   如果你想要一个在`x`和`y`之间的随机数，使用`generateRandomNumber(x, y)`

通常，我们希望对我们的指示进行限定。如果你要给一个人下达指示，比如*找到我的自行车*，你可能会进一步限定这个指示，比如*它是蓝色的*和*它的前轮丢了*。然而，重要的是不要让函数的名称被这些限定所拖累。以下函数就是一个例子：

```js
findBlueBicycleWithAMissingFrontWheel();
```

正如我们之前提到的，一个不必要地长的名称是一个糟糕抽象的标志。当我们看到这种过度限定的情况时，我们应该退一步重新考虑。在这里，重要的是要在口语和编程语言中划清界限。在编程中，函数是抽象常见行为的方式，可以通过参数根据需要进行调整或配置。

因此，我们应该通过参数来表达`蓝色`和`丢失前轮`的限定。例如，我们可以将它们表达为一个单一的对象参数，如下所示：

```js
findBicycle({
  color: 'blue',
  frontWheel: 'missing'
});
```

通过将函数名称的限定部分移到其参数中，我们正在产生一个更清晰和更易理解的抽象。这不仅增加了抽象的可配置性，还为用户提供了更多的可能性。

在我们的情况下，我们可能希望让用户能够找到除自行车以外的其他对象。为了满足这一点，我们会使函数的名称更加通用（例如，`findObject`），并通过添加一个新的选项属性（例如，`type`）将限定部分移到参数中，如下所示：

```js
findObject({
  type: 'bicycle',
  color: 'blue',
  frontWheel: 'missing'
});
```

在这个过程的阶段，发生了一些奇怪的事情。我们已经正确地将各种限定词移到函数的参数中，扩展了我们抽象的有用性和配置。但现在我们得到的是一个做很多事情的抽象，因此在某个时候，退一步构建更高级别的抽象来封装这些不同的行为可能是明智的。在我们的情况下，我们可以通过函数组合来实现这一点，如下所示：

```js
const findBicycle    = config => findObject({ ...config, type: 'bicycle' });
const findSkateboard = config => findObject({ ...config, type: 'skateboard' });
const findScooter    = config => findObject({ ...config, type: 'scooter' });
```

首先，函数是行为的一个单元。正如 SRP 告诉我们的那样，确保它们只做一件可辨认的事情非常重要。在考虑这些事情或行为单元时，重要的是要从将使用它的人的角度考虑函数的作用。从技术上讲，我们组合的`findScooter`函数很可能在表面之下做了各种事情。它可能非常复杂。但在它将被使用的抽象层面上，可以说它只做了一件事，这才是重要的。

# 三个糟糕的名字

如果你对名字感到困惑，有一个聪明的方法可以帮助你摆脱困境。当你有一个需要命名的抽象或变量时，仔细看看它的功能或包含的内容，然后想出至少三个描述它的糟糕名字。现在不要担心你希望提供的抽象或接口；只是想象你在向一个对代码库一无所知的人描述功能。直接而描述性。

例如，假设我们嵌入在处理设置新用户名的代码库的部分。我们需要检查用户名是否与一组特定的禁止单词匹配，比如`admin`、`root`或`user`。我们想写一个函数来做这个，但我们不确定该选什么名字。因此，我们决定尝试三个糟糕的名字的方法。这是我们想出的名字：

+   `matchUsernameAgainstForbiddenWords`

+   `checkForForbiddenWordConflicts`

+   `isUsernameReservedWord`

想出三个不太完美的名字要比花很多时间试图找到完美的名字容易得多。这三个名字有多糟糕并不重要。重要的是我们至少能想出三个。现在，我们已经有了一系列可能性，我们可以自由地比较和对比我们找到的名字，并混合它们以找到最具描述性和直接表达我们函数目的的方式。在这种情况下，我们可能最终决定采用从这三个可能性中改编的名字：`isUsernameForbiddenWord`。如果不是因为采用了三个糟糕的名字的方法，我们就不会得到这个名字。

# 总结

在本章中，我们已经探讨了命名的艰难艺术。我们讨论了一个好名字的特征，即目的、概念和约定。我们通过示例讲解了如何将这些特征编织到我们的名字中，以及要避免的反模式。我们还讨论了在追求清晰抽象时层次结构和一致性的重要性。最后，我们介绍了一些有用的技术和惯例，当我们在命名事物时遇到困难时可以利用。

在下一章中，我们将终于开始深入了解 JavaScript 语言本身，并学习如何以一种能产生真正清晰代码的方式运用它的构造和语法。
