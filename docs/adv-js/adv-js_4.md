# 第四章：测试 JavaScript

## 学习目标

在本章结束时，您将能够做到以下几点：

+   分析测试的好处

+   解释代码测试的各种形式

+   构建代码测试环境

+   为您的 JavaScript 代码实施测试

本章将涵盖测试的概念、测试框架以及如何有效地测试代码的不同方式。

## 介绍

在第一章中，我们介绍了 ES6 中发布的许多新功能和强大功能。我们讨论了 JavaScript 的发展历程，并突出了 ES6 中的关键添加。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强的对象属性、解构赋值、类和模块、转译以及迭代器和生成器。在第二章中，我们讨论了 JavaScript 的异步编程范式。我们讨论了 JavaScript 事件循环、回调、承诺和 async/await 语法。在第三章中，我们学习了文档对象模型（DOM）、JavaScript 事件对象和 jQuery 库。

在本章中，我们将学习有关 JavaScript 中测试代码和代码测试框架的知识。在第一个主题中，我们将介绍测试并讨论测试驱动开发。然后，我们将讨论应用测试驱动开发以及您可以测试代码和应用程序的几种不同方式。在最后一个主题中，我们将讨论几种 JavaScript 代码测试框架，您可以使用它们来为您的代码构建强大的测试。

## 测试

测试代码很像去健身房。你知道这对你有好处。所有的论点都说得通，但起身并开始健身之路是困难的。最初的冲动感觉很棒；然而，紧随其后的是酸痛的肌肉，你开始怀疑这是否真的值得。你花了一个小时甚至更多的时间，但你所能展示的只是酸痛的手臂和腿。但是，几周后，情况变得更容易。你开始注意到锻炼的好处。

就像去健身房一样，您可能已经听说过测试代码有多么重要。编写测试是编写良好和可持续代码的一个重要部分。当您开始编写测试时可能会感到困难。编写您的第一个测试并使其成功运行会带来一种兴奋感，但在工作日中花费一个小时来编写测试后的一两天后，您开始怀疑这是否真的值得。但您坚持下去。几周后，这变得不那么乏味，您开始注意到测试代码带来的一些小好处。

在本章中，我们将讨论测试代码的原因，您可能需要实施的测试类型，以及您可能使用的一些 JavaScript 框架来实施和运行测试。

### 测试代码的原因

测试代码有许多原因。这些原因包括程序正确性、敏捷开发、代码质量、错误捕捉、法律责任、满足感等等。我们将简要讨论列出的每个原因，并解释它们的好处。

1.  **正确性**

测试代码的最简单和最重要的原因是测试代码检查代码的正确性。智能编写的测试将针对预定的输入值和相应的输出值测试代码中的所有逻辑。通过将程序的输出与预期输出进行比较，我们可以验证代码是否按预期工作，捕捉语义或语法错误，然后将其集成到代码中。

1.  **敏捷开发**

测试代码使开发过程更加敏捷。**敏捷开发周期**是最受欢迎和最热门的开发风格之一，被包括洛克希德·马丁、Snapchat 和谷歌在内的软件公司采用。敏捷开发依赖于短期目标。更改旧的经过测试的代码是一个非常缓慢的过程。如果需要重构或添加或删除功能的任何旧代码，我们需要重新测试整个过程。有了编写的代码测试，我们可以自动化它们，加快测试过程，并节省大量时间。这可能是实现我们的敏捷冲刺目标和错过截止日期之间的区别。

#### 注意：

敏捷开发周期专注于短期冲刺，设计、实施和发布新功能。这些冲刺通常为两到三周。这种短期和快速的开发策略使您能够将一个大型产品分解成较小的部分，并管理潜在的变化需求。

1.  **捕获错误**

测试代码将使您能够在开发周期的早期发现错误。测试应该在集成到产品或模块之前进行。这意味着测试发现的任何错误将在集成到产品之前被发现和修复。调试已完全集成到应用程序中的模块比调试仍在开发中的模块要困难得多。在集成之前编写和运行测试将使您能够在它们与其他代码交互之前找到并修复这些错误，节省大量时间。在集成之前捕获错误并推送正确的工作代码是开发人员可以拥有的最重要的技能之一，代码测试可以极大地提高这一技能。

1.  **代码质量**

代码测试提高了编写代码的质量。在编写带有测试的代码时，我们必须明确地考虑这些测试来设计和实施我们的代码。编写良好的测试有助于我们更全面地思考我们试图解决的问题以及我们将要解决问题的方式；我们必须考虑诸如边缘情况之类的事情，并设计一个满足测试要求的良好实现。编写测试将帮助您更好地理解代码的设计和实现，从而产生更高质量、更深思熟虑的代码。

1.  法律责任

编写测试可以帮助预防和减轻法律责任。在许多司法管辖区和市场领域，供应商被要求确保或证明所提供的软件具有市场质量。有记录的测试过程有可能在某些情况下限制您的法律责任。这可能会防止您因软件漏洞而被起诉。在最糟糕的情况下，充分记录的测试过程也可以用来证明诉讼中涉及的软件漏洞并非出于过失。这可能会减少您的惩罚性赔偿或个人责任。

1.  **满足感**

测试代码的最终原因经常被大多数人忽视。测试代码可以非常令人满意。测试可以立即给您关于代码正确性的视觉反馈。看到所有方面都有绿色的勾号是非常令人满意的。发布您知道写得很好、经过充分测试并且将会无故障运行的代码是非常令人满意的。知道您的代码经过了充分测试可以帮助您在截止日期到来时对发布感到自信。

### 测试驱动开发

**测试驱动开发**（**TDD**）是一种以编写测试为重点的软件开发形式，先于实现代码。它通常是敏捷开发周期的一部分，也是将测试整合到代码中的最简单方式之一。TDD 是围绕短而简单的开发周期构建的软件开发过程。在其最基本的形式中，该周期包括添加一个定义新功能应如何工作的测试，然后编写代码直到满足测试的要求。这个周期重复进行，直到所有功能都被添加。

测试驱动开发要求开发人员创建自动化测试。这些测试应该清楚地定义代码的要求，并且应该在编写任何代码之前定义。测试应该覆盖所有预期或潜在的用例，特别是边界情况。测试的通过将通知开发人员开发何时完成。

#### 注意：

边界情况是发生在操作参数的极端情况。在代码中，边界情况指的是可能需要特殊处理的有效输入值。例如，斐波那契数列算法（F(n)=F(n-1)+F(n-2)）在序列值为 0 或 1 时需要特殊处理。

TDD 允许开发人员在必要时将其代码分解为小而可管理的步骤。这是可能的，因为 TDD 要求每个添加的函数和功能都必须有测试。我们可以编写一个小测试，然后编写使该测试通过的代码。大型功能和函数可以分解为小部分，并逐步构建。这可以极大地帮助理解问题的所有部分。

TDD 还可以促进更模块化和可重用的代码。每一部分代码都必须经过测试，大段的代码可以分解为小部分。这可以导致更小、更专注的类和函数，以及代码文件之间更少的交叉依赖。这些小部分可以被包装在一个带有它们的测试的模块中，并通过程序共享。对模块的更新可以通过运行附加的测试套件来简单地验证其正确性。

### TDD 周期

TDD 周期通常是一个六个步骤的序列：

1.  **添加测试：**在 TDD 中，每个新功能都应该以编写测试开始。要编写新测试，必须清楚地理解功能的规格和要求。功能的要求必须经过深思熟虑，并分解成可以逐一编写为测试的可测试部分。

1.  **运行所有测试并查看是否有失败：**为了检查新测试是否通过，测试显然应该失败，因为我们正在添加的功能尚未实现。如果测试没有失败，那么该功能已经存在，或者测试编写错误。这是对编写的测试进行理智检查。测试应该为预期目的而失败，并有助于检查所测试的逻辑是否正确。

1.  **编写代码修复测试：**在这个阶段，代码不需要完美。测试可能以低效的方式修复，但这是可以接受的，因为它可以在后续的过程中进行重构。

1.  **运行测试并确保它们通过：**测试应该全部通过，包括之前添加的所有测试。如果新代码破坏了之前通过的测试，可以撤销更改以找出可能的破坏性变化。

1.  **重构/清理代码：**如果需要进行任何代码清理，可以在这一步完成。在这里，您可以改进新添加的代码的实现，或者修复在添加新代码时可能已经破坏的任何测试。在任何重构之后，应该再次运行测试以确保所有更改都是正确的。根据需要重复重构和运行测试步骤，直到重构正确为止。

1.  **重复：**添加一个新的测试，并重复 TDD 周期，直到功能已经完全实现和测试。

测试驱动开发是确保所有代码都经过测试的强大方法，但如果开发人员不够谨慎，它可能会导致几个陷阱。当需要完整堆栈或功能测试时，TDD 可能很难使用。完整堆栈或功能测试是一次对技术堆栈的多个部分进行测试。需要用户界面元素、数据库调用或网络调用的测试可能非常难编写。通常情况下，代码中测试的外部世界交互可以通过使用模拟数据或网络调用来欺骗。

如果测试不经常运行或维护不当，TDD 也可能会开始崩溃。如果测试被放弃并且从不运行，或者只是偶尔运行，TDD 的整个目的就会崩溃。添加到程序中的功能是根据测试设计的，并且测试用于验证功能是否被正确实现。如果测试从未运行，TDD 的整个目的就被忽视了。维护不当的测试也会阻止 TDD 的有效性。维护不当可能是因为没有更新以满足调整后的功能要求，或者没有添加概述新功能要求的新测试。维护不当的测试将无法正确地告诉您编写的代码是否按照我们想要的方式执行。

TDD 也可能会受到测试编写不当或懒散的影响。如果测试太粗糙，它们将无法找到代码中的错误。测试必须具有足够的特异性，以独立地测试每一点逻辑，而不受其他逻辑的影响。另一方面，如果添加了琐碎的测试，我们会在 TDD 敏捷过程中浪费时间。如果编写了琐碎的测试或重复了以前的测试，我们将降低开发效率。

最后，如果团队中的任何成员不采用开发策略，TDD 可能会崩溃。如果只有部分开发团队在添加新代码之前编写测试，我们只能测试和验证代码库的一小部分。为了使 TDD 取得最佳结果，所有开发团队成员都必须完全采用它。

### 结论

测试代码是确保代码按预期方式运行的最佳方法。如果您目前不测试代码，要开始实施测试可能会非常困难；然而，这是必须要做的。测试代码可以使您的代码更正确、更容易编写和更高质量。

测试驱动开发是在项目中开始集成测试的最简单方法之一。TDD 围绕着在编写任何实现代码之前添加概述任何功能或函数要求的测试。它迫使开发人员准确了解每个功能将如何实现。TDD 是一个简单的六步过程：添加测试，运行测试，编写代码，运行测试，重构，重复。这个过程确保了每个功能的小部分都得到了测试。

### 练习 24：应用测试驱动开发

你被要求编写一个斐波那契数生成器。使用测试驱动开发周期编写测试并开发斐波那契算法。您可以参考*第一章：介绍 ECMAScript 6*中的斐波那契代码，进行修改。您应该为`n=0`条件编写测试，然后实现`n=0`条件，然后为`n=1`条件编写测试并实现，然后为`n=2`条件编写测试并实现，最后为`n=5`、`n=7`和`n=9`条件编写测试并实现。如果测试通过，则记录`测试通过`。否则，抛出错误。

使用 TDD 开发和测试算法，执行以下步骤：

1.  手工计算斐波那契数列在 n=0，n=1，n=2，n=5，n=7 和 n=9 时的值。

1.  编写一个名为`fibonacci`的函数，该函数以变量`i`作为输入，递归计算斐波那契数列的值，并检查`i<=0`。

如果是，返回`1`，然后检查`if i==1`。

如果是，则返回`1`。否则，它会递归获取斐波那契值。

然后返回`fibonacci(i-1) + fibonacci(i-2)`。

1.  编写一个名为`test`的通用测试函数，它接受两个参数：计算出的值（`value`）和预期值（`expected`）。

1.  检查两个值是否不同。如果它们不同，则抛出错误。

1.  如果两个值相同，请打印`测试通过`消息。

1.  对于每个要测试的条件（在步骤 1 中计算，n=0，n=1，n=2，n=5，n=7 和 n=9），使用`test`函数编写测试条件的测试。

1.  调用`test`函数，并传入从`fibonacci`函数返回的值和手动计算的值。

1.  运行测试。

1.  如果测试失败，请修复`fibonacci`函数中的错误。

1.  修复错误后再次运行测试。

1.  如果测试通过，请继续下一个测试条件。

1.  如果测试失败，请修复错误并重新运行测试。

**代码**

##### index.js

```php
function fibonacci( i ) {
 if ( i <= 0 ) {
   return 0;
 } else if ( i === 1 ) {
   return 1;
 } else {
   return fibonacci( i - 1 ) + fibonacci( i - 2 );
 }
}
function test( value, expected ) {
 if ( value !== expected ) {
   throw new Error( 'Value did not match expected value' );
 } else {
   console.log( 'Test passed.' );
 }
}
test( fibonacci( 0 ), 0 );
test( fibonacci( 1 ), 1 );
test( fibonacci( 2 ), 1 );
test( fibonacci( 5 ), 5 );
test( fibonacci( 7 ), 13 );
test( fibonacci( 9 ), 34 );
```

https://bit.ly/2H5CNv0

###### 代码片段 4.1：测试代码

**输出**

![图 4.1：斐波那契测试](img/Figure_4.1.jpg)

###### 图 4.1：斐波那契测试

您已成功应用测试驱动开发来开发和测试算法。

## 测试类型

软件测试有许多不同的形式。在本节中，我们将讨论测试代码的不同方法，并涵盖最常见的代码测试类型。

### 黑盒和白盒测试

测试代码有两种方法，黑盒和白盒。术语**黑盒**表示内部工作原理未知的系统。观察系统的唯一方法是通过其输入和输出。**白盒**系统是已知内部工作原理的系统。可以通过其输入、输出和确切的内部工作原理来观察。黑盒和白盒系统可以是任何东西，从软件程序到机械设备或任何其他系统。

**黑盒测试**是指在测试软件时，测试人员不知道代码的内部结构或实现。我们只能观察代码系统的输入和输出。**白盒测试**是指在测试软件时，测试人员知道代码的内部结构或实现。我们能够观察输入和输出，并确切地了解程序每一步的内部状态如何改变。几乎所有形式的代码测试都基于黑盒或白盒测试原则。以下图示显示了黑盒与白盒的对比：

![图 4.2：黑盒和白盒可视化](img/Figure_4.2.jpg)

###### 图 4.2：黑盒和白盒可视化

我们将讨论三种类型的测试：**单元测试**，**功能测试**和**集成测试**。单元测试旨在验证所有可测试代码的预期目的。它们测试最小的逻辑片段，以确保实现的正确性。功能测试旨在确认功能或组件的功能。集成测试旨在测试集成的组件，以验证它们在集成系统中一起按预期工作。这三种代码测试为您提供了一个良好的基础，可以从中进行代码测试。

### 单元测试

**单元测试**是最常见的测试形式之一。单元测试用于确保函数的特定功能部分已满足要求。单元测试通常从白盒测试的角度构建，我们将在本章中讨论单元测试，假设已知代码的内部功能。虽然单元测试可以从黑盒的角度构建，但这更接近功能测试，并将在下一节中更多地讨论。

单元测试只是测试尽可能小的代码单元的测试。代码的“单元”是一个与代码的其他部分逻辑上隔离的小片段。换句话说，它是一段不依赖于代码其他部分的逻辑的代码。代码单元可以更新而不影响其周围代码的功能。例如，考虑以下代码片段中显示的代码：

```php
function adjustValue( value ) {
 if ( value > 5 ) {
   value--;
 } else if ( value < -5 ) {
   value++;
 }
 return value
}
```

###### 片段 4.2：代码单元示例

函数`adjustValue()`接受一个数字。如果数字大于 5，则从数字中减去 1，如果值小于-5，则向数字中添加 1。我们可以将这段代码分解为三个逻辑单元，如下所示：

1.  第一个单元是检查值是否大于 5 的`if`语句和减量运算符（`value--`）。

1.  第二个单元是`else if`语句，检查值是否小于-5，并且增量运算符（`value++`）。

1.  第三个逻辑单元是`return`语句。更改这三个逻辑单元中的任何一个都不会影响其周围代码的逻辑结构。

我们可以为每个单元创建一个单元测试，以确保它们的功能正确。我们的单元测试应该一次只测试一个代码单元。对于这个例子，我们将需要 3 个单元测试。我们将构建测试来检查返回值、大于 5 的条件和小于-5 的条件。要测试返回条件，我们只需要传入一个小于或等于 5 且大于或等于-5 的值。返回的值应该与传入函数的值相同。要测试大于 5 的条件，我们必须传入一个大于 5 的值。我们知道返回的值必须比输入的值低 1。要测试小于条件，我们必须传入一个小于-5 的值。我们知道返回的值应该比输入的值高 1。这三个单元测试可以放入一个代码文件中，并在对代码进行修改后运行。

单元测试应尽可能频繁地运行。单元测试应该放入文件中，并在任何代码逻辑发生变化时运行。代码片段逻辑的微小变化可能导致结果的重大变化。持续测试将有助于确保没有小错误悄然产生。许多公司都有自动化测试系统，将在 Git 存储库提交或版本发布时自动运行单元测试。这种自动化测试对于帮助追踪破坏代码的提交和更改非常有用。这可以大大减少调试时间和精力。

### 练习 25：构建单元测试

你被要求为一段代码构建单元测试。要完成这个任务，请按照以下说明进行操作：

1.  参考`exercises/exercise25/exercise.js`中提供的文件，并查看名为`fakeRounding`的函数。我们将为这个函数构建单元测试。

1.  在文件中，编写一个名为`test`的通用测试函数，该函数接受两个参数：计算出的值（`value`）和预期值（`expected`）。检查这两个值是否不同。如果它们不同，就抛出一个错误。

如果这两个值相同，就打印测试通过的消息。如果愿意，可以使用*练习 24*中的`test`函数。

1.  参考`fakeRounding`函数，逐行分析函数对输入和输出的影响。

它获取传入数字的绝对值的小数部分。如果小数<=0.5，则返回最接近整数的输入。接下来，如果小数>0.5，则返回最接近整数的输入向下取整。

1.  使用我们创建的`test`函数编写测试，检查以下情况。从提供的输入计算预期值。

为多个输入编写测试，0、0.4999、0.5、0.5001、-0.4999、-0.5 和-0.5001：

**代码：**

##### **solution.js**

```php
test( fakeRounding( 0 ), 0 );
test( fakeRounding( 0.4999 ), 1 );
test( fakeRounding( 0.5 ), 1 );
test( fakeRounding( 0.5001 ), 0 );
test( fakeRounding( -0.4999 ), 0 );
test( fakeRounding( -0.5 ), 0 );
test( fakeRounding( -0.5001 ), -1 );
```

###### 片段 4.3：单元测试

https://bit.ly/2Fjulqw

**输出：**

![图 4.3：单元测试](img/Figure_4.3.jpg)

###### 图 4.3：单元测试

您已经成功为一段代码构建了单元测试。

### 功能测试

**功能测试**是一种黑盒测试方法，用于确定应用程序的组件是否按照定义的规范工作。功能测试通常比单元测试更复杂。单元测试测试组件内部函数的逻辑，而功能测试旨在测试组件是否符合规范表或数据表中定义的规范。例如，如果我们在网页上有一个只接受数字的表单，我们可能会使用数字和字符串进行功能测试，以确保正确满足仅接受数字的规范。

功能测试可以分为五个步骤：

1.  确定功能

1.  创建输入数据

1.  确定输出数据

1.  比较输入和输出

1.  修复错误

构建功能测试的第一步是确定需要测试的功能。功能测试通常测试主要功能、错误条件、可用性等。通常最容易确定需要构建的测试是通过查看特性/组件规范或数据表来确定的。您可以从数据表中获取组件的所需程序行为和错误处理，并将其分解为一系列测试。

一旦确定了需要测试的功能以及如何测试该功能，您必须创建输入数据进行测试。测试所需的输入数据严重依赖于正在构建的组件或特性，因此很难为教科书的目的进行概括。但是，您应该使用您期望程序接受的值和可能对程序来说意外的值进行测试。例如，如果我们正在创建一个电子邮件输入表单，我们应该使用有效的电子邮件（`xxxx@yyy.zzz`）和无效的电子邮件（`12344312`）来测试输入字段。在生成任意测试数据时，通常最好使用数组、字符串或其他数据结构中的非顺序值进行测试。使用随机值可以帮助您发现逻辑错误。

确定测试所需的输入数据后，您必须确定特性的预期输出。这个过程的这一部分可以说是最重要的，不应该草率对待。输出值绝对不能通过将输入通过正在测试的程序来计算。这将导致在运行测试时出现重言，不会发现任何错误。我曾经看到许多测试失败，因为程序员没有正确计算预期的输出值，测试无效。

一旦确定了输出值，我们就可以运行我们的测试了。输入值应该通过特性或组件，并与输出值进行比较。如果组件的输出值与前一步计算的预期输出值相匹配，则测试通过。如果值不匹配，则测试未通过，需要修复错误。

该过程的最后一步是修复错误。如果测试未通过，则组件中存在错误。修复错误后，可以重新运行测试。如果所有功能的所有测试都通过，则该组件可能被认为已准备好进行集成。

构建测试可能是功能测试中最困难的部分之一。我们需要构建两种不同类型的测试：正向测试和负向测试。正向测试测试预期的程序使用流程，而负向测试测试意外的使用流程。

正面测试相对容易生成。任何您希望或期望用户执行的操作都可以转化为正面测试用例。例如，单击应用程序中的按钮或在文本字段中输入信息。这两个用例可以转化为单击按钮的功能测试和输入文本字段的功能测试。由于正面测试旨在测试预期的程序流程，因此应使用有效和预期的数据。在测试不使用数据而是使用其他功能的情况下，例如用户的鼠标点击，我们只需要为预期行为编写正面测试。

负面测试更难创建。它们需要更多的创造力来有效地构建和实施，因为你必须想出奇怪的方法来破坏自己的代码。往往很难预料用户可能如何误用功能。负面测试旨在测试错误路径和失败。例如，如果我们打算让用户在我们的网站上单击一个按钮，可能会明智地为双击条件编写负面测试。双击是意外行为，如果没有妥善考虑，可能会导致表单重新提交。负面测试对于充分测试一个功能是必不可少的。

### 集成测试

集成测试是从功能测试中退一步。集成测试旨在测试模块和组件在完全集成时的工作方式。单元测试逐个测试功能。功能测试逐个测试完整的组件或模块。集成测试测试组合的组件，以确保它们正确地相互交互。集成测试通常比单元测试或功能测试更复杂。一旦所有组件都建立并集成在一起，集成测试可以为简单的单个网页编写，也可以为包含 API、多个服务器和数据库的完整前端应用程序编写。集成测试通常是最困难和耗时的测试形式。

**集成测试**可以简化并且可以像制造圆珠笔的过程一样思考。盖子、笔身、墨水、圆珠和带夹的尾盖都是圆珠笔的组成部分。它们都是分别制造和测试，以确保每个组件都符合其设定的规格。当这些部件准备好后，它们被放在一起进行集成测试，以测试这些组件是否能正确地一起运行。例如，我们的集成测试可能测试圆珠是否能放入墨水盒中，墨水和圆珠是否能放入笔身中，或者盖子是否能放在笔身上。如果其中一个测试失败，集成系统（圆珠笔）将无法按规格运行，一个或多个组件必须更新。

进行集成测试有几种方法。它们包括大爆炸测试、自下而上测试、自上而下测试和夹层测试。每种方法都有其优点和缺点。

大爆炸测试包括一次性组合所有组件，然后运行测试。它被称为**大爆炸测试**，因为你一次性将所有东西放在一起，然后会出现（很可能）失败的集成测试。**大爆炸测试**对于没有太多组件之间交互的小型系统非常方便。但是，当应用于大型系统时，大爆炸测试通常会出现问题。第一个问题是在非常大型和非常复杂的系统中，故障定位可能会更加困难。如果找到错误源需要很长时间，我们的测试周期将会非常缓慢。第二个问题是由于系统的复杂性，一些组件之间的链接可能会被忽略而未经测试。如果有数百个需要测试的组件链接，一旦它们全部同时链接起来，要跟踪它们可能会很困难。大爆炸测试的第三个问题是，集成测试无法在所有模块或组件被设计和完全构建之前开始。由于必须一次性组合所有模块，一个模块的延迟会推迟整个系统的集成测试。

集成测试的第二种形式是**自下而上的测试**。在**自下而上的测试**中，我们必须将系统的层次结构想象成一棵树。我们首先集成底层模块，然后一旦所有测试通过，我们就添加下一层模块或组件，直到整个系统都被测试。为了以这种方式进行测试，我们必须使用驱动程序来模拟上层并调用我们正在测试的底层模块或组件。驱动程序只是模拟高级模块和它们对低级模块的调用的代码片段，用于测试目的。自下而上的测试有两个主要好处。第一个是故障定位非常容易。模块从最低级别开始集成。如果新集成的模块失败，那么我们可以快速找出需要修复的模块。第二个好处是不需要等待所有模块都开发完成。如果模块也是按自下而上的方式开发的，那么一旦准备就绪，我们就可以将它们添加到集成测试中。我们可以在准备就绪时进行集成测试，而不是等到整个系统构建完成。自下而上的测试有两个主要缺点。第一个是很难创建早期的工作原型。由于模块是自下而上构建和集成的，用户界面功能和模块通常是最后实施和测试的。由于原型组件通常最后准备就绪，因此很难拥有早期原型。第二个缺点是控制应用程序流程的顶层关键组件和模块最后进行测试，可能无法像首先测试的模块那样进行充分测试。对于大型集成系统，我一般认为自下而上的测试比大爆炸测试更好。

集成测试的第三种形式是**自顶向下测试**。在**自顶向下测试**中，我们必须将系统层次结构想象成一棵树。我们首先集成系统的顶层。这些通常是面向用户的组件和程序流模块。自顶向下测试要求测试人员构建存根来模拟较低级别模块的功能。存根模仿未开发的模块，以便正在测试的模块可以进行所需的调用。自顶向下测试有三个主要优点。与自底向上测试一样，第一个主要优点是故障定位非常容易，我们不需要等待整个系统构建完成才能开始集成测试。组件可以一次添加一个，一旦它们被构建。自顶向下测试的第二个优点是可以非常容易地创建早期原型。首先构建和测试面向用户和最关键的组件，因此很容易将它们集成到早期演示的原型中。最后一个主要优点是对关键模块进行了优先测试。关键模块首先构建，因此更频繁地进行测试，通常更完整。自顶向下测试有两个主要缺点。第一个是需要许多存根。每个较低级别的模块或组件必须构建成一个用于测试的存根。这可能需要编写大量额外的代码。第二个缺点是较低级别的模块通常是最后构建和测试的。通常，它们没有经过如此彻底的测试。

集成测试的最终形式是**夹层测试**。**夹层测试**是自顶向下和自底向上方法的结合。最重要和最低级别的模块同时构建和集成。这种方法的好处是提供了更一般和大爆炸式的集成测试方法，同时保持了自顶向下和自底向上测试的优点。夹层测试的最大缺点是需要构建存根和驱动程序。如果系统非常复杂，有时很难分清存根和驱动程序。

### 构建测试

构建测试可能看起来是一个非常艰巨的过程。从头开始构建整个测试套件可能非常困难。然而，测试驱动开发为我们提供了一个非常好的测试起点。如前所述，在*测试驱动开发*部分，构建测试应始终从编写需求表开始。

需求表是用于构建功能、特性或整个系统的数据表。需求表应将功能的要求细分为非常详细和具体的列表。为软件应用程序编写需求表超出了本书的范围，但我们将通过一个简要的示例进行介绍。假设我们被要求构建一个类似 Facebook 的评论创建组件。该组件必须具有一个带有字符限制的文本字段和一个在点击事件后发表评论的按钮。我们可以从这个场景中轻松构建出两个一般要求：文本字段的字符限制和按钮在点击事件后进行 API 调用。然后，这两个要求可以细化为以下要求列表：

1.  文本字段必须接受用户输入的字符。

1.  文本字段包含 250 个或更多字符时，无法向文本字段添加字符。

1.  在文本字段中，按下退格键可以删除任何字符。

1.  按钮必须对`onclick`事件做出响应。

1.  在点击事件中，组件必须使用文本字段数据调用 API。

这不是功能或功能组件的完整需求列表，但对于这个示例来说，已经足够了。有了这些需求，我们就可以开始编写我们的测试了。

我们可以开始编写测试，逐项通过我们的需求列表。每个需求都应该分解为一个或多个测试。每个测试应该测试一件事，并具有非常具体的成功标准。

第一个要求是文本区域必须接受用户输入的字符。如果我们在键盘上按键，按下的字符应该添加到文本区域，所以我们的第一个测试应该是在键盘上按键，并验证相同的字符是否添加到文本区域。

第二个要求规定，当文本区域包含 250 个或更多字符时，不能添加任何字符到文本字段。这可以分为两个测试：当文本区域有 250 个字符时，不能添加任何按键到文本区域，当文本区域有超过 250 个字符时，不能添加任何按键到文本区域。

第三个要求规定，可以通过按下退格键删除文本字段中的任何字符。这个要求可以很容易地转化为一个测试。我们必须测试，如果按下退格键，一个字符将从文本区域中删除。为了正确测试边缘情况，我们应该运行这个测试四次：一次是空的文本区域，一次是有 0 个但少于 250 个字符的文本区域，一次是 250 个字符，一次是超过 250 个字符。测试文本区域的所有操作条件（甚至是我们从未预期达到的超过 250 个字符的测试用例）将确保不会发生任何故障。

第四个要求规定按钮必须响应点击事件。这个测试非常容易编写。我们只需要添加一个测试，用户点击按钮。最后一个要求规定，按钮上的点击事件必须调用 API。我们可以很容易地将这转化为一个测试，通过模拟点击事件，并确保网站使用正确的数据调用 API。

我们已经在一系列测试中概述了五个要求的列表。现在可以将这些测试编译在一起，并以代码形式编写在一个测试文件中。这个测试文件将用于验证我们需求表中概述的需求是否得到了正确满足。

### 练习 26：编写测试

你的团队被要求为你的通讯订阅建立一个注册页面。注册页面必须有三个文本字段，用于姓名、电子邮件和年龄，以及一个**提交**按钮。您的注册页面必须接受 1 到 50 个字符（包括）之间的姓名，1 到 50 个字符（包括，不验证电子邮件格式）之间的电子邮件，以及用户的年龄（必须大于 13 岁）。当按下**提交**按钮时，用户信息必须经过验证（根据前一节提供的规格）。如果规格的任何部分未满足，就在浏览器控制台中抛出错误。编写一个非常基本的规格表，详细说明每个输入和提交按钮的要求，然后从规格表中构建测试。实现页面（使用`exercises/exercise26/exercise.html`作为起点），并从 UI 手动执行测试。起始文件包含了您必须编写的测试的提示。在打开起始文件之前编写规格表和测试。

构建一个基本的规格表，并从规格表中运行测试，执行以下步骤：

1.  通过将包含场景描述中规格信息的每个句子拆分为一个或多个需求来编写规格表。

1.  将规格表分解为手动 UI 测试，方法是将规格表上的每一项都写成一个或多个测试。

1.  打开`exercises/exercise26/exercise.html`中的起始 HTML 文件。

1.  添加三个带有 ID `name`、`email` 和 `age` 的输入字段。如下图所示：![图 4.4：数据表（第 4 步后）](img/Figure_4.4.jpg)

###### 图 4.4：数据表（第 4 步后）

1.  将**提交**按钮添加到 HTML 文档中，并在单击时调用`validate`函数。

1.  在验证函数中，通过 id 获取`name`文本字段并将其值保存在`name`变量中。

通过 id 获取`email`文本字段并将其值保存在`email`变量中。

通过 id 获取`age`文本字段，获取其值，解析数字的值，然后将解析后的值保存在`age`变量中。

检查与`name`字段相关的规范表上的条件。还要检查名称是否不存在，或者为 false，如果是，则抛出错误。检查`name length <= 0 or > 50`，如果是，则抛出错误。

检查与`email`字段相关的规范表上的条件。还要检查电子邮件是否不存在，或者为假；如果是，则抛出错误。检查`email length is <=0 or > 50`，如果是，则抛出错误。

检查与`age`字段相关的规范表上的条件。还要检查年龄是否不存在，或者为假；如果是，则抛出错误。检查`age < 13`，如果是，则抛出错误。

将用户详细信息（`name`，`email`和`age`）记录到控制台。

1.  对于规范表中编写的每个测试，手动测试它。填写文本字段中的值，然后单击**提交**。

将记录在控制台的错误与测试的预期结果进行比较。

如果测试失败，则更新验证函数以修复错误并重新运行测试。

**代码**

##### solution.html

```php
<body>
 <input type="text" id="name" value="Name">
 <input type="text" id="email" value="Email">
 <input type="text" id="age" value="Age">
 <button onclick="validate()">Submit</button>
 <script>
   function validate() {
     const name = document.getElementById( 'name' ).value;
     const email = document.getElementById( 'email' ).value;
     const age = parseInt( document.getElementById( 'age' ).value, 10 );
     if ( !name ) {
       throw new Error( 'Must provide a name.' );
     } else if ( name.length <= 0 || name.length > 50 ) {
       throw new Error( 'Name must be between 1 and 50 characters.' );
     }
     if ( !email ) {
       throw new Error( 'Must provide an email.' );
     } else if ( email.length <= 0 || email.length > 50 ) {
       throw new Error( 'Email must be between 1 and 50 characters.' );
     }
     if ( !age ) {
       throw new Error( 'Must provide an age that is also a number.' );
     } else if ( age < 13 ) {
       throw new Error( 'Age must be at least 13.' );
     }
     console.log( 'User details:
     Name: ${name}
     Email: ${email}
     Age: ${age}' )
   }
 </script>
</body>
```

###### 片段 4.4：测试前端输入代码

https://bit.ly/2H5E7OJ

**输出**

![图 4.5：数据表（最终输出）](img/Figure_4.5.jpg)

###### 图 4.5：数据表（最终输出）

您已成功构建了基本的规范表并从规范表中运行了测试。

## 测试工具和环境

测试工具、框架和环境旨在使测试代码更简单、更快速。JavaScript 有许多可用的测试框架，最受欢迎的将会简要提到。然后我们将深入研究其中一个框架，并演示如何使用该框架编写良好的测试。

### 测试框架

您需要根据希望进行的测试类型选择测试框架。通常使用三种方式对 JavaScript 进行测试：**一般测试**，**代码覆盖测试**和**用户界面测试**。在选择框架时，必须决定要测试什么以及希望如何进行测试。

一般测试将包括单元测试、功能测试和集成测试。这是您测试的一种综合方式。最受欢迎的测试框架是**Mocha**，**Jasmine**和**Jest**。Jest 由 Facebook 使用，是设置最简单的框架之一。Mocha 是 JavaScript 中最受欢迎的测试框架，并且稍后将更详细地介绍它。

代码覆盖测试用于帮助检查测试的完整性。代码覆盖可以定义为您的自动化测试覆盖的代码基数的百分比。代码覆盖可以用作代码测试完整性的一般指导。理论上，应用程序的代码覆盖率越高，测试就越完整和更好。但是，在实践中，拥有 100%的代码覆盖并不意味着代码的测试经过深思熟虑且有效。这只意味着每个代码路径在某种程度上都在测试中引用。编写深思熟虑的测试比随意组合的测试更重要，后者会触及每行代码。最受欢迎且最简单的代码覆盖库是**Istanbul**。它与许多测试框架兼容，并且可以轻松地融入大多数测试套件中。如果需要第三方库进行代码覆盖测试，我建议使用 Istanbul。

测试的最终形式是**用户界面**（**UI**）测试。与一般测试一样，我们可以将 UI 测试分为集成测试、功能测试和单元测试。然而，UI 测试通常不包括在一般测试中，因为它们需要特殊和更复杂的框架。要执行 UI 测试，我们必须加载用户视图并模拟用户交互。一些更常见的 UI 测试框架包括 Testcafe、WebdriverIO 和 Casper。

### Mocha

**Mocha**是一个用于在 Node.js 中测试 JavaScript 的框架。它是一个简单的库，旨在简化和自动化测试过程。Mocha 被设计为简单、灵活和可扩展的。我的公司使用 Mocha 进行单元测试、功能测试和集成测试。我们将讨论使用 Mocha 而不是其他框架的一些好处，介绍如何设置和运行 Mocha 的第一个测试，并解释 Mocha 提供的一些高级功能。

#### 注意

Mocha 的完整文档可以在[`mochajs.org/`](https://mochajs.org/)找到。

Mocha 有许多好处。正如前面所述，Mocha 是 Node.js 最流行的测试框架。这立即给 Mocha 带来了最大的优势：Mocha 拥有最大的开发社区。这对于支持和扩展非常重要。如果您在 Mocha 测试中遇到问题，这个社区可以提供广泛的支持。Stack Overflow 社区很快就会回答关于 Mocha 的问题。Mocha 社区还为独特的测试场景构建了许多插件或扩展。如果您的项目有独特的测试需求，很可能已经构建了适合您需求的插件。

除了庞大的社区支持外，Mocha 还提供了简单的设置、断言和简单的异步测试等优势。通过 npm 可以通过命令行设置 Mocha。对于任何测试框架，我们希望确保设置它不会花费太多时间。Mocha 还允许使用断言模块。虽然不是必需的，但如果您的团队希望从断言标准来进行测试，Mocha 允许您安装和导入许多 JavaScript 断言库。最后，Mocha 专为异步测试而设计。对于任何 JavaScript 测试模块，我们必须依赖异步支持来编写完整的测试。Mocha 被设计为与回调、promises 和 ES6 async/await 语法一起工作。它可以轻松地集成到大多数后端设置中。

### 设置 Mocha

安装 Mocha 是通过 npm 命令`npm install -g mocha`完成的。这个命令会在系统上全局安装 Mocha。任何 Node.js 项目现在都可以使用 Mocha 来运行测试。一旦全局安装，我们就可以使用命令行运行测试，使用`mocha`关键字。

一旦 Mocha 在我们的系统上安装好了，我们必须将其添加到一个项目中。如果您没有 Node.js 项目，请创建一个到所需项目目录的路径，并使用`npm init`初始化项目。这是在*第一章*中讨论转译和 Babel 时设置项目时使用的相同命令。`npm init`命令将创建一个名为`package.json`的文件。创建 JavaScript 项目后，我们需要创建项目文件。创建一个名为`index.js`的文件和一个名为`test.js`的文件。`index.js`将包含我们的项目代码，`test.js`将包含我们的测试代码。

在`package.json`文件中，将会有一个名为`scripts`的字段。要从 npm 运行我们的测试，我们必须向`scripts`对象添加一个字段。用以下片段中显示的代码替换`scripts`对象：

```php
"scripts": {
  "test": "mocha ./test.js"
}
```

###### 片段 4.5：package.json 中的测试脚本

前面片段中的代码向`package`对象添加了一个名为`test`的脚本。我们可以使用`npm run test`命令运行此脚本。运行此命令时，它会调用`mocha`关键字和`./test.js`参数。Mocha 测试框架将运行`test.js`文件中包含的测试。现在我们已经准备好开始向`test.js`添加测试了。

Mocha 使用`describe`和`it`关键字组织测试。两者都是以字符串作为第一个参数和函数作为第二个参数的函数。`describe`函数用于将测试分组在一起。`it`函数用于定义一个测试。`describe()`的函数参数包含测试声明（使用`it()`）或更多的描述函数。`it()`的函数参数包含要运行的测试函数。

您可以将 describe 函数视为描述和组合一组测试的方式。例如，如果我们有一组测试都测试一个名为`calculateModifier`的函数，我们可以使用 describe 函数将这些测试组合在一起，并使用描述：`describe( 'calculateModifier tests', () => { ... } )`。这将把包含在函数中的测试分组在`calculateModifier`测试下。

您可以将`it`函数视为定义测试的一种方式，形式为“它应该……”。传递给`it`函数的字符串描述了测试，通常是测试试图实现的内容。函数参数包含实际的测试代码。例如，如果我们想定义一个检查两个值是否相等的测试，我们可以使用`it`函数来做到这一点：`it( 'should have two inputs that are equal', () => { ... } )`。描述告诉我们应该发生什么，检查值的代码将放在函数参数中。

### Mocha 基础知识

了解测试的基础知识后，我们可以查看 Mocha 入门文档，并查看以下代码片段中显示的代码：

```php
var assert = require('assert');describe('Array', function() {  describe('#indexOf()', function() {    it('should return -1 when the value is not present', function() {      assert.equal([1,2,3].indexOf(4), -1);    });  });});
```

###### 代码片段 4.6：Mocha 基础知识

您认为这段代码在做什么？首先，我们用描述`Array`描述了一组测试。在第一个`describe`块的函数参数内部，我们有另一个`describe`块。这个新块描述了一个带有描述`#indexOf`的测试集；因为这些描述块是嵌套的，我们可以假设我们正在测试数组的`indexOf`功能。在第二个`describe`块内部，我们使用`it`函数定义了一个测试。我们定义了一个测试，说`当值不存在时应返回-1`。根据测试的描述，我们期望`indexOf`函数在数组中的值不存在时返回值`-1`。在这个例子中，我们使用 assert 库来断言预期值`-1`等于实际值。assert 库并不是严格必要的，但使这个例子更容易理解。

### 练习 27：设置 Mocha 测试环境

目标是设置 Mocha 测试环境并准备一个测试文件。要完成此任务，请按照以下步骤操作：

1.  运行`npm init`在练习目录中创建一个`package.json`文件。

1.  运行`npm install mocha -g`来安装测试包。

1.  创建一个名为`test.js`的文件，我们的测试将放在其中。

1.  在`package.json`文件中添加一个脚本，以在`test.js`文件上运行 mocha 测试套件。

1.  在`test.js`文件中，添加一个`describe()`块，将测试描述为`My first test!`

1.  在`describe`块的回调内部，添加一个带有`it()`的测试，通过并具有描述`Passing test!`

1.  通过调用`package.json`中添加的`npm`脚本来运行测试。

**代码：**

##### **test.js**

```php
describe( 'My first test!', () => {
 it( 'Passing test!', ( done ) => done( false ) );
} );
```

###### 代码片段 4.7：Mocha 基础知识

https://bit.ly/2RhzNAy

**输出：**

![图 4.6：Mocha 测试](img/Figure_4.6.jpg)

###### 图 4.6：Mocha 测试

您已成功设置了 Mocha 测试环境并准备了一个测试文件。

### Mocha 异步

Mocha 支持异步测试和同步测试。在 Snippet 4.6 中显示的示例中，我们执行同步测试。要支持异步测试，我们只需要将一个 done 回调参数传递到`it()`函数的函数参数中：`it( 'description', ( done ) => {} )`。这告诉 mocha 在继续进行下一个测试之前等待`done`回调被调用。`done`参数是一个函数。如果测试成功，应该使用一个`falsy`值（没有错误）调用 done。如果使用一个`truthy`值调用 done，mocha 将解释该值为错误。最佳实践是将错误对象传递给 done 回调，但任何评估为 true 的值都会告诉 Mocha 测试失败。

Mocha 以同步方式按照测试文件中定义的顺序同步执行异步测试。测试可能会异步查询资源，但在上一个测试完全完成（done 已被调用）之前，下一个测试不会开始运行。同步运行测试非常重要。即使同步运行测试可能导致更长的测试时间，它也允许我们测试依赖于一些共享状态的异步系统。例如，我们可以使用 Mocha 测试数据库和数据库接口等系统。如果我们需要执行一个集成测试，测试向数据库添加和删除的过程，我们可以创建一个测试来向数据库添加项目，以及一个测试来从数据库中删除添加的项目。如果这两个测试异步运行，我们可能会遇到时间问题。由于网络延迟或其他意外错误，删除操作可能在添加操作之前被处理，测试将失败。Mocha 通过强制测试同步运行来避免调试此类问题的需要。

### Mocha Hooks

对于更复杂的测试，Mocha 允许我们将钩子附加到我们的测试上。**Hooks**可以用于设置测试的前提条件和后置条件。简单来说，钩子允许我们在测试之前和之后进行设置。Mocha 提供以下钩子：`before`，`after`，`beforeEach`和`afterEach`。钩子接受两个参数，一个`description`和一个`callback`函数参数。这个函数参数可以接受一个参数 - 一个 done 函数。钩子的语法示例如下所示：

describe( 'Array', () => {

```php
  before( 'description', done => { ... } );
  after( 'description', done => { ... } );
  beforeEach( 'description', done => { ... } );
  afterEach( 'description', done => { ... } );
} );
```

###### Snippet 4.8: Mocha hooks

钩子只在它们所包含的描述块中的测试之前或之后运行。`before`钩子在任何定义的测试开始之前运行一次。它们可以用于在测试之间设置一个共享状态。`beforeEach`钩子在每个测试开始之前在`describe`块内运行。它们可以用于设置或重置每个测试所需的共享状态或变量集。`after`钩子在所有测试完成后运行一次。它们可以用于清理或重置测试之间共享的状态。`afterEach`钩子在每个测试完成后但下一个测试开始之前运行。它可以用于清理或重置特定于测试的共享状态。

### Activity 4: Utilizing Test Environments

您的任务是将斐波那契序列测试代码升级为使用 Mocha 测试框架。取出斐波那契序列代码并测试您为*Activity 1: Implementing Generators*创建的代码，并升级为使用 Mocha 测试框架来测试代码。您应该为`n=0`条件编写测试，实现它，然后为`n=1`条件编写测试并实现。对于`n=5`，`n=6`以及`n=8`也重复这个过程。如果`it()`测试通过，调用没有参数的 done 回调，否则使用错误或其他`truthy`值调用测试完成回调。

要使用 Mocha 测试框架编写和运行测试，请执行以下步骤：

1.  设置 NPM 项目并安装 mocha 模块。

1.  在`package.json`中添加一个测试脚本，运行 mocha 和`test.js`中的测试。

1.  创建一个`index.js`文件，其中包含一个斐波那契数列计算器函数。导出这个函数。

1.  创建`test.js`，使用 mocha 框架测试斐波那契数列函数。测试`fibonacci`，n=0，n=1，n=2，n=5，n=7 和 n=9。

**输出**

![图 4.7：使用 Mocha 测试斐波那契数列](img/Figure_4.7.jpg)

###### 图 4.7：使用 Mocha 测试斐波那契数列

你已成功利用 Mocha 测试框架编写和运行测试。

#### 注意:

此活动的解决方案可在第 288 页找到。

## 总结

代码测试是开发人员可以拥有的最重要的技能之一。测试代码就像去健身房一样。你知道这对你有好处，但往往很难开始。在本章中，我们讨论了测试代码的原因，几种代码测试类型以及几种 JavaScript 代码测试框架。需要进行代码测试以确保程序的正确性。测试驱动开发是将测试整合到项目中的最简单方法之一。TDD 围绕着编写测试来概述任何添加的功能或函数的要求，然后再编写任何实现代码。有许多形式的代码测试。在本章中，我们介绍了单元测试、功能测试和集成测试。这些类型的代码测试是最常见的，通常是从黑盒和白盒两种方法中构建的。功能、单元和集成测试都可以在前面主题中涵盖的许多框架中构建。

在下一章中，我们将介绍函数式编程编码原则，并定义面向对象编程和函数式编程。
