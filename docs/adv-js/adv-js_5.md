# 第六章：函数式编程

## 学习目标

在本章结束时，您将能够做到以下几点：

+   解释函数式编程

+   实现函数式编程的关键概念

+   将函数式编程概念应用于您的代码

+   以函数式编程风格构建新的代码库

本章解释了编程的类型，包括面向对象编程和函数式编程，以及如何使用不同类型的函数。

## 介绍

在第一章中，我们涵盖了 ES6 中发布的许多新功能和强大功能。我们讨论了 JavaScript 的发展，并突出了 ES6 中的关键增强。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强对象属性、解构赋值、类和模块、转译以及迭代器和生成器。

在第二章中，我们涵盖了 JavaScript 的异步编程范式。我们讨论了 JavaScript 事件循环、回调、承诺和 async/await 语法。

在第三章中，我们学习了文档对象模型（DOM）、JavaScript 事件对象和 jQuery 库。

在第四章中，我们讨论了测试 JavaScript 代码。我们涵盖了测试的原因以及如何添加测试的方法。然后，我们讨论了不同类型的代码测试以及它们如何应用于您的代码库。最后，我们讨论了各种 JavaScript 代码测试框架以及如何在其中构建测试。

在本章中，我们将介绍函数式编程的编码原则。在第一个主题中，我们将定义面向对象编程和函数式编程，讨论两者之间的区别，并概述我们使用函数式编程的原因。然后，在随后的部分中，我们将讨论函数式编程的每个关键概念。对于每个关键概念，我们将概述定义并展示其在函数式编程中的应用。

## 引入函数式编程

有许多不同的方法来处理软件设计和构建。最知名的设计哲学或编程范式是面向对象编程（OOP）和函数式编程（FP）。编程范式是一种思考软件设计和构建的方式。编程范式基于几个定义原则，并用于组织和描述软件应用的设计和构建。函数式编程是一种通过表达式和声明构建软件的编程范式。在本节中，我们将讨论面向对象编程和函数式编程的基础知识，并比较这两种编程范式。

### 面向对象编程

面向对象编程（OOP）是一种基于对象和语句的编程范式。对象是用于组织应用程序部分的编程抽象。在 OOP 中，对象通常包含并存储属性中的数据，具有可以在方法中运行的过程，并且具有**this**或**self**的概念，这是对象引用自身的一种方式。一般来说，对象以类的形式存在。**类**可以被视为对象的定义，具有其属性、方法和**this**范围。**对象**是类的实例化。在 OOP 中，语句是指令驱动的代码。这将在*声明式与命令式*主题中更详细地介绍。许多编程语言都适用于面向对象编程软件开发。最流行的面向对象编程语言是 C++、Java 和 Python。

### 函数式编程

函数式编程（FP）是一种基于表达式和声明而不是对象和语句的编程范式。简而言之，这意味着 FP 依赖于函数而不是对象来组织代码和构建应用程序。函数式编程被认为起源于λ演算，这是在上世纪 30 年代创造的。函数式编程依赖于七个关键概念：声明式函数，纯函数，高阶函数，共享状态，不可变性，副作用和函数组合。这些概念中的每一个将在本章的后续主题中进行讨论。

函数式编程旨在更简洁，可预测和可测试。然而，这些好处可能导致 FP 代码比其他编程范式更密集。一些最常见的函数式编程语言是 JavaScript，PHP 和 Python。

## 声明式与命令式

有两种一般的编写代码的方式：**声明式**和**命令式**。在函数式编程范式中编写的代码应该是声明式的。

**声明式代码**是表达计算逻辑而不描述其控制流的代码。命令式代码是使用语句来改变程序的状态的代码。

如果你以前从未学习过声明式和命令式代码，这些定义很难理解。声明式代码通常与函数式编程一起使用，而命令式代码通常与面向对象编程一起使用。在决定使用哪种编码风格时，没有“正确答案”；它们都有各自的权衡。然而，声明式代码比命令式更适合函数式编程范式。

### 命令式函数

**命令式代码**在面向对象编程中最常见。技术上的定义很复杂，但我们可以简化它。编写命令式代码是关于你如何解决问题。考虑在餐厅找到一张桌子。你走向主人/女主人说：“我看到角落的桌子是空的。我和我的妻子要走过去坐下。”这是一种命令式方法，因为你描述了你将如何从主人/女主人那里到你的团队的桌子。

### 声明式函数

声明式编程在 FP 中最常见。编写声明式代码的方法可以简化为我们需要做什么。考虑前面段落中的餐厅例子。获取桌子的声明式方法是走向主人/女主人说：“请给我们两个人的桌子。”我们描述我们需要什么，而不是我们将采取的每一步来获得桌子。声明式编程是符合开发者的思维模型而不是机器的操作模型。从这些定义和比喻中，我们可以得出结论，声明式编程是对一些命令式实现的抽象。

现在，让我们从比喻转到实际代码。考虑下面片段中显示的代码：

```php
function addImperative( arr ) {
 let result = 0;
 for ( let i = 0; i < arr.length; i++ ) {
   result += arr[ i ];
 }
 return result;
}
function addDeclarative( arr ) {
 return arr.reduce( ( red, val ) => red + val, 0 );
}
```

###### 片段 5.1：声明式与命令式函数

在上面的片段中，我们创建了两个函数来添加数组中的值。第一个函数`addImperative`是这个问题的一种命令式方法。代码逐步说明了数组将如何被添加。第二个函数`addDeclarative`是同一个问题的一种声明式方法。代码说明了数组将如何被添加。它通过使用 JavaScript 数组 reduce 操作来抽象出大部分命令式解决方案（for 循环）。

开始编写声明式代码而不是命令式代码的最简单方法是创建函数。这些函数应该抽象出命令式代码的逐步性质。考虑数组操作，如`find`，`map`和`reduce`。这些函数都是声明式的数组成员函数。它们抽象出了对数组进行迭代的逐步性质。使用它们将有助于将声明式概念引入您的代码，并减少您编写的一些命令式代码。

### 练习 28：构建命令式和声明式函数

您的研究团队已经获得了最新实验的值列表；但是，由于校准错误，只有部分数据可以使用，并且可以使用的任何数据都需要进行缩放。您必须构建一个实用函数，该函数接受一个数组，过滤掉小于或等于 0 的任何值，将剩余的值缩放为乘以`2`，并返回最终结果。首先，构建一个命令式函数来执行此操作，然后构建一个声明式函数来执行相同的操作。

要使用命令式和声明式编码实践创建函数，请执行以下步骤：

1.  定义一个名为`imperative`的函数，采用以下方法：

接受一个名为`arr`的数组参数。创建一个名为`filtered`的数组，用于保存过滤后的值。

创建一个`for`循环来遍历输入数组`arr`。对于每个项目，检查数组项的值。如果大于`0`，将该值推送到过滤后的数组中。

创建一个`for`循环来遍历过滤后的数组。对于每个项目，将其乘以`2`并保存在相同索引的过滤后的数组中。

返回过滤后的数组。

1.  定义一个名为`declarative`的函数，执行以下操作：

使用`Array.filter()`过滤输入数组。在过滤器的`callback`函数中，检查值是否大于`0`。如果是，返回 true；否则，返回 false。

将一个 map 调用链接到`filter`输出。

使用`Array.map()`映射过滤后的数组。

在回调中，将每个值乘以`2`。

返回修改后的数组。

1.  创建一个值从`-5`到`+5`的测试值数组。

1.  使用值数组运行`imperative`并记录输出。

1.  使用值数组运行`declarative`并记录输出。

**代码**

##### index.js

```php
function imperative( arr ) {
 const filtered = [];
 for ( let i = 0; i < arr.length; i++ ) {
   if ( arr[ i ] > 0 ) {
     filtered.push( arr[ i ] );
   }
 }
 for ( let j = 0; j < filtered.length; j++ ) {
   filtered[ j ] = 2 * filtered[ j ];
 }
 return filtered;
}
function declarative( arr ) {
 return arr.filter( v => v > 0 ).map( v => 2 * v );
}
```

###### 代码段 5.2：命令式和声明式代码比较

https://bit.ly/2skAnic

**结果**

![图 5.1：测试值输出](img/Figure_5.1.jpg)

###### 图 5.1：测试值输出

![图 5.2：修改后的数组输出](img/Figure_5.2.jpg)

###### 图 5.2：修改后的数组输出

您已成功利用了命令式和声明式编码实践来编写函数。

## 纯函数

**纯函数**是函数式编程的关键组成部分。纯函数可以定义为不对函数外部的状态产生任何影响或利用任何状态的函数。要被视为纯函数，函数必须满足三个关键标准：

+   当给定相同的输入时，函数必须始终返回相同的输出。

+   函数不能有副作用。

+   函数必须具有引用透明性。

### 相同的输入给出相同的输出

给定一组输入值，纯函数在提供这些输入值时必须始终返回相同的值。这听起来比实际情况复杂得多。简而言之，纯函数的输出不能改变，除非更改输入值。这意味着函数的内部代码不能依赖于函数外部的任何程序状态。纯函数不能使用函数外部的任何变量来进行计算或代码路径决策。以下代码段显示了这一点的示例：

```php
const state = { prop1: 5 };
function notPure () {
  return state.prop1 > 0 ? 'Valid': 'Invalid';
}
function pure( val ) {
  return val > 0 ? 'Valid': 'Invalid';
}
notPure(); // Expected output: 'Valid'
pure( state.prop ); // Expected output: 'Valid'
```

###### 代码段 5.3：依赖外部状态

在前面的片段中，我们创建了一个名为 state 的变量，其中的`prop1`属性设置为`5`。然后我们定义了两个函数，根据值的比较返回字符串`Valid`或`Invalid`。在第一个函数`notPure`中，我们检查 state 的`prop1`值，并根据此返回一个值。在第二个函数 pure 中，我们检查传入函数的值来决定返回什么。第一个函数不是一个纯函数。它依赖于函数外部的状态来确定函数的返回值。第二个函数是纯的，因为它依赖于函数的输入值，而不是全局状态变量。

### 无副作用

纯函数不能有副作用。这简单地意味着纯函数不能修改通过引用传递的任何对象或值。副作用将在*副作用*主题中更详细地讨论。在 JavaScript 中，只有对象和数组可以通过引用传递给函数。纯函数不能以任何方式修改这些对象或数组。如果您的函数需要在内部更新或修改数组或对象，我们必须首先创建数组/对象的副本。重要的是要注意，在 JavaScript 中，复制对象或数组只会复制实体的第一层。这意味着如果一个数组或对象中嵌套了数组或对象，这些嵌套的引用将不会被复制。当复制的对象按引用传递时，嵌套的对象也将被传递。这意味着如果嵌套引用没有被显式复制，可能会导致副作用。要正确地复制一个对象，我们必须创建一个深拷贝。对象的深拷贝是一个复制所有嵌套引用的副本。这可以通过递归或通过 Node.js 的`deepcopy`模块来完成。副作用的一个示例在下面的片段中显示：

```php
function notPure( input ) {
  input.prop2 = 'test';
}
function pure( input ) {
  input = JSON.parse( JSON.stringify( input ) );
  input.prop2 = 'test';
  return input;
}
```

###### 片段 5.4：避免副作用

在前面的片段中，我们定义了两个函数`notPure`和`pure`。这两个函数都向传入函数的`input`对象添加一个属性。函数的不纯版本（`notPure()`）直接修改了`input`对象。因为对象是按引用传递的，这个更新将在所有其他使用对象的范围内可见。这是一个副作用。函数的纯版本（`pure()`）通过 JSON 操作创建了对象的深拷贝，然后向新对象添加了一个新属性并返回了新对象。由于对象被克隆了，原始对象没有被修改。没有产生副作用。

### 引用透明度

**引用透明度**是纯函数的一个属性，使得弄清楚函数行为更简单。如果一个函数具有引用透明性，那么对该函数的调用可以用函数调用的结果值（函数返回的值）替换，而不改变代码的含义。简而言之，这意味着函数应该返回在其被使用的代码上下文中有意义的值，并且不应该依赖或修改函数外部的状态。

编写纯函数给我们带来了两个关键的好处：

第一个好处是纯函数非常容易进行单元测试。纯函数不依赖外部状态，因此在编写测试时不需要考虑其他上下文。我们只需要考虑输入和输出值。

其次，纯函数使代码更简单、更灵活。纯函数不依赖外部状态，也不产生副作用。这意味着它们可以在任何特殊的上下文中使用。它们可以在更多的地方使用，因此更灵活。

### 练习 29：构建纯控制器

您已被聘为开发人员，以升级在线商店的购物车实现。构建一个函数来向购物车添加物品。您的函数应该是纯的。您可以假设有一个名为`cart`的全局数组，其中包含购物车。该函数应该至少接受一个物品（字符串）和一个数量（`number`）。在提供的文件（`exercise-test.js`）中创建名为`addItem()`的函数。该文件将有基本测试来测试纯度。

要使用纯函数概念构建应用程序的一部分，请执行以下步骤：

1.  打开**exercises/exercise29/exercise-test.js**中的测试文件。

1.  创建一个名为`addItem`的函数，它接受三个参数：`cart`、`item`和`quantity`。

1.  复制传入函数的`cart`，并将复制的值保存到名为`newCart`的变量中。使用以下方法之一复制`cart`：

对于最简单的复制，请使用 JSON 操作：`JSON.parse( JSON.stringify( cart ) )`。

通过循环遍历原始购物车数组，并将每个项目推送到新数组中。

使用`cart.map( () => {} )`，因为数组中的所有项目都是简单类型。

使用`rest/spread`运算符，`newCart= [ ...cart ]`，因为所有项目都是简单类型。

1.  将传入函数的项目推送到`cart`数组中，`quantity`次数。

1.  返回`newCart`数组。

1.  运行`exercise-test.js`中提供的代码。

如果抛出错误，请修复代码中的错误，然后再次运行测试。

**代码**

##### exercise-solution.js

```php
function addItem( cart, item, quantity ) {
 // Duplicate cart
 const newCart = JSON.parse( JSON.stringify( cart ) );
 newCart.push( ...Array( quantity ).fill( item ) );
 return newCart;
}
```

###### Snippet 5.5：函数纯度测试

https://bit.ly/2H2TXJG

**输出**

![图 5.3：返回新的购物车数组](img/Figure_5.3.jpg)

###### 图 5.3：返回新的购物车数组

您已成功应用了纯函数的概念来构建应用程序的一部分。

## 高阶函数

正如我们在第一个主题中学到的，高阶函数是一个要么将另一个函数作为输入参数，要么返回另一个函数作为返回值的函数。几乎所有 JavaScript 中的异步代码都利用高阶函数，通过将回调函数作为输入参数传递。除了它们在 JavaScript 中的广泛使用之外，高阶函数是函数式编程的关键部分，用于三个关键好处：抽象、实用程序和复杂性减少。

高阶函数对于抽象非常重要。抽象是隐藏过程的内部工作或细节的一种方式。例如，考虑根据食谱烹饪一餐的过程。食谱可能要求您切碎食物。什么是切碎？它是一个动作的抽象。完成该动作的动作和步骤是拿起刀，将其放在食物上，向下按压。然后，将刀移动一小段距离沿着食物，并重复该过程，直到没有大块残留。切碎是这个动作的抽象。说“切胡萝卜”比长篇描述更简单更快。与准备食物一样，代码使用抽象来包装复杂的过程，并隐藏代码的内部工作。

高阶函数对于创建功能性实用程序非常有用。作为程序员，我们经常创建旨在对一组值执行操作的实用函数。通常，我们希望最大限度地提高灵活性，并创建可以在各种潜在输入值或格式上工作的函数。创建接受一些参数并返回新函数的高阶实用函数可以是一个很好的方法。这些函数在 JavaScript 中通常称为闭包。考虑以下片段中显示的函数：

```php
function sortObjField1( field ) {
 return function ( v1, v2 ) {
   return v1[ field ] > v2[ field ];
 }
}
function sortObjField2( field, v1, v2 ) {
 return v1[ field ] > v2[ field ];
}
```

###### Snippet 5.6：高阶实用程序

在前面的片段中，我们创建了两个用于按指定字段中存储的值对对象数组进行排序的实用函数。这两个实用函数都需要指定字段。它们的区别在于返回值。`SortObjField1`是一个高阶函数，它接受字段名称并返回一个闭包函数。闭包函数接受我们尝试排序的两个对象，并返回排序值。第二个辅助函数`sortObjField2`一次接受字段和两个对象，并返回排序值。高阶实用函数更加强大，因为我们不需要同时知道所有的值。我们可以将`sortObjField( 'field' )`作为参数传递给另一个函数，以在程序的另一个部分中使用。

高阶函数对于减少复杂性也非常有用。代码越长越复杂，就越容易出现错误。高阶函数将复杂部分的内部工作抽象出来，并可以使用实用函数来减少需要编写的代码行数。这两种效果都将减少代码库的大小，从而减少复杂性。简化代码将有助于减少您必须花费在修复错误上的时间。

### 练习 30：编辑对象数组

目标是将高阶函数的概念应用于编辑对象数组。要使用必要的函数编辑数组，请执行以下步骤：

1.  创建一个名为`data`的数组，其中包含以下数据：`[ { f1: 6, f2: 3 }, { f1: 12, f2: 0 }, { f1: 9, f2: 1 }, { f1: 6, f2: 7 } ]`。

1.  创建一个名为`swap`的函数，它接受两个参数`key1`和`key2`。

1.  向`swap`函数添加一个`return`语句。`return`语句应返回一个函数。这个函数应该接受一个参数`obj`。

1.  在返回的函数内部，使用数组解构，交换`obj`中存储的`key1`和`key2`的值。

提示：使用`[a, b] = [b, a]`来使用数组解构交换值。

1.  从函数中返回修改后的对象`obj`。

1.  通过在`data`上调用`map`函数来编辑数据数组。将带有参数`f1`和`f2`的调用传递给`map`函数。

提示：`data.map( swap( 'f1', 'f2' ) );`

1.  记录对`data.map()`的调用的输出。

**代码**

##### **index.js**

```php
const data = [ { f1: 6, f2: 3 }, { f1: 12, f2: 0 }, { f1: 9, f2: 1 }, { f1: 6, f2: 7 } ];
function swap( key1, key2 ) {
 return obj => {
   [ obj[ key1 ], obj[ key2 ] ] = [ obj[ key2 ], obj[ key1 ] ];
   return obj;
 }
}
console.log( data.map( swap( 'f1', 'f2' ) ) );
```

https://bit.ly/2D0t70K

**输出**

![图 5.4：最终输出](img/Figure_5.4.jpg)

###### 图 5.4：最终输出

您已成功将高阶函数的概念应用于编辑对象数组。

## 共享状态

**共享状态**是存在于共享范围中的任何变量、对象或内存空间。任何被多个独立范围使用的非常量变量，包括全局范围和闭包范围，都被视为处于共享状态。在函数式编程中，应该避免共享状态。共享状态会阻止函数变得纯粹。当违反共享状态规则并且程序修改变量时，就会产生副作用。在面向对象编程中，共享状态通常作为对象传递。面向对象编程函数可能会修改共享状态。这与函数式编程规则背道而驰。下面的片段中展示了一个共享状态的示例：

```php
const state = { age: 15 }
function doSomething( name ) {
  return state.age > 13 ? '${name} is old enough' : '${name} is not old enough';
}
```

###### 片段 5.7：共享状态

在前面的例子中，我们有一个全局范围内的变量称为`state`。在我们的名为`doSomething`的函数中，我们引用变量 state 来做出逻辑代码决定。由于`state`变量是在`doSomething`函数的范围之外定义的，并且不是一个不可变对象（创建后其状态无法修改的对象），它被认为是一个共享状态。这是函数式编程中应该避免的事情，因为它会阻止我们的函数变得纯粹。

共享状态必须避免，原因有几个。首先，共享状态可能会使理解函数变得困难。要真正理解函数的工作原理以及给定输入的输出结果，我们必须理解函数所在的整个状态。如果我们的函数使用共享状态，那么在正确理解函数之前，我们必须理解一个更加复杂的状态。详细理解共享状态非常困难。要正确理解共享状态，必须理解状态如何更新以及它如何在与之共享的每个函数中使用。

虽然起初听起来可能不是一个主要的缺点，但不理解我们的函数如何工作将导致开发速度变慢，出现更多的错误和不充分的测试。共享状态会减慢开发速度，因为我们必须花更多的时间来理解依赖于它们的函数。如果我们不花时间理解共享状态和依赖于它们的函数，那么我们很可能不会编写高效和无错误的代码。这显然会导致更多时间用于调试和重构代码。不完全理解的函数往往更容易出现错误。如果我们不完全理解函数在共享状态中定义的所有可能性和限制下需要如何操作，那么我们很可能会忘记在开发中处理边缘情况。如果这些错误没有被发现，那么有缺陷的代码可能会被发布。最后，不理解函数几乎不可能完全测试一个函数。要完全测试任何函数，我们必须完全理解它在所有条件下的操作方式，换句话说，就是在所有可能被调用的状态下。

### 练习 31：修复共享状态

目标是重构代码以消除共享状态。要正确地重构代码，请执行以下步骤：

1.  打开`exercises/exercise31/exercise.js`文件。您将更新此文件以解决练习。

1.  运行*步骤 1*中打开的文件中的代码，并观察输出。

1.  更新`getOlder`函数声明，以接受一个名为`age`的参数。

1.  更新`getOlder`的主体，使其返回`age+1`或`++age`，而不是修改全局变量。

1.  将`formatName`函数声明更新为接受两个参数，`first`和`last`。

1.  更新`formatName`的主体，使其返回`Mrs. ${first} ${last}`字符串，其中`first`和`last`是存储在输入参数`first`和`last`中的值。

1.  更新对`getOlder`函数的调用，并将`person.age`作为参数传入。将返回的值保存到`person.age`中。

1.  更新对`formatName`的函数调用，并将`person.firstName`和`person.lastName`作为参数传入。将返回的值保存到`person.name`中。

1.  运行代码并将输出与*步骤 2*的输出进行比较。它们应该是相同的。

**代码**

##### solution.js

```php
const person = { age: 10, firstName: 'Sandra', lastName: 'Jeffereys' };
function getOlder( age ) {
 return ++age;
}
function formatName( first, last ) {
 return 'Mrs. ${first} ${last}';
}
console.log( person );
person.age = getOlder( person.age );
person.name = formatName( person.firstName, person.lastName );
console.log( person );
```

https://bit.ly/2CZwyoC

**输出**

![图 5.5：最终输出](img/Figure_5.5.jpg)

###### 图 5.5：最终输出

您已成功地重构了代码以消除共享状态。

## 不可变性

不可变性是函数式编程中非常简单但非常重要的概念。**不可变性**的教科书定义只是“不可改变的”一词。在编程中，我们使用这个词来表示对象和变量在创建后不能改变其状态。

在软件开发中，值可以通过引用传递给函数。当变量通过引用传递时，意味着传递的是指向内存位置（指针）的引用，而不是内存中该位置包含的对象的序列化值。由于所有指向引用传递的变量的指针都指向同一块内存，对通过引用传递的变量值的任何更新都将被指向该内存块的任何指针看到。任何通过引用传递而不是通过值传递的变量都可以被视为共享状态，因为它可以被多个独立作用域修改。编写防止数据突变的函数非常重要，因为对通过引用传递的值的任何更改都将被视为对共享状态的更改。修改通过引用传递的变量将违反函数式编程的原则，并导致副作用。

在 JavaScript 中，不可变性的概念通常适用于传入函数的变量，以及函数返回的变量。在 JavaScript 中，简单类型（字符串、数字、布尔值）是按值传递的，而复杂类型（对象、数组等）是按引用传递的。对这些复杂数据类型的任何更改都会影响所有出现的地方，因为它们本质上只是指向同一块内存的指针。

JavaScript 对不可变性的支持并不完整。JavaScript 没有内置的不可变数组或对象。需要注意的是，变量创建关键字`const`不会创建不可变对象或数组。正如在第一章中讨论的那样，const 只是锁定名称绑定，使得名称绑定不能被重新分配。它不会阻止被变量引用的对象被修改。在 JavaScript 中，可以通过两种方式创建不可变对象：使用`freeze`函数和使用第三方库。

不可变对象可以使用 freeze 函数创建。`freeze`是全局`Object prototype ( Object.freeze()` )上的一个函数。它接受一个参数，即要冻结的对象，并返回相同的对象。freeze 防止向对象中添加、删除或修改任何内容。如果一个数组被冻结，它将锁定元素的值，并防止向数组中添加或删除元素。需要注意的是，freeze 函数只是浅冻结。作为属性（在对象中）或元素（在数组中）嵌套的对象和数组不会被`freeze`函数冻结。如果要完全冻结所有嵌套属性，必须编写一个辅助函数来遍历对象或数组树，冻结每个嵌套级别，或者找到一个第三方库。`Object.freeze()`的使用如下所示：

```php
const data  = {
  prop1: 'value1',
  objectProp: { p1: 'v1', p2: 'v2' },
  arrayProp: [ 1, 'test' , { p1: 'v1' }, [ 1, 2, 3 ] ]
};
Object.freeze( data );
Object.freeze( data.objectProp );
Object.freeze( data.arrayProp );
Object.freeze( data.arrayProp[2] );
Object.freeze( data.arrayProp[3] );
```

###### 片段 5.8：冻结一个对象

### JavaScript 中的不可变性

存在几个第三方库可以为 JavaScript 添加不可变功能。有两个库通常被认为是 JavaScript 中最好的不可变性库。它们是**Mori**和**Immutable**。Mori 是一个将 ClojurScript 的持久数据结构和不可变性引入 JavaScript 的库。**Immutable**是 Facebook 的不可变性库的实现，具有 JS API，将许多不可变数据结构引入 JavaScript。这两个库被认为非常高效，并且在许多大型项目中通常被使用。

#### 注意

有关 Mori 和 Immutable 的更多信息，以及完整的文档，请参阅[`github.com/swannodette/mori`](https://github.com/swannodette/mori)和[`facebook.github.io/immutable-js/`](http://facebook.github.io/immutable-js/)上的库页面。

在 JavaScript 中有一种最终实现不可变性的方法；然而，这并不是真正的不可变性。为了避免使用第三方库或冻结传递给函数的任何对象或数组，我们可以简单地创建传递引用的任何变量的副本，并修改副本而不是原始值。这将防止通过引用传递数据的共享状态问题，但它会带来内存效率和效率的折衷。简单地将引用分配给一个新变量不会复制数据。我们可以通过三种方式之一复制对象或数组——使用第三方库，通过遍历对象树，或者使用 JSON 操作。

存在用于创建对象的深层副本的第三方库。这通常是复制对象的最简单方法。我们还可以遍历对象的树，并将每个值和属性复制到一个新对象中。这通常需要我们编写和测试自己的函数。最后，我们可以使用 JSON 操作 stringify 和 parse 来复制一个对象。首先将对象字符串化，然后解析字符串（`JSON.parse（JSON.stringify（obj））`）。JSON 操作通常是复制对象的最简单方法，但它带来了最多的缺点和限制。如果对象具有不兼容 JSON 的属性，例如函数或类，这种方法将无效。将整个对象转换为字符串，然后将整个字符串解析为对象也非常低效。对于小对象，这可能不会影响性能，但如果您必须复制一个大对象，则不建议使用此方法，因为它是一个阻塞操作。

## 副作用

**副作用**是我们采取行动后产生的任何次要效果或反应。副作用可以是好的也可以是坏的，但通常是无意的。在函数式编程中，副作用是指除函数返回值之外可以在函数调用之外看到的任何状态更改。根据函数式编程的规则，函数不允许修改函数之外的任何状态。如果函数有意或无意地修改了状态，这被视为副作用，因为它违反了函数式编程的原则。

副作用是不好的，因为它使程序变得更加复杂。正如前面讨论的，共享状态会增加程序的复杂性。函数中的副作用会修改共享状态，因此增加了复杂性。无论有意还是无意，副作用都会使代码更难以测试和调试。以下列表显示了 JavaScript 中副作用最常见的原因的简单分解：

+   修改任何外部状态（变量）

两种变量类型包括全局变量和父函数作用域中的变量。

这个列表中的第一条应该从 FP 副作用的定义中是不言自明的。对任何外部状态的改变，包括函数范围之外的任何变量，都是副作用。变量的作用域级别并不重要。它可以在全局作用域中，也可以在父函数作用域树中的任何地方；对函数范围之外的变量的任何改变都被视为副作用。

+   输入/输出

列表包括记录到控制台，写入屏幕或显示器，文件 I/O 操作，网络操作，HTTP 请求，消息队列和数据库请求。

副作用列表中的第二个要点并不那么直观。考虑一下 I/O 操作。它们做什么？它们修改一些外部资源。这可以是控制台的内容，网页上显示的视图或显示，文件系统中的文件，或者仅通过网络访问的外部资源。这些外部资源不直接限定于修改它们的代码块，并且可以被其他完全无关的应用程序修改和查看。根据定义，文件系统和控制台等资源是共享状态。对这些资源的修改算作副作用。

+   启动或结束外部进程

副作用列表中的第三个要点与第二个类似。启动外部进程，例如辅助线程以卸载一些大量的同步工作，会产生副作用。当我们启动一个新进程时，我们直接改变了系统的状态。创建了一个新线程，它超出了创建它的函数的范围。根据定义，这是一个副作用。

+   调用任何具有副作用的其他函数

副作用列表中的第四项也不那么直观。调用具有副作用的函数的任何函数都被认为具有副作用。考虑一个程序设置，其中函数 A 调用函数 B，并且函数 B 导致全局状态的更改。对全局状态的更改可以由对函数 B 的直接调用或通过调用函数 A 而引起。由于对函数 A 的调用仍然会导致全局状态的更改，即使函数 A 的代码不直接修改全局状态，函数 A 仍然被认为具有副作用。

在编写 FP 代码时，我们必须考虑以下问题：

如果任何 I/O 操作引起副作用，我们如何将 FP 原则应用于编写没有副作用的有用代码？由于 I/O 操作会引起副作用，那么我们代码中使用的每个网络调用或文件系统操作都会引起副作用吗？是的。 I/O 引起副作用，它们是不可避免的。解决此问题的方法是将具有副作用的代码与软件的其余部分隔离开来。任何具有副作用或依赖具有副作用的模块或操作（数据库操作等）的代码必须与不具有副作用的代码隔离开来。这通常是通过模块完成的。大多数前端和后端框架鼓励我们使用模块将状态管理与代码的其余部分分离。引起副作用的代码被移除并放入自己的模块中，以便代码库的其余部分可以在没有副作用的情况下进行测试和维护。

### 避免副作用

几乎不可能编写一个没有副作用的完整应用程序。Web 应用程序/服务器必须处理/发出 HTTP 请求-根据定义是副作用。为了实现这一点，您可以执行以下操作：

+   将具有副作用的代码与代码库的其余部分隔离。

+   将状态管理代码和具有副作用的代码与应用程序的其余部分分开。

这些方法使测试和调试更容易。

## 函数组合

**函数组合**是理解函数式编程的最后关键。函数组合将本章学到的许多概念很好地融入到函数式编程的核心中。函数组合的广泛使用定义是函数组合是一个数学概念，允许您组合多个函数以创建一个新函数。这个定义告诉我们函数组合是什么，但并没有真正告诉我们如何组合函数或者为什么我们需要使用它。

根据定义，函数组合是将函数组合在一起创建新函数的行为。这到底意味着什么？在数学中，我们经常看到像这样组合的函数：f(g(x))。如果这对你来说不熟悉，在表达式 f(g(x))中，我们将变量 x 传递给函数 g，然后将 g(x)的结果传递给函数 f。表达式 f(g(x))从内到外，从右到左，按顺序 x，g，f 进行评估。在函数 g 中使用输入参数的每个实例，我们可以替换为 x 的值。在函数 f 中使用输入参数的每个实例，我们可以替换为 g(x)的值。现在，让我们用代码考虑这种函数组合的方法。考虑以下代码片段：

```php
function multiplyBy2( c ) {
 return 2 * c;
}
function sumNumbers( a, b ) {
 return a + b;
}
const v1 = sumNumbers( 2, 4 ); // 2 + 4 = 6
const v2 = multiplyBy2( v2 ); // 2 * 6 = 12
const v3 = multiplyBy2( sumNumbers( 2, 4 ) ); // 2 * ( 2 + 4 ) = 12
```

###### 代码段 5.10：函数组合

在上述代码片段中，我们创建了一个将值乘以 2 的函数和一个将两个数字相加的函数。我们可以使用这些函数以两种方式计算一个值。首先，我们独立使用这些函数，依次使用。这需要我们创建一个变量并保存第一个函数的输出，使用该值调用第二个函数，然后将第二个函数的结果保存到一个变量中。这需要两行代码和两个变量。我们计算值的第二个选项是使用函数组合。我们只需要在第二个函数的输入参数中调用一个函数，并保存结果变量。这只需要一行代码和一个变量。从代码片段中可以看出，使用函数组合将有助于简化我们的代码，并减少我们需要编写的代码行数。

函数组合非常有用，可以减少我们需要编写的代码行数，同时减少代码的复杂性。在函数式编程范式中编写代码时，重要的是要认识到我们可以利用函数组合的优势的情况。

### 活动 5：递归不可变性

您正在使用 JavaScript 构建应用程序，并且已被告知出于安全原因不能使用任何第三方库。现在，您必须为此应用程序使用 FP 原则，并且需要一种算法来创建不可变的对象和数组。创建一个递归函数，使用`Object.freeze()`来强制对象和数组在所有嵌套级别上的不可变性。为简单起见，您可以假设对象中没有嵌套的空值或类。在`'Lesson 5/topic f - immutability/activity-test.js'`中编写您的函数。此文件包含测试您实现的代码。

要强制对象的不可变性，请执行以下步骤：

1.  创建一个名为`immutable`的函数，它接受一个参数`data`。

1.  冻结`data`对象。

1.  循环遍历对象值，并对每个值递归调用不可变函数。

**代码**

**结果**

![图 5.6：返回新的购物车数组](img/Figure_5.6.jpg)

###### 图 5.6：返回新的购物车数组

您已成功演示了强制对象的不可变性。

#### 注意

此活动的解决方案可在第 291 页找到。

## 摘要

**函数式编程**是一种侧重于表达式和声明来设计应用程序和构建代码库的编程范式。函数式编程是炙手可热的新编程风格之一，被认为是 JavaScript 编程的最佳风格。函数式编程可以帮助我们的 JavaScript 更加简洁，可预测和可测试。函数式编程建立在七个关键概念上：声明式函数，纯函数，高阶函数，共享状态，不可变性，副作用和函数组合。

**声明性函数**关注的是解决方案或目标，而不是我们如何得到解决方案。声明性函数旨在抽象掉大量的命令式代码。它们帮助开发人员更符合开发者的思维模型，而不是运行代码的机器的操作模型。

**纯函数**旨在使我们的代码更易于测试、更易于调试，并且更灵活和可重用。我们在 JavaScript 中编写的所有函数都应该努力成为纯函数。纯函数在给定相同的输入值时必须始终返回相同的输出值。它们不能通过修改外部状态来引起任何副作用，并且必须具有引用透明性。

**高阶函数**是 JavaScript 异步编程中最常用的函数类型之一。高阶函数是任何以函数作为输入并返回函数作为输出的函数。高阶函数非常有用，可以用于抽象代码、减少复杂性以及创建和管理实用函数。它们是闭包的关键，允许我们对代码非常灵活。

**共享状态**是函数式编程中要避免的最重要的事情之一。共享状态是存在于共享作用域中的任何非常量变量或非不可变对象或内存空间。共享作用域可以是全局作用域或父函数作用域树中的任何作用域。共享状态会阻止函数成为纯函数，并可能导致更多的错误、不充分的测试和开发速度变慢。

不变性是无法改变某物的能力。在 JavaScript 中，所有按引用传递的变量都应该是不可变的。对可变变量的更改可能会导致副作用，并无意中修改不应共享的状态。在 JavaScript 中，可以通过`Object.freeze()`函数、第三方库和 JSON 操作来实现不可变性。

在 JavaScript 中，**副作用**是指可以从函数调用外部看到的任何状态更改，不包括函数的返回值。副作用可以由对共享状态变量的任何修改、任何 I/O 操作、任何外部进程执行或调用具有副作用的任何函数引起。要完全消除 JavaScript 应用程序中的副作用可能非常困难。为了最小化副作用的影响，我们必须将具有副作用的代码与代码库的其余部分隔离开来。引起副作用的代码应该移入模块以进行隔离。

**函数组合**是函数式编程的最后一个关键概念。我们可以通过以新的方式组合更简单的函数来简单地创建复杂而强大的函数。函数组合旨在帮助抽象和减少我们代码的复杂性。

在下一章中，您将介绍服务器端 JavaScript 的基本概念，并构建一个 Node.js 和 Express 服务器。
