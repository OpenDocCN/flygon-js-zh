# 第一章 典型的 JavaScript 项目

欢迎来到 JavaScript 中的领域驱动设计。在本书中，我们将探索一种开发具有高级业务逻辑的软件的实用方法。有许多策略可以保持开发流畅和代码和思想有组织，有建立在约定上的框架，有不同的软件范式，如面向对象和函数式编程，或者测试驱动开发等方法。所有这些部分都解决了问题，并且就像工具箱中的工具一样，帮助管理软件中不断增长的复杂性，但这也意味着今天在开始新项目时，甚至在我们开始之前就有很多决定要做。我们想要开发单页应用程序吗，我们想要紧密遵循框架的标准吗，还是我们想要自己设置？这些决定很重要，但它们也在很大程度上取决于应用程序的上下文，在大多数情况下，对这些问题的最佳答案是：“这取决于情况”。

那么，我们真的该如何开始呢？我们真的知道我们的问题是什么吗？如果我们理解了，这种理解是否与其他人的理解相匹配？开发人员很少是某个特定主题的领域专家。因此，当涉及指定系统应具有的行为时，开发过程需要来自业务领域专家的外部输入。当然，这不仅适用于从头开始开发的全新项目，也可以应用于在开发过程中添加到应用程序或产品中的任何新功能。因此，即使您的项目已经进展顺利，也会有一个时机，新功能似乎会拖慢整个项目，此时，您可能想考虑以替代方式来处理这个新功能。

领域驱动设计为我们提供了另一个有用的工具，特别是为了解决与其他开发人员、业务专家和产品所有者互动的需求。在现代，JavaScript 成为构建项目的更加有说服力的选择，特别是在基于浏览器的 Web 应用程序等许多情况下，它实际上是唯一可行的选择。如今，使用 JavaScript 设计软件的需求比以往任何时候都更加迫切。过去，更复杂的软件设计问题集中在后端或客户端应用程序开发上，随着 JavaScript 作为一种开发完整系统的语言的崛起，情况已经发生了变化。在浏览器中开发 JavaScript 客户端是开发整个应用程序的复杂部分，随着 Node.js 的崛起，开发服务器端 JavaScript 应用程序也是如此。在现代开发中，JavaScript 发挥着重要作用，因此需要像过去其他语言和框架一样在开发实践和流程中得到同等重视。基于浏览器的客户端应用程序通常包含与后端相同甚至更多的逻辑。随着这种变化，许多新问题和解决方案已经出现，首先是朝着更好地封装和模块化 JavaScript 项目的方向发展。新的框架已经出现并确立了自己作为许多项目的基础。最后但同样重要的是，JavaScript 已经从浏览器中的语言跃升到更多地移动到服务器端，通过 Node.js 或作为某些 NoSQL 数据库中的首选查询语言。让我带你走一遍开发软件的过程，带你通过使用领域驱动设计引入的概念以及它们如何被解释和应用来创建一个应用程序的各个阶段。

在本章中，您将学习：

+   领域驱动设计的核心理念

+   我们的业务场景——管理兽人地牢

+   跟踪业务逻辑

+   理解核心问题并选择正确的解决方案

+   学习什么是领域驱动设计

# 领域驱动设计的核心思想

有许多软件开发方法论，各有优缺点，但都有一个核心思想，就是要应用和理解以正确地使用该方法论。对于领域驱动设计，核心在于意识到，由于我们不是软件所处领域的专家，我们需要从其他专家那里收集意见。这意识意味着我们需要优化我们的开发过程来收集和整合这些意见。

那么，这对 JavaScript 意味着什么？当考虑在浏览器应用程序中向消费者公开某种功能时，我们需要考虑许多事情，例如：

+   用户期望应用程序在浏览器中的行为是什么？

+   业务工作流程是如何工作的？

+   用户对工作流程了解多少？

这三个问题已经涉及到三种不同类型的专家：擅长用户体验的人可以帮助解决第一个问题，业务领域专家可以解决第二个问题，第三个人可以研究目标受众并提供最后一个问题的意见。将所有这些整合在一起是我们试图实现的目标。

虽然不同类型的人很重要，但核心思想是让他们参与的过程总是相同的。我们提供了一种共同的方式来谈论这个过程，并为他们建立了一个快速的反馈循环进行审查。在 JavaScript 中，这可能比大多数其他语言更容易，因为它是在浏览器中运行的，可以随时进行修改和原型设计；这是 Java 企业应用程序所梦寐以求的优势。我们可以与用户体验设计师密切合作，调整预期的界面，同时动态地改变工作流程以适应我们的业务需求，首先在浏览器的前端，然后将知识从原型移至后端，如果有必要的话。

# 管理兽人地牢

谈到领域驱动设计时，通常是在处理复杂的业务逻辑的情境下。事实上，大多数软件开发实践在处理非常小的、简化的问题时并不真正有用。就像使用任何工具一样，你需要清楚什么时候是使用它的正确时机。那么，什么才真正属于复杂的业务逻辑领域？这意味着软件必须描述一个现实世界的场景，通常涉及人类的思考和互动。

编写处理决策的软件，90%的时间按某种方式进行，10%的时间按其他方式进行，这在向不熟悉软件的人解释时尤其困难。这些决策是许多业务问题的核心，但尽管这是一个有趣的问题要解决，但跟踪下一个会计软件的开发并不是一个有趣的阅读。考虑到这一点，我想向你介绍我们正在尝试解决的问题，即管理地牢。

![管理兽人地牢](img/B03704_01_01.jpg)

一位兽人

## 地牢内部

从外部看，管理兽人地牢似乎很简单，但实际上管理起来并不容易。因此，我们受到一位兽人大师的联系，他苦于保持地牢的顺利运行。当我们到达地牢时，他向我们解释了实际运作方式和涉及的因素。

### 提示

即使是**全新**的项目通常也有一些现状是有效的。这一点很重要，因为这意味着我们不必提出功能集，而是匹配当前现实的功能集。

许多外部因素起着作用，地牢并不像它希望的那样独立。毕竟，它是兽人王国的一部分，国王要求他的地牢给他赚钱。然而，金钱只是交易的一部分。它实际上如何赚钱呢？囚犯需要采矿金子，为此需要在地牢中保留一定数量的囚犯。兽人王国的运行方式也导致不断有新囚犯到来，来自战争的新俘虏，那些无法支付税款的人等等。总是需要为新囚犯腾出空间。好消息是每个地牢都是相互连接的，为了实现其目标，它可以依靠其他地牢，通过请求囚犯转移来填满空牢房或摆脱自己牢房中的囚犯。这些选择使地牢主能够密切关注囚犯的保留和牢房空间的数量。根据需要将囚犯送往其他地牢，并向其他地牢请求新的囚犯，以防有太多的空牢房空间，可以使采矿劳工保持在最佳水平，以最大化利润，同时准备好接收直接被送到地牢的高价值囚犯。到目前为止，解释是合理的，但让我们深入一点，看看发生了什么。

### 管理进来的囚犯

囚犯可能因为一些原因到达，比如如果一个地牢已经满了，决定将一些囚犯转移到有空牢房的地牢，除非他们在途中逃跑，他们最终会在我们的地牢里到达。另一个囚犯来源是不断扩张的兽人王国本身。兽人将不断奴役新的人民，对我们的国王说“抱歉，我们没有空间”并不是一个有效的选择，这实际上可能导致我们成为新的囚犯之一。看到这一点，我们的地牢最终会填满，但我们需要确保这不会发生。

处理这个问题的方法是提前转移囚犯以腾出空间。这显然是最复杂的事情；我们需要权衡几个因素来决定何时以及转移多少囚犯。我们不能简单地通过阈值来解决这个问题的原因是，从地牢结构来看，这不是我们可以失去囚犯的唯一方式。毕竟，人们并不总是愿意成为采金矿的奴隶，他们可能会决定在逃跑时死亡的风险和在监狱中死亡的风险一样高，因此他们决定逃跑。

囚犯在不同地牢之间移动时也是如此，而且并不罕见。因此，即使我们在物理牢房上有一个硬性限制，我们仍需要处理进出囚犯的软性数量。这是商业软件中的一个经典问题。将这些数字相互匹配并优化特定结果基本上就是计算机数据分析的全部内容。

### 现状

考虑到所有这些，很明显兽人大师目前通过一张糟糕的餐巾纸上的笔记来跟踪的系统并不完美。事实上，这几乎已经让他多次险些丧命。举个例子，他讲述了一次国王抓住了四个氏族领袖并想让他们成为矿工，只是为了羞辱他们。然而，当到达地牢时，他意识到没有空间，不得不前往下一个地牢把他们放下，而他们则嘲笑他，因为显然他不知道如何管理王国。这是因为我们的兽人大师忘记了前一天到达的八名转移者。还有一次，兽人大师在国王的治安官到来时无法交付任何黄金，因为他不知道他只有三分之一所需囚犯才能挖掘任何东西。这次是因为有多人统计囚犯，而不是逐个单元格记录，他们实际上试图在脑海中做。虽然是兽人，但这是失败的设置。所有这些都归结为糟糕的组织，而将管理地牢囚犯的*系统*画在餐巾纸的背面当然也符合这样的标准。

### 数字地牢管理

在最近的失败案例的指导下，兽人大师终于意识到是时候进入现代化了，他希望通过数字化一切来革新管理地牢的方式。他努力要有一个系统，可以通过自动计算当前填充的单元格数量来简化管理繁琐的工作。他希望只需坐下来，放松，让计算机为他做所有的工作。

### 提示

与业务专家讨论软件时的一个常见模式是，他们不知道可以做什么。永远记住，我们作为开发者是软件专家，因此是唯一能够管理这些期望的人。

现在是时候考虑我们需要了解的细节以及如何处理不同的情况了。兽人大师并不真正熟悉软件开发的概念，所以我们需要确保用他能理解的语言交谈，同时确保我们得到所有需要的答案。我们被聘用是因为我们在软件开发方面的专业知识，所以我们需要确保管理期望以及功能集和开发流程。开发本身当然会是一个迭代的过程，因为我们不能指望一次性就得到所有需要的清单。这也意味着我们需要考虑可能的变化。这是构建复杂商业软件的重要部分。

开发包含更复杂业务逻辑的软件很容易迅速变化，因为业务正在调整自己，用户正在利用软件提供的功能。因此，保持业务理解者和软件开发者之间的共同语言是至关重要的。

### 提示

尽可能地融入业务术语，这将有助于业务领域专家和开发者之间的沟通，从而在早期防止误解。

## 规格

要了解软件需要做什么，至少要有用的最好方式是了解在你的软件存在之前未来用户在做什么。因此，我们与兽人大师坐下来，看他是如何管理进出囚犯的，并让他向我们介绍他日常工作。

地牢由 100 个单元格组成，目前每个单元格要么被囚犯占据，要么为空。在管理这些单元格时，我们可以通过观察兽人的工作来确定不同的任务。根据我们所见，我们可以大致将其勾画如下：

![规格](img/B03704_01_02.jpg)

有一些重要的组织事件和状态需要跟踪，它们是：

1.  当前可用或空闲单元

1.  外传输状态

1.  传入传输状态

每次传输都可能处于多种状态，主控必须了解这些状态，以便进一步决定下一步该做什么。保持这样的世界观并不容易，尤其要考虑到同时发生的并发更新的数量。跟踪一切的状态会导致我们的主控有更多的任务要做：

1.  更新跟踪

1.  当太多的单元被占用时开始进行外传输

1.  通过开始跟踪来响应传入传输

1.  如果占用单元太少，要求传入传输

那么，每个任务都包括什么呢？

### 跟踪可用单元

地牢的当前状态由其单元的状态反映，因此第一个任务是获得这种知识。在其基本形式中，这很容易实现，只需计算每个占用和每个空闲单元，写下这些值。现在，我们的兽人主控在早上巡视地牢，记录每个空闲单元，假设另一个单元必定被占用。为了确保他不陷入麻烦，他不再相信他的下属能够做到！问题在于只有一个中央表来跟踪一切，所以如果有多人计算和记录单元，他的看守人可能会意外地覆盖彼此的信息。此外，这是一个很好的开始，目前已经足够了，尽管它缺少一些有趣的信息，例如逃离地牢的囚犯数量以及根据这一速率预期的空闲单元数量。对我们来说，这意味着我们需要能够在应用程序内跟踪这些信息，因为最终我们希望根据地牢的状态来预测预期的空闲单元数量，以便我们可以有效地根据地牢的状态创建建议或警告。

### 开始外传输

第二部分是实际处理在地牢填满囚犯的情况下如何处理。在这种具体情况下，这意味着如果空闲单元的数量低于 10，是时候移出囚犯了，因为随时可能会有新的囚犯到来。这种策略非常可靠，因为根据经验，几乎没有更大的运输，所以建议一开始就坚持这种策略。然而，我们已经看到一些目前过于复杂的优化。

### 提示

从业务经验中汲取经验是重要的，因为可以对这种知识进行编码并减少错误，但要注意，因为编码详细的经验可能是最复杂的事情之一。

在未来，我们希望根据逃离地牢的囚犯数量、因被捕获而到达的新囚犯以及来自传输的新到达的预期来优化这一点。目前这是不可能的，因为它只会压垮当前的跟踪系统，但实际上这归结为尽可能多地捕获数据并进行分析，这是现代计算机系统擅长的事情。毕竟，这可能会挽救兽人主控的脑袋！

### 跟踪传入传输的状态

有些日子，一只乌鸦会带来消息，说有些囚犯已经被送去转移到我们的地牢。我们实际上无能为力，但协议是在囚犯实际到达之前的五天发送乌鸦，给地牢一个准备的机会。如果囚犯在途中逃跑，将会发送另一只乌鸦通知地牢这尴尬的情况。这些消息每天都要筛选一遍，以确保实际上有足够的空间来容纳到达的囚犯。这是预测填充单元数量的一个重要部分，也是最不稳定的部分，我们被告知。重要的是要注意，每条消息只能处理一次，但它可以在任何时候到达。目前，它们都由一个兽人处理，他在记录内容结果后立即将它们扔掉。当前系统的一个问题是，由于其他地牢的管理方式与我们目前的方式相同，当它们陷入麻烦时，它们会迅速进行大规模的转移，这使得情况变得相当不可预测。

### 启动传入转移

除了让囚犯呆在他们应该呆的地方，挖掘黄金是地牢的第二个主要目标。为了做到这一点，需要有一定数量的囚犯来操作机器，否则生产基本上会停止。这意味着每当太多的单元被放弃时，就是填充它们的时候，因此兽人头目会派一只乌鸦请求新的囚犯。这再次需要五天时间，除非他们在途中逃跑，否则是可靠的。过去，由于长时间的延迟，这仍然是地牢的一个主要问题。如果填充的单元数量低于 50，地牢将不再生产任何黄金，而不赚钱是替换当前地牢主的原因。如果兽人头目所做的只是对情况做出反应，这意味着可能会有大约五天时间没有黄金被挖掘。这是当前系统的一个主要痛点，因为预测五天后填充单元数量似乎是不可能的，所以目前所有兽人能做的就是做出反应。

总的来说，这给了我们一个大致的想法，地牢主在寻找什么，以及需要完成哪些任务来替换当前系统。当然，这不必一次完成，而可以逐渐进行，以便每个人都能适应。目前，是时候确定从哪里开始了。

# 从零开始到应用程序

我们是 JavaScript 开发者，所以对我们来说构建一个 Web 应用程序来实现这一点似乎是显而易见的。根据问题的描述，很明显，从简单开始，随着我们进一步分析情况，逐渐扩展应用程序显然是正确的方式。目前，我们并不真正了解一些部分应该如何处理，因为业务流程尚未发展到这个水平。此外，随着我们的软件开始被使用，可能会出现新的功能或处理方式开始有所不同。所描述的步骤留有根据收集到的数据进行优化的空间，因此我们首先需要数据来看预测如何工作。这意味着我们需要从追踪尽可能多的事件开始。按照清单，第一步始终是了解我们所处的状态，这意味着追踪可用单元并为此提供一个接口。起初，可以通过计数器来完成，但这不能是我们的最终解决方案。因此，我们需要朝着追踪事件并对其进行汇总以便能够对未来进行预测。

## 第一条路线和模型

当然，有许多其他开始的方式，但在大多数情况下，最重要的是现在是选择构建的基础的时候了。我的意思是决定构建在哪个框架或一组库上。这与决定使用哪个数据库来支持我们的应用程序以及许多其他小决定同时进行，这些小决定受到框架和库的影响。对前端应该如何构建有清晰的理解也很重要，因为构建单页应用程序，在前端实现大量逻辑，并由与在服务器端实现大部分逻辑有很大不同的 API 层支持的应用程序，与构建大量逻辑的应用程序有很大不同。

### 提示

如果您对 express 或以下使用的任何其他技术不熟悉，不要担心。您不需要理解每一个细节，但您会了解如何使用框架开发应用程序的想法。

由于我们还没有明确了解应用程序最终会采取的方式，我们试图尽可能推迟尽可能多的决定，但决定我们立即需要的东西。由于我们在 JavaScript 中开发，应用程序将在 Node.js 中开发，express 将是我们选择的框架。为了使我们的生活更轻松，我们首先决定我们将使用纯 HTML 来实现前端，使用 EJS 嵌入式 JavaScript 模板，因为这将使逻辑集中在一个地方。这似乎是合理的，因为将复杂应用程序的逻辑分散在多个层中将进一步复杂化事情。此外，在传输过程中摆脱最终的错误将使我们更容易朝着一个坚实的应用程序迈进。我们可以推迟关于数据库的决定，并使用存储在 RAM 中的简单对象来处理我们的第一个原型；当然，这不是长期的解决方案，但至少我们可以在需要决定另一个重要软件之前验证一些结构，这也带来了很多期望。考虑到所有这些，我们设置了应用程序。

在接下来的章节和整本书中，我们将使用 Node.js 构建一个小型后端。在撰写本文时，当前活跃的版本是 Node.js 0.10.33。Node.js 可以从[`nodejs.org/`](http://nodejs.org/)获取，并且适用于 Windows、Mac OS X 和 Linux。我们的 Web 应用程序的基础由 express 提供，目前版本为 3.0.3，可通过**Node Package Manager** (**NPM**)获取：

```js
**$ npm install –g express**
**$ express --ejs inmatr**

```

### 提示

为了简洁起见，以下的粘合代码被省略了，但像书中呈现的所有其他代码一样，该代码可以在 GitHub 存储库[`github.com/sideshowcoder/ddd-js-sample-code`](https://github.com/sideshowcoder/ddd-js-sample-code)上找到。

### 创建模型

现在应用程序的最基本部分已经设置好了。我们可以继续创建我们的地牢模型在`models`/`dungeon.js`中，并添加以下代码以保持模型及其加载和保存逻辑：

```js
var Dungeon = function(cells) {
  this.cells = cells
  this.bookedCells = 0
}
```

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)账户购买的所有 Packt 图书中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

请记住，这将最终存储在数据库中，我们还需要以某种方式找到一个地牢，因此`find`方法似乎是合理的。这个方法应该已经遵循了 Node.js 的回调风格，以便在切换到真正的数据库时更容易。尽管我们推迟了这个决定，但假设是明确的，因为即使我们决定不使用数据库，地牢引用也将在将来存储并从进程外部请求。以下是一个使用`find`方法的示例：

```js
var dungeons = {}
**Dungeon.find = function(id, callback) {**
  if(!dungeons[id]) {
    dungeons[id] = new Dungeon(100)
  }
  callback(null, dungeons[id])
}
```

### 第一个路由和加载地牢

现在我们已经做好了这些，我们可以继续实际响应请求。在 express 中定义所需的路由来做到这一点。由于我们需要确保我们当前的地牢可用，当请求到达时，我们还使用中间件来加载它。

使用我们刚刚创建的方法，我们可以向 express 堆栈添加一个中间件，以便在请求到达时加载地牢。

中间件是一段代码，每当请求到达其堆栈级别时就会执行，例如，用于将请求分派到定义的函数的路由器被实现为中间件，日志记录也是如此。这也是许多其他类型的交互的常见模式，比如用户登录。我们的地牢加载中间件看起来像这样，假设现在我们只管理一个地牢，我们可以通过在`middleware/load_context.js`中添加以下代码来创建它：

```js
function(req, res, next) {
  req.context = req.context || {}
  Dungeon.find('main', function(err, dungeon) {
    req.context.dungeon = dungeon
    next()
  })
}
```

### 显示页面

有了这个，我们现在能够简单地显示有关地牢的信息，并在请求内跟踪对其所做的任何更改。创建一个视图来呈现状态，以及一个用于修改状态的表单，是我们 GUI 的基本部分。由于我们决定在服务器端实现逻辑，它们相当简单。在`views`/`index.ejs`下创建一个视图可以让我们稍后通过 express 将所有内容呈现到浏览器。以下示例是前端的 HTML 代码：

```js
<h1>Inmatr</h1>
<p>You currently have <%= dungeon.free %> of
<%= dungeon.cells %> cells available.</p>

<form action="/cells/book" method="post">
  <select name="cells">
    <% for(var i = 1; i < 11; i++) { %>
    <option value="<%= i %>"><%= i %></option>
  <% } %>
  </select>
  <button type="submit" name="book" value="book">
  Book cells</button>
  <button type="submit" name="free" value="free">
  Free cells</button>
</form>
```

### 通过 express 将应用程序粘合在一起

现在我们几乎完成了，我们有一个显示状态的页面，一个用于跟踪变化的模型，以及一个根据需要加载此模型的中间件。现在，为了将所有这些粘合在一起，我们将使用 express 注册我们的路由并调用必要的函数。我们主要需要两个路由：一个用于显示页面，一个用于接受和处理表单输入。当用户访问首页时，显示页面已经完成，所以我们需要绑定到根路径。接受表单输入已经在表单本身中声明为`/cells/book`。我们只需为其创建一个路由。在 express 中，我们根据主应用程序对象定义路由，并根据 HTTP 动词定义如下：

```js
app.get('/', routes.index)
app.post('/cells/book', routes.cells.book)
```

将此添加到主`app.js`文件中允许 express 连接各种东西，路由本身实现如下在 routes/`index.js`文件中：

```js
var routes = {
  index: function(req, res){
    res.render('index', req.context)
  },

cells: {
  book: function(req, res){
    var dungeon = req.context.dungeon
    var cells = parseInt(req.body.cells)
    if (req.body.book) {
    dungeon.book(cells)
  } else {
    dungeon.unbook(cells)
  }

      res.redirect('/')
    }
  }
}
```

完成了这些，我们有一个可以跟踪空闲和已使用单元的工作应用程序。

以下显示了跟踪系统的前端输出：

![通过 express 将应用程序粘合在一起](img/B03704_01_03.jpg)

## 推动应用程序向前发展

这只是朝着希望自动化目前手工完成的应用程序的第一步。有了第一步，现在是时候确保我们可以推动应用程序了。我们必须考虑这个应用程序应该做什么，并确定下一步。在向业务展示当前状态后，下一个请求很可能是要集成某种登录，因为如果没有授权，将无法修改地牢的状态。由于这是一个 Web 应用程序，大多数人都熟悉它们有登录功能。这将使我们进入一个复杂的空间，我们需要开始指定应用程序中的角色以及它们的访问模式；因此目前还不清楚这是否是正确的方法。

另一种方法是开始将应用程序转向跟踪事件，而不是纯粹的空闲单元格数量。从开发者的角度来看，这可能是最有趣的路线，但立即的业务价值可能很难证明，因为没有登录似乎是不可用的。我们需要创建一个记录事件的端点，比如逃跑的囚犯，然后根据这些跟踪的事件修改地牢的状态。这是基于这样一个假设，即应用程序的最高价值将在于对囚犯移动的预测。当我们想以这种方式跟踪空闲单元格时，我们将需要修改我们的应用程序的第一个版本的工作方式。关于需要创建哪些事件的逻辑将不得不移动到某个地方，最合理的是前端，地牢将不再是地牢状态的唯一真相来源。相反，它将成为状态的聚合器，通过事件的生成进行修改。

以这种方式思考应用程序使一些事情变得清晰。我们并不完全确定应用程序的最终价值主张是什么。这将使我们走上一条危险的道路，因为我们现在做出的设计决策将影响我们如何在应用程序内构建新功能。如果我们关于主要价值主张的假设最终是错误的，这也是一个问题。在这种情况下，我们可能已经构建了一个相当复杂的事件跟踪系统，它并没有真正解决问题，而是使事情变得复杂。每个状态修改都需要转换为一系列事件，而对对象的简单状态更新可能已经足够了。这种设计不仅不能解决真正的问题，而且向兽人大师解释起来也很困难。某些抽象缺失，沟通也没有遵循作为业务语言建立的模式。我们需要一种替代方法来让业务更加参与。此外，我们需要保持开发简单，使用业务逻辑上的抽象，而不是技术上的抽象，这些技术由所使用的框架提供。

# 再次审视问题

到目前为止，我们一直从网页开发者的角度看待应用程序。这是一个经典的例子，*当你手中只有一把锤子，一切看起来都像钉子*。我们真的已经解决了核心问题吗？我们还没有问过哪些问题？这些是我们需要问自己的重要问题。此外，我们需要弄清楚我们可以向业务专家提出什么问题，以更好地了解如何前进。我们之前做了什么假设，以及为什么？

### 提示

使用合适的工具来解决问题也延伸到我们所做的抽象。当你已经知道*解决方案*是一个网页应用程序时，解决问题并不总是有帮助的。

## 另一个思考 MVC 网页应用程序的角度

到目前为止，我们一直在以**模型-视图-控制器**（**MVC**）的方式思考问题，这是一个网页应用程序。这带来了一定的假设，可能在我们的业务领域并不成立。创建一个用于管理输入和输出的网页界面确实通常处理应用程序的呈现，但这并不意味着这部分也包含主要的逻辑。在我们的地牢管理器的情况下，这可能只是访问和输入数据的一种方式。以这种方式构建的信息系统具有包含逻辑和数据的模型。这些模型由数据库支持，负责持久性，并且还用于通过对数据的约束来实现一些逻辑。这意味着我们的领域被压缩成了，很可能是关系型的，数据库模型。

所有这些将我们锁定在一定的技术集合中：用于托管我们的应用程序的 Web 服务器，用于持久性的数据库，以及用于访问和输入的 Web 层。所有这些元素都成为我们应用程序的组成部分，并使变更变得困难。此外，模型层除了由一堆模型组成之外，并没有真正的抽象。当我们想要表示更复杂的交互时，这可能不够。要明确的是，只要开发的应用程序主要由系统之间的交互组成，这并没有真正的问题，但是当价值主张主要是要在系统的各个部分之间表示业务逻辑时，这种设计就不再足够了。

## 理解核心问题

在业务应用的情况下，许多问题及其解决方案通常并不明确。这对许多领域都是如此，大多数开发人员可能熟悉的一个例子是设置 Web 服务器。当询问开发人员或管理员要实现这一目标时，描述的步骤通常只有几步，例如：设置操作系统，安装**Apache**，配置站点，然后启动。对于另一个开发人员或系统管理员来说，这可能足够了解要做什么，但对于外部人员，甚至更糟糕的是对于计算机来说，这几乎无法复制。

明确所有步骤对于了解核心业务领域的真正构成至关重要。在我们的情况下，我们需要确保跟随兽人大师目前所做的事情来保持他的地牢运行。这可以通过跟随他周围，或者让他向我们展示他的正常业务流程来完成。然而，我们不能依赖业务专家向我们详细解释流程。此外，我们也不能依赖我们对其理解与实际需要做的事情是否匹配。

因此，这项练习的主要目标是建立对正在发生的事情的理解基线，并提供一个共同的语言来讨论将不可避免地出现的问题。我们开始处于不确定的情况中。这不应该吓倒我们，而是我们需要将其视为增加自己理解的机会，有时甚至是增加当前执行人员的理解。通常，当质疑达到目标的所有步骤时，业务专家会意识到他们领域的新细节，他们甚至可能会识别可能的问题。

### 提示

找出对业务流程理解存在差距的地方是正确实施的关键。

在实施业务流程的情况下，我们可以假设现状是我们需要复制以替换业务目前正在使用的工具的最低要求。因此，首先，我们需要重建或整合业务目前正在使用的所有工具。当我们对问题有了牢固的把握后，我们可以找到优化有意义且可能的地方。我们还应该逐步替换一个接一个的流程，而不是一次性进行大规模切换，因为这样可以最大程度地减少业务风险。

## 沟通是关键

|   | *计算机科学中只有两件难事：缓存失效和命名事物。* |   |
| --- | --- | --- |
|   | --*菲尔·卡尔顿* |

在应用程序中工作时，往往很难在开发人员、产品所有者以及业务人员之间创建共享语言。通常有人说，命名事物是计算机科学中最困难的问题之一，有一个描述性的名称确实会让很多事情变得更容易。通常情况下，一个明确定义的对象更容易扩展，因为它的范围已经由它的名称定义。因此，在面向对象设计中，通常不鼓励使用一般性词语来命名事物，比如*Manager*、*Creator*或*Processor*。在考虑这个问题时，我们发现在我们的业务领域中，我们可以并且应该尽可能多地重用已建立的业务语言。这一切都归结为沟通。我们作为开发人员是这个领域的新手，所以介绍我们的业务专家将已经有一个建立的语言来描述我们所缺少的领域中的问题。

当我们跟随业务专家的步伐时，我们应该花时间熟悉正在使用的特定语言。当我们开始编写代码时，这变得更加重要。我们将不断需要与领域专家核对，以考虑他们的理解，因此当我们使用业务语言来编码领域时，我们将更容易与周围的每个人交流，以更好地理解领域。这相当抽象，所以让我举个例子。考虑一下地牢的命名：

```js
function Dungeon(cells) {
  this.freeCells = cells
}
```

现在考虑我们想要记录囚犯数量的变化，并编写以下代码：

```js
var dungeon = new Dungeon(100)
dungeon.freeCells -= 5
dungeon.freeCells += 3
```

尽管这对开发人员来说是自然的，但它并没有使用任何特定于业务的语言。我们需要向非开发人员解释像`+=`这样的东西的含义，以使他们理解含义。另一方面，考虑使用以下方法对相同的逻辑进行编码：

```js
Dungeon.prototype.inPrison = function (number) {
  this.freeCells -= number
}

Dungeon.prototype.free = function (number) {
  this.freeCells += number
}
```

使用这些方法来表达相同的事物，看起来比以前更加领域特定。现在我们可以在领域的上下文中描述问题，代码如下：

```js
var dungeon = new Dungeon(100)
dungeon.inPrison(5)
dungeon.free(3)
```

现在即使对非开发人员来说，发生了什么也变得非常清晰，因此我们可以专注于讨论行为是否正确，而不是代码的细节。

# 领域驱动设计的概念。

在开发软件时，很容易陷入实施细节，而从未深入问题的本质。作为软件开发人员，我们的主要目标始终是为业务增加价值，为了实现这一目标，我们首先需要明确我们试图解决的问题是什么。这在计算机科学的历史上已经有过多种尝试。结构化编程为开发人员提供了一种将问题分解为片段的方法，面向对象则将这些片段附加到命名的事物上，从而进一步构建结构并更好地将含义与程序的各个部分关联起来。

领域驱动设计专注于在解决问题的过程中建立结构，并提供了正确的起点，以便开始每个利益相关者都可以参与的对话。语言在其中是一个重要部分，因为沟通是许多项目挣扎的领域，因为工程术语往往更具体，而业务语言则留下了解释的空间，让人和他或她的上下文来解决所谈论的问题。这两种形式的语言都有它们的位置，因为它们已经被证明是在特定场景中有效的沟通形式，但在这两者之间进行翻译往往是引入问题或错误的地方。为了帮助解决这些问题，领域驱动设计允许开发人员以多种形式对通信中的某些类型的对象进行分类，所有这些都将在本书中详细介绍：

+   值对象

+   实体

+   聚合

+   有界上下文

这些是具有一定意义并允许对业务流程中的对象进行分类的概念。有了这些，我们可以附加意义和模式。

## 这一切都是关于分心。

考虑创建程序的不同方式，结构化编程对我们今天的编程方式所做的主要改进是，程序员在项目上工作时，不必总是将整个项目记在脑中，以确保不重复功能或干扰程序的正常流程。这是通过将功能封装在可在其他部分重复使用的块中来实现的。接着，面向对象编程增加了进一步将功能封装在对象中的能力，将数据和函数作为一个逻辑单元放在一起。对于函数式编程也可以说类似的事情，它允许程序员将程序看作是由输入定义的函数流，因此可以组合成更大的单元。领域驱动设计现在在此基础上增加了一层，它增加了抽象来表达业务逻辑，并可以将其从外部交互中封装起来。在这种情况下，通过明确定义的 API 与外部世界进行交互的业务层就是这样做的。

在这些不同的实践中，有一件事在所有层面都闪耀出来，那就是消除分心的想法。在处理大型代码库或复杂问题时，你需要一次记住的东西越多，就越容易分心。这是**领域驱动设计**的一个重要观点，我们将在下一章中看到这是如何发挥作用的，当我们考虑如何从之前看到的规范转向我们可以继续使用的问题描述时。

## 专注于手头的问题

在很多情况下，陈述问题实际上并不明显。这就是为什么在业务专家和开发人员之间努力达成共识是如此重要的原因，双方都需要就他们对功能或软件的期望达成一致。允许开发人员清楚地告诉业务功能解决了什么问题，使开发人员能够更直接地专注于手头的问题并获得更直接的输入。类似于测试驱动或行为驱动开发的原则，清晰地陈述某个功能的意图对开发有很大帮助。在这个阶段，创建从*A*到*B*的路径，以及客观地陈述何时达到目标，是我们所追求的。这绝不意味着我们不需要不断确认目标是否仍然是需要不断与业务方确认的，但它使我们能够使这种沟通更加清晰。有了确定的语言，现在就不必再进行多个持续数小时且没有明确结果的会议了。

有了这一切，现在是时候深入领域驱动设计的本质了。在本书中，我们将把我们的兽人地牢带入 21 世纪，使其能够灵活地适应其业务需求。作为第一步，我们将坐下来看看经营这个地牢到底是什么，以及我们的新软件如何利用领域驱动设计的概念和思维方式增加价值。

# 进一步阅读

领域驱动设计，正如本章所述，主要由 Eric J. Evans 的书《领域驱动设计》描述。我建议每个读者都跟进他的描述，以更深入地了解领域驱动设计的思想，不仅限于本章所描述的更具体的主题。

# 总结

在本章中，我们经历了开始应用程序的步骤，因为大多数项目今天都是这样开始的，并将其与领域驱动设计开发方法进行了对比。我们了解了领域驱动设计的重点，即开发人员与项目中涉及的其他各方之间的沟通。

需要牢记的关键点是，在关注技术选择和其他开发相关问题之前，要着重关注应用程序的核心功能集，否则会从探索中减少资源。我们学到的另一个重要方面是如何收集使用规范。关键点在于获取关于当前工作如何完成以及应用程序如何帮助的知识，而不仅仅是询问潜在用户的规范。

下一章更深入地关注了收集关于应用程序使用、预期可用性的知识的过程，以及开始建立一种语言来帮助开发应用程序的团队、建立领域专家和开发人员之间的沟通过程。
