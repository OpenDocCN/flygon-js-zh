# 第三章：为面向领域驱动设计设置项目

到目前为止，我们一直专注于准备项目的先决条件。我们致力于为自己创建一个心智模型，并确认我们对领域的理解与我们的领域专家的理解相匹配。通过这样做，我们开始在所有参与者之间创建一个共享的语言，以便所有各方可以就项目进行沟通，同时避免大部分误解。有了这一切，我们能够确定项目的起点，现在我们知道从哪里开始，以及如何根据领域命名我们的对象，我们可以设置项目以适应这一点。罗伯特·C·马丁在他的演讲《架构的失落年代》中说：*架构是关于意图的*，架构不是为了自身而创建的，而是为了说明项目的内容，并清楚地表明下一个人需要覆盖的每个层次。在设置应用程序时，我们希望在每个层次上表达应用程序的内容，这包括文件和文件夹的组织层次，以及创建类和模块。

我们的主要目标与软件架构的目标一致，一般来说，我们的目标是不要过早做决定，并确保我们做出的决定尽可能自我解释。我们还没有决定任何框架或实际上任何技术，但随着我们推动应用程序的进展，现在是时候解决一些推迟的决定了，尽管我们希望尽可能保持开放以进行更改。

本章将讨论在创建灵活的项目设置时出现的挑战，这样可以使您的项目适应并实际上拥抱结构的变化。在整个设计过程中牢记这一点非常重要。我们不希望模块结构妨碍我们的重构，或者因为压倒性的类和文件层次结构而使我们的项目更加僵化。

在进行这项工作时，我们将在多个层次上处理结构：

+   文件和目录结构

+   项目结构

+   对象或类结构

+   应用程序结构与领域外部的交互

对象和类结构以及项目结构与我们决定如何设计应用程序密切相关。作为其中的一部分，测试被引入，因为它对我们如何设计我们的类和对象有最直接的影响。它还对我们的团队如何共同开展项目工作以及他们如何能够向业务专家展示结果产生影响，让他们探索当前项目的方式。

### 提示

随着 JavaScript 离开增强网站的领域，转向成为用于大型应用程序的语言，无论是在浏览器上还是在服务器上，对更复杂的架构的需求增加了，人们试图将目前用于 Java 或 C++后端应用程序的许多概念移植过来。通常，这实际上会引起更多问题，因为 JavaScript 是一种非常灵活的语言，有自己的组织方式和概念，尽管可能仍然缺少一些部分；模块是其中一个核心概念。构建 JavaScript 应用程序时，始终牢记自己使用的语言，并使用其特性和概念来处理项目；不要在每一步都与之对抗。

本章涵盖了项目的设置以及如何使其成为一种愉快的工作方式。您将了解以下内容：

+   项目文件结构以及在布局时要考虑的因素

+   不同形式的测试及其重要性

+   构建应用程序

+   六边形架构简介

# 按我们的看法构建项目

当一个新的开发人员投入一个项目时，他们总是会看到项目中文件和文件夹的布局。这也是我们在不断编辑项目时不断处理的组织元素，因此值得投入思考。仅仅看看文件和文件夹应该已经告诉你一些关于项目的信息；这是最高级别的组织，因此应该代表我们领域的一些最高级别的概念。

因此，首先，我们需要确保我们知道我们试图用这个结构解决什么问题。在这个层面上，有多个要点需要我们解决，并且它们将贯穿项目组织的每个部分；它们是：

+   易接近性

+   编辑的局部性

+   适应变化的能力

因此，让我们看看这些要点是关于什么，以及我们如何为每个要点进行优化。

## 易接近性

当一个新的开发人员加入一个项目，甚至当一个回到他们最近没有工作的项目时，都需要花时间了解事物的位置，也许更重要的是，了解事物未来应该放在哪里。这总是一个问题，因为它会减慢开发速度，或者当谈论一个开源项目时，它实际上可能会减慢采用和贡献。因此，我们显然希望尽可能使代码库易接近，但这意味着什么呢？对于不熟悉的工具和风格，存在主观的学习曲线，这很难提前估计每个开发人员的情况，但也存在一个更客观的学习曲线，与常见的做法、命名和已经建立的概念相关。那么我们如何从文件和文件夹级别使代码库易接近呢？

当我们开始时，我们需要看看里面有什么，因此导航的便利性是我们必须处理的第一件事。具有大量的子文件夹，只有视图文件，或者有时甚至没有文件，都是使项目难以导航的例子。有些人可能会说，你正在使用的编辑器应该解决这个问题，但这也是我们为自己创造的问题，因此我们应该避免这样做。

有更多的方法可以使项目更易接近，例如，文件名应反映内容，目录名也应如此，而且可能最重要的是，项目应遵循社区已经建立的惯例。这意味着除非你有很好的理由，否则你应该避免创建自己的惯例。特别是一些小事情，比如根据社区标准命名文件，可以帮助很多。一个例子是在文件末尾添加像 model 或 controller 这样的名称。在一些编程社区中，这是非常常见的，而在 Node.js 社区中，这是不被赞同的。遵循这些小事情可以使开发人员更容易，而不遵循它们可能几乎会引起对项目的愤怒。

请记住，文件很可能只会被开发人员触及，因此它们可以被优化以支持开发人员的任务，因此，常见的开发人员实践比领域专家的易接近性更重要。当然，这在项目和任务之间的范围上有所不同。它在组织性质和框架的常见习语方面基本成立，但不适用于在整个项目中开发的语言固有部分的命名。我们希望项目的结构对于已经熟悉类似代码库的开发人员来说是易接近的，但我们不希望在开发人员和领域专家之间引入翻译层。

让我们以一个例子更仔细地看看我们如何为我们的地牢管理器制定基本规则。当然，一开始，这只会包含转移`囚犯功能`，但尽管如此，它将暗示整体结构：

![易接近性](img/B03704_03_01.jpg)

关于这种结构的重要事项是，它一直使用节点模块的基础，同时已经暗示了可能包括多个功能在囚犯转移之外的结构。`index.js`文件通常命名为指示特定模块的入口点。跳入项目的开发人员将知道在尝试了解有关模块的更多信息时首先查看这些文件。我们以后可以利用这一事实来包括有关功能的常见文档，以及使该文件加载完成模块任务所需的所有其他文件。

在测试文件夹中创建测试也是定位测试的已建立方式。由于测试在设计上具有某些固有的类别，因此按照测试目录的结构进行组织是有意义的。测试文件夹的结构应该让我们一眼就能看出有哪些测试，以及它们如何适用于我们的整个项目。随着项目的增长，拥有一组覆盖功能的测试不仅在回归方面非常有价值，而且还可以快速了解某个功能的使用方式，因此快速定位测试可以意味着某个模块被重复使用或调整，而不是浪费精力重复已有的工作。

### 提示

这里提出的结构并非一成不变，有些人更喜欢将 app 改为 lib，将 spec 改为 test，或者进行其他类似的小改动。结构的目标应始终是让开发人员感到宾至如归。在这个领域可以根据特定的开发人员做出权衡。

最后，添加`package.json`文件是处理项目依赖关系并定义结构和其他部分的常见方式，因此我们也添加了这个文件，准备以后充分利用。

## 编辑的局部性

当开发人员在项目上工作时，他们很可能正在处理一个功能，或者正在修复错误和重构代码。由于这些活动至少在我们所追求的情况下与一个功能相关，我们希望确保开发人员不必跳转到许多不同的地方进行编辑。因此，与问题相关的文件应该在一个地方，减少打开与给定任务或功能相关的所有内容的开销，以及保持相关部分在头脑中以确保编辑发生在正确的地方的心理开销。

这就是我们之前在`lib`文件夹中创建包或模块的原因之一。当开发人员在处理囚犯转移时，他们可以仅通过查看目录结构就知道要编辑什么。他们可以快速在编辑器中打开文件，并将其视为一个工作单元，因为他们正在更改代码以完成给定的任务。

使用这样的结构不仅使开发人员在编辑时更容易查看，而且版本控制系统也更容易使用。由于代码是这样组织的，我们可以逐个功能地查看它，而且在处理不同功能时也不太可能触及相同的文件。这不仅减少了冲突的可能性，还使给定模块的历史更有用。

如果您看过我们迄今为止一直在使用的前述结构，您可能已经注意到编辑的局部性在测试中会被打破。当我们在`lib`中开发囚犯转移功能时，我们也必须编辑测试中的功能测试，这在文件系统上可能是相隔很远的。与软件开发中的一切一样，这是一个权衡，我们在这种情况下选择了可接近性而不是局部性。原因是更重视人员的入职，并且假定非局部性的成本似乎足够低以支持这一点。如果我们有不同看法，我们可能会将每个功能的测试定位在功能内部，因此更容易在将来将整个功能移动到不同的项目中。当然，这个决定并不是非此即彼的，我们可能会创建一个类似于测试目录下主目录结构的结构，以保持测试的局部性，例如将测试目录作为测试目录的一部分。

## 健身

| | *根据达尔文的说法，健身意味着生存和繁殖的能力。* | |
| --- | --- | --- |
| | - *达尔文健身-劳埃德·德米特里乌斯，马丁·齐赫克* |

随着我们的软件的增长和发展，它将需要适应不同的使用场景，最好的软件是超出其预期用例的软件。一个常见的例子是 Unix 及其相关的哲学。其理念是创建许多小的部分，当重新组合时，可以实现各种各样的用途。Unix 以各种形式存活了几十年，似乎没有尽头，但仅仅以某种方式创建只是故事的一半。随着变化的出现和新的用例形成，它并没有变得僵化，而是其思想和概念是可塑的，但对于我们的软件意味着什么。我们如何实现类似的多功能性？

我们已经看到，即使在文件系统级别上，软件也是由模块组成的。随着功能的实现，不同元素之间存在明显的区别。从健身的角度来看，这意味着我们能够快速定位某个特定功能，以及增强、删除或重用它。功能还应提示其依赖关系，可以通过子文件夹明确表示，或者只需查看位于功能目录根目录的索引文件中的导入依赖关系即可。

举个例子，随着地牢管理员的发展，囚犯转移可能会开始融入更多的消息传递，因为其他地牢已经采用了我们的系统，现在我们可以完全自动地在它们之间进行转移。在这一点上，整个王国都依赖于转移服务的可用性，这意味着需要非常严格的测试来确保其可靠性，因为停机意味着王国无法以最大效率进行袭击。我们对这个系统的成功非常满意，但它总体上减缓了地牢管理员的发展，因为囚犯转移是其一部分，我们需要遵守其严格的集成规则。但毕竟我们处于一个良好的位置；如果我们看一下我们的应用程序布局，我们可以看到我们可以相当容易地将囚犯转移提取到一个独立的应用程序中，并且可以单独维护它。

提取后，我们可以再次快速前进，并将转移集成为地牢管理员与之通信的另一个服务。拆分共同功能以及必须遵守不同约束的功能是保持可塑和可扩展软件不断前进的关键。

实际上，这显然是最好的情况，但仅仅将应用程序构建为一组独立的小部分，每个部分都在功能级别上进行了单独测试，使我们考虑 API 的方式，这在软件增长时将非常有用，当然，反过来也是一样。我们能够快速剔除不需要的功能，从而减少维护开销并提高我们的速度。这本质上就是本节开头提到的所有小型 Unix 程序的合作概念。

当然，这并不是软件设计的全部和终结，任何从 shell 开始使用 Unix 的人都会知道最初的学习曲线非常陡峭，最初做任何事情都不会感觉很快或者表达得很好。正如我们之前所看到的，为了达到一个目标，就意味着牺牲另一个，比如在这个例子中——项目的可接近性。毕竟，没有完美的解决方案，但至少在项目开始时，增强可接近性并在问题出现时考虑其他问题通常是有帮助的。对我们来说，这意味着牢记模块的高层结构可能是一件好事，但过度做准备并使每个部分都准备好提取，甚至是自己的应用程序，可能不会帮助项目前进。

### 提示

不要过于复杂化以获得完美的架构，因为完美的架构并不存在。更重要的是迅速将软件交到用户手中，以便获得关于其是否有用的反馈。由于延迟反馈，决定完美架构的减速很可能会在以后造成更大的成本，而次优的架构可能不会。

## 处理共享功能

就我们目前构建的应用程序而言，我们已经准备好拆分可能成为独立功能的功能，但反过来呢？领域通常有一定的一组关键概念，这些概念一次又一次地出现。这很好，因为它允许我们在需要时共享它，而不必一遍又一遍地写。这也表明我们足够了解领域，以提取核心概念并共享它们，因此这实际上是值得努力的事情。

当我们的功能与共享功能密切匹配时，我们提供一个公共接口，每个依赖接口都可以根据它进行开发。但如果我们实际上提取了一部分功能，例如我们的囚犯转移服务不再局限于应用程序，而实际上是通过 HTTP 可达的服务，那会发生什么？在这种情况下，我们不仅需要处理共享功能，而且我们实际上必须在每个依赖方中实现相同的代码，以便通过 API 调用来执行我们以前在本地执行的工作。想想每个其他购物系统都创建的支付网关抽象——这种功能可以开发一次并在多个地方使用，允许共享测试和共享开发资源。

当然，这并不是唯一一个共享功能实际上意味着有代码被共享的地方，似乎我们不得不在各个地方重复某些片段。其他例子可能是数据库访问或配置管理。所有这些共同点都是实际上与应用程序领域没有密切关系的较低级别代码。我们正在处理我们喜欢交流的方式的产物，我们应用的模式并不很好地支持这种交流。我们也可以这样思考，领域层面的内聚性较低，因为我们正在以一种方式泄露抽象，例如当我们想要处理囚犯时，我们会关心数据库访问代码。

### 提示

引入共享代码时要记住的一件事是，共享是耦合，耦合不是一件好事。共享代码应该有非常好的理由。

此时可能有多种解决方案，根据项目和代码的不同，可能适用不同的解决方案，所以让我向您介绍最常见的解决方案。

### 共享工具箱

当出现第一个不真正属于任何地方的共享功能时，大多数项目开始创建一个*实用*库，一个在整个项目中使用的工具箱。尽管许多架构纯粹主义者对此不屑一顾，但这可能是开始的最佳方式。最好将共享的工具箱分开，而不是在之后处理代码重复。许多流行的库都是这样开始的；想想 underscore 在 JavaScript 的*each*构造上提供了其实现，并处理了浏览器实现可能需要关心的所有不同版本，以在全世界运行。以下是从`underscore.js`文件中提取的一个示例，重新格式化以便更容易阅读：

```js
var each = _.each = _.forEach = function(obj, iterator, context) {
  if (obj == null) return;
  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, length = obj.length; i < length; i++) {
      if (iterator.call(context, obj[i], i, obj) === breaker)
      return;
    }
  } else {
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)
      return;
    }
  }
};
```

虽然 underscore 这样的库是这种方法有用性的完美例子，但也存在问题。特别是当命名不当时，这个文件夹或文件很快就会成为各种东西的倾倒地。不去考虑某样东西真正属于哪里，而是将更多东西倾倒到实用程序文件夹中，这更快。至少现在它在一个地方，可以从中移动和重构，所以保持积极；情况可能会更糟。从长远来看，目标应该是转向一种使用面向对象的方法，并让我们的测试从一开始就指导领域设计。当我们查看应用程序并看到类似上述的库函数是应用程序代码的一部分时，我们知道缺少一个抽象。再次强调，这一切都是权衡，抽象的问题是您在编写时必须考虑它们。

### 提示

实用程序或库是一个危险的地方，所以一定要确保将它们放在您的定期审查和重构的视线中。始终保持代码比您找到的代码整洁一点，并密切监视其变化。

### 提升依赖关系

随着项目的推进和发展，处理依赖关系的最佳方式可能是利用已有的内容。您的库已经成长，许多内部项目依赖于它们，为什么不利用已经内置到环境中的依赖管理呢？

JavaScript 曾经以处理依赖关系而臭名昭著，但是下载 jQuery 的版本并将其放入项目的时代幸运地结束了。JavaScript 为每种用例提供了惊人数量的依赖管理器。在浏览器中，我们可以利用**bower** ([`bower.io/`](http://bower.io/))、**browserify** ([`browserify.org/`](http://browserify.org/))和**npm** ([`www.npmjs.com/`](https://www.npmjs.com/))，可能还有许多其他的依赖管理器，在 Node.js 中，npm 是处理任何我们可能需要的包的标准方式。

根据作为过程一部分开发的库的类型，可能是一个很好的时机依赖于项目之外的版本，甚至可能建立一个私有版本的包注册表。这在开始时可能有些过度，但随着需求的出现，这是需要记住的事情。此外，不要忘记，现在可能是您回馈社区并将其作为开源发布的时候。

# 测试

| | *小心上述代码中的错误；我只证明了它的正确性，而没有尝试它。* | |
| --- | --- | --- |
| | --*Donald Ervin Knuth* |

每个即将投入生产的系统都需要根据实际情况进行评估。现实可能是一件严酷的事情，经常发生的情况是，我们期望完美运行的东西在实际使用时却不起作用。因此，在计算机编程的历史上，开发人员一直在思考如何确保软件能够正常工作，并且最好能够按预期工作。

1994 年，Kent Beck 为 Smalltalk 编写了 **SUnit** 测试框架，开启了现代单元测试的时代。这个想法非常简单：自动化代码评估，并确保它满足一定的规范。即使今天有许多新的框架来实现这一点，基本思想仍然是一样的：编写代码并检查它是否产生了预期的结果。实际上，无论有没有测试框架或固定流程，开发人员总是在做这个事情——没有人会在没有尝试过的情况下将代码推送到生产环境中。我们可以手动执行，也可以自动化执行。

有多个要点需要解决，以使测试变得有用，因为我们编写的测试有不同的目标。我们需要促进简单的单元测试、表达性的功能测试和性能测试。当然，这并不意味着所有场景都需要由一个框架处理，但摩擦越小，核心原则的采纳就会越好。确保测试被执行是至关重要的，而实现这一点的最佳方式是通过自动化，确保没有代码可以在最终产品中出现，而不满足其要求并且不破坏其他代码。

## 建立测试环境

正如我们现在所知，测试环境必须满足许多不同的目标，但也有大量的测试框架以及 JavaScript 本身在测试方面带来了一些挑战。过去许多项目中使用的一个框架是 Mocha 测试框架。它在 Web 开发人员中也得到了广泛的采用，因此接下来的部分将解释 Mocha。没有秘密可言，Mocha 可以与您团队最擅长的框架相互替换。唯一需要确保的是您实际使用了您拥有的工具，并且了解您想从测试中获得什么。因此，首先，我们需要确保在选择技术实现目标之前，了解我们不同测试的目标是什么。

## 不同类型的测试和目标

当我们开始测试代码时，有多个原因需要这样做。对于一个由其领域实现驱动的项目来说，一个主要方面始终是测试实现的功能，因为我们希望向客户提供快速反馈，并以一种解释性的方式展示我们的实现是有效的。但作为开发人员，我们还需要深入挖掘并在单元级别上工作，探索我们编写代码时的具体情况，或者在设计算法时。最后，一个项目不仅应关心其功能是否实际执行了它应该执行的任务，还应该从用户的角度来看，提供响应迅速的答复，并在整体上表现得足够好，以免成为障碍。所有这些方面都可以通过测试来实现。

### 功能规范

多年来，使测试不仅对开发人员有用，而且对客户也有用，一直是测试驱动和实施的最终目标。有一些工具，比如 Ruby 的 Cucumber，它有一个 JavaScript 实现，可以确保规范与代码有些解耦，使其尽可能易于领域专家阅读和理解。最终结果是规范看起来大部分像普通英语，但有一些限制。下面的代码使用黄瓜语法来描述囚犯转移作为功能规范，包括一个验收场景：

```js
Feature: Prisoner transfer to other dungeon
  As a dungeon master
  I want to make prisoner transfer an automated process
  So no important steps get left out

  Scenario: Notifying other dungeons of the transfer
    Given I have a prisoner ready to transfer to another dungeon
    When I initiate the transfer
    Then the other dungeon should be notified
```

这种规范现在可以很容易地转化为一个运行的规范，使用`Given`、`When`和`Then`块作为我们测试的指令。

将规范与真正的测试解耦有些程度上将程序员与之分离。因此，根据产品所有者的技术专业知识，即使他们也可以编写规范，当然需要一些开发人员的支持。在大多数项目中，情况并非如此，开发人员最终会为 Cucumber 创建规范代码，以及其作为测试代码的实现。在这种情况下，坚持使用更基本的工具是有用的，因为这更适合开发人员已经习惯的方式编写测试。这并不意味着黄瓜的想法不值得考虑。测试应该在非常高的层面上阅读，并且应该能够反映产品所有者最初在描述给开发人员时的意图，这样我们作为团队可以一起检测不匹配。但是，由于代码很可能在有开发人员在场的情况下阅读，几乎没有必要几乎有两种测试实现的开销。

受到 Cucumber 的启发并使用 Mocha 来编写我们的测试并没有错。例如，测试可以看起来像这样：

```js
var prisonerTransfer = require("../../lib/prisoner_transfer")
var assert = require("assert")

describe("Prisoner transfer to other dungeons", function () {
  /*
   * Prisoner transfers need to be an automated process. After
   * initiation the transfer should take the necessary steps to
   * complete, and prompt for any additional information if needed
   */

  it("notifies other dungeons of the transfer", function (done) {
    var prionser = getPrisonerForTransfer()
    var dungeon = getDungenonToTransfer()
    prisonerTransfer(prionser, dungeon, function (err) {
      assert.ifError(err)
      assert.equal(dungeon.inbox.length, 1)
      done()
    })
  })

  // Helpers
  /* get a prisoner to transfer */
  function getPrisonerForTransfer() { return {} }

  /* get a dungeon to transfer to */
  function getDungenonToTransfer() { return { inbox: [] } }
})
```

即使这种风格现在是实际可运行的代码，使用辅助方法来抽象细节并使命名清晰保持可读性。这里的目标不是让非技术人员轻松阅读，而是让开发人员能够与业务专家坐下来讨论隐含的规则。

### 提示

测试是代码的一个组成部分，因此它们需要采用相同严格的编码标准，由于测试没有测试，可读性至关重要。

### 单元测试

与业务专家讨论功能集后，创建功能规范中的当前状态规范，作为开发人员，我们需要尝试我们的代码。这就是单元测试的闪光之处！这个想法是在开发代码的同时测试我们的代码，并允许它在隔离环境中立即执行，这样我们就可以对其进行推理。单元测试通常随着某个部分的开发而迅速变化，并在之后作为回归保护。

### 提示

不要害怕放弃单元测试；它们是为了帮助开发而不是阻碍开发。

由于我们已经在我们的功能中使用 Mocha，自然而然地也要用它来测试我们的更小的单元，但测试看起来会有所不同。在单元测试的级别上，我们希望尽可能地隔离自己，如果我们做不到这一点，那么在其他开发领域中，我们真的会遇到一些痛苦。这种痛苦实际上是关于高耦合的；当我们将一个模块与系统的其他部分耦合得太紧时，测试会告诉我们。在这种设置中，创建一个孤立的单元测试将需要大量的设置，以确保我们只击中模块本身，而不触及依赖关系。

模块的单元测试的最终结果应始终测试公共接口，因为在这一点上它们起到了回归保护的作用。模块的单元测试测试的外部部分越多，它的私有接口就越多暴露，发生故障的可能性就越大，但即使这是我们的最终目标，也不要犯认为这应该是所有单元测试所做的错误。在编写更大应用程序的模块时，探索其逻辑更深入可能非常有用，特别是当公共接口可能仍在变化时。因此，在开发时编写所有能够深入了解模块较难部分的测试，但确保在声明模块可以使用之前删除这些“小助手”。

### 性能测试

每当一个应用程序向前发展并实现功能时，我们都需要考虑这个应用程序的性能。甚至在我们涉及性能需求之前，了解系统中哪些部分最有可能在将来引起麻烦是很重要的。

性能测试的重要之处在于它们将在早期阶段确定代码中的指标重点。考虑如何测量系统各部分的性能将确保我们考虑到仪器，这在我们后来实际上更接近重度使用或者在生产中探索故障时可能是一个至关重要的特性。

当然，测试应用程序的性能不是一次性的事情。单独来看，性能的测量是毫无意义的；只有在随着时间的推移监控时才会变得有用。实现这一点的一种策略是在每次推送到主分支时对外部 API 进行测试，并记录更改。这将让您了解项目在监控方面以及在项目开发期间的性能方面的情况。

尽管这可能并不明显，但监控性能的变化是实施域的一个重要点。作为采用领域驱动设计实践的开发人员，我们必须考虑我们应用程序的可用性。通常，不同的利益相关者对性能有不同的需求，而一个无法满足其需求的应用程序可能对某些人毫无用处。因此，很多时候，即使应用程序在其他方面提供了完整的功能集，由于性能特征不佳，应用程序也停止被使用。总的来说，只要知道了缺陷，就已经成功了一半。当我们至少了解时间花在哪里时，这是一个我们可以随时介入并根据需要进行优化的时机。这种需求很可能迟早会出现，因此为此做准备是非常值得的。

考虑到这些不同的目标，我们现在必须解决的问题是尽可能经常地运行所有这些不同的测试，而不必仅仅依赖于严格的遵从，特别是在创建一个随着时间推移而变化的视图时。随着项目的变化，依赖于人们每次运行所需的一切不仅对团队是一个重大负担，而且也是不必要的。

## 持续集成

最终，所有可能需要的测试只有在运行时才有用，这就是持续集成发挥作用的地方。当然，我们都是优秀的开发人员，总是测试他们的代码，但即使我们可能并不总是测试应用程序中整个集成链。我们的性能测试只有在可比较的平台上运行时才有用。

持续集成已经存在一段时间了，它最突出的系统可能是 Jenkins，但也有其他系统存在。其想法是在系统上自动运行我们从开发到生产需要的测试和其他步骤，并确保我们始终拥有稳定的构建。我们甚至可以使用这个系统来自动化部署，并且当然为开发人员提供一个仪表板，以检查应用程序当前的运行情况。

这样的系统可以成为项目的重要组成部分，因为它允许您快速从开发转移到系统，业务专家可以检查工作的影响。有许多关于如何设置项目持续集成的教程，最近高度精练的系统如**Travis-CI**使得设置变得非常容易，所以我在这里不会详细介绍；只需记住，这样的系统在项目达到一定规模和复杂性时，其价值远远超过成本，没有理由不使用。

### 提示

持续集成系统实际上是在整个开发过程中强制执行最佳实践，即使开发人员有一天状态不佳。它还提供了一个更易接近的方式，让外部人员发现和评估整个应用程序的状态。

# 管理构建

为兽人地牢编写软件有一个重要的优势，因为兽人对软件了解不多，所以我们可以引入任何我们喜欢的工具，他们不会对此有意见。你可能会想，当这一节的标题应该谈论构建软件时，我为什么要提到这个？市面上有很多构建工具，它们都有些许不同的功能，每个人似乎都更喜欢其中的一个。特别是在 JavaScript 中，社区尚未统一一种工具，因此有**Grunt**、**Jake**和**Broccoli**等，当然，您的项目也可能利用其他语言的工具，比如 Ruby 的 Rake 或老式的 make。

尽管有这么多构建工具，但它们唯一重要的是实际使用一个。是的，它们都有差异，但它们几乎都可以做到相同的事情，只是语法和性能有所不同。但为什么构建工具如此重要？为什么我们应该使用一个？

## 为什么每个应用程序都需要一个构建系统

在实际创建一个功能完整的系统来管理业务流程的规模上创建软件总是一项困难的任务。这样的系统涉及许多部分，就像我们管理囚犯转移的例子中，通知其他地牢，跟踪地牢的统计数据等等。当我们设置它时，我们需要加载多个文件，也许编译一些部分，管理依赖关系，并且在前端 JavaScript 代码的情况下，我们还希望对其进行压缩和最小化，以优化页面加载速度。手动执行所有这些步骤涉及多个步骤，并且很可能会因为我们忘记了其中一个步骤而在早晚失败，这就是构建系统的作用。在某种程度上，所有软件都有一个构建系统，这取决于系统的自动化程度。

### 提示

构建系统优化了“无聊性”；构建越无聊，越好。

目标是不犯错误，并且每次都能创建一个可重现的环境。我们希望运行一个命令并获得预期的结果，所以在我们的情况下，构建系统有一些责任：

+   运行测试

+   打包应用程序

+   部署应用程序

所有这些步骤都很重要，所以让我们逐步进行。

### 运行测试

我们现在正在编写很好的测试，这些测试确保我们的系统按照我们与领域专家确定的功能集的预期行为进行。因此，这些测试应该运行，如果它们失败，那么我们的系统有问题需要修复。由于我们已经有了一个测试框架，运行测试非常简单：

```js
**$ mocha --recursive test**

```

这将运行在测试目录中指定的所有测试，根据我们之前创建的文件布局，这将是所有测试。由于我们不想记住这个命令，我们可以通过将其添加到我们已经设置的`package.json`文件中，将其连接到 npm 中：

```js
{
  "name": "dungeon_manager",
  ...
  "scripts": {
    "test": "./node_modules/.bin/mocha --recursive test"
  }
  ...
}
```

有了这个设置，运行所有测试变得很简单：

```js
**$ npm test**

```

这将使我们的生活变得更加轻松，现在我们可以依靠一个命令来运行我们的测试，失败肯定是开发失败，而不是命令输错，例如，忘记了`--recursive`然后跳过大部分测试。根据涉及的开发人员的偏好，我们甚至可以进一步观察文件的更改并重新运行由这些更改触发的测试，这里描述的系统应该被视为最低要求。

### 打包应用程序

将应用程序移至生产环境很可能不是一个一步完成的过程。Web 应用程序可能涉及将资产编译在一起，下载依赖项，甚至配置某些部分以适应生产环境而不是开发环境。手动运行这些步骤容易出错，之前使用过这种流程的每个开发人员都有一个失败的故事。但是，如果我们希望保持软件的可塑性，并能够对领域的变化做出反应，并且能够迅速将其交给我们的领域专家，我们需要尽早并经常部署，而这的第一步是将应用程序打包成一个步骤。

目标是让每个开发人员能够设置应用程序的基本环境，就像我们的情况下安装 Node.js 一样，然后用一个命令设置应用程序。目前继续使用 npm 来管理我们的任务，我们将以下内容添加到我们的`package.json`文件中：

```js
{
  "name": "dungeon_manager",
  ...
  "scripts": {
    "test": "./node_modules/.bin/mocha --recursive test",
    "package": "npm install && npm test"
  }
  ...
}
```

由于这是一个自定义命令，在 npm 运行中没有特殊支持，这意味着运行：

```js
**$ npm run package**

```

对于外部人来说，这有点不直观，但是在 readme 文件中列出这样的命令目前可以解决这个问题，如果我们愿意，我们也可以决定使用一个系统来包装所有这些调用，使它们保持一致。

现在我们有了一个地方来放置打包应用程序所涉及的任何步骤，我们准备确保我们也可以用一个命令部署它。

### 部署

正如我们之前所说，我们希望我们的部署过程是一个无聊的过程；它应该是一个步骤，永远不会导致难以恢复的失败。这实际上意味着我们需要能够根据需要回滚部署，否则错误部署的恐惧将对任何进展产生僵化作用。

实际部署可能非常简单，根据您的需求，几个 shell 脚本就可以轻松完成。一个涵盖基本知识的系统，易于使用并适应不断变化的需求的系统是`deploy.sh`，可以在[`github.com/visionmedia/deploy`](https://github.com/visionmedia/deploy)上找到。使用 deploy 时，需要创建一个`deploy.conf`配置文件：

```js
[appserver]
user deploy
host appserver-1.dungeon-1.orc
repo ssh://deploy@githost.dungeon-1.orc/dungeon_manager
path /home/deploy/dungeon_manager
ref origin/master
post-deploy npm run package && npm start
```

该文件可以扩展为任何应用程序服务器，并且应该非常容易阅读。需要运行的任何步骤都可以实现为预部署或后部署挂钩，这使得该系统非常灵活，特别是当与管理应用程序部分的强大构建系统结合使用时。

## 选择正确的系统

到目前为止，我们一直在使用默认安装的工具，而没有真正安装大型工具；`deploy.sh`本身只是一个包含不到 400 行代码的 shell 脚本，npm 默认包含在 Node.js 中。实际上有很多有效的理由来使用环境之外的系统，例如，当您预期项目将来会由多种语言组成时，选择一个中立的包装器可以极大地增加项目之间的一致性，并简化入门。

现在我们知道我们想从系统中得到什么，所以选择一个意味着查看需求并选择大多数开发人员喜欢的系统。要记住的一件事是，这是项目希望长期坚持的东西，所以一个有一些使用经验的系统是个好主意。

### 提示

我喜欢在大多数项目中使用简单的**Makefile**，因为它是最常用和理解的系统，但你的情况可能有所不同。

这将我们带到了设置结束的地方，我们考虑文件和运行命令，但缺少一个重要的部分，那就是如何使领域部分真正成为世界的一部分，但又足够分离，以便对其进行推理。

# 隔离领域

|   | *创建应用程序，使其可以在没有 UI 或数据库的情况下运行自动回归测试，当数据库不可用时工作，并且可以在没有用户参与的情况下链接应用程序。* |   |
| --- | --- | --- |
|   | --*Alistair Cockburn* |

当我们创建一个遵循领域驱动设计原则的应用程序时，我们努力将业务逻辑与与“真实世界”交互的软件部分分开。最常引用的情况是，我们不希望以某种方式构建我们的 UI 层，使其也包含部分或全部业务逻辑。我们希望有一个清晰的面向领域的 API，被应用程序的其他部分消耗，以提供它们与领域的交互。

这个概念类似于一些提供的 UI，特定于 UI 的语言或 API，比如 HTML，或者例如 QT。这两者都源于提供开发人员构建 UI 所需的所有部分，但保持自然分离的概念。这是没有意义的，HTML、CSS 和 JavaScript 的 DOM 抽象的组合是 DSL，领域特定语言，用于构建浏览器界面。它们提供了一个抽象，浏览器实现者可以在其下更改他们的实现而不影响每个网站的编写。因此，它们隔离了浏览器供应商的业务领域，显示结构化内容，与创建内容的工作，很可能是你的工作。拥有这样的 API 比直接暴露内部数据结构具有许多优势，正如历史所显示的。

## 现代应用程序的架构

隔离业务领域的想法已经在软件行业中存在了很长时间，特别是随着核心领域和许多消费者的增长。近年来，首先将服务作为 API 变得越来越可行，这是由于移动设备和网络的重要性日益增加。今天，许多应用程序具有多个接口，例如，在酒店预订中，员工可以访问酒店的状态，将客户移动到不同的房间，通过电话进行预订等。与此同时，客户在线上，通过各种网络门户查看可用选项并进行预订。

在到达之前的几天，用户可能希望通过手机上的移动应用程序访问数据，以确保无论他们身在何处都可以使用。这些只是预订系统的许多访问选项之一，即使现在已经有很多选项：

+   内部桌面应用程序

+   内部 Web 应用程序

+   Web 应用程序

+   其他供应商的 Web 应用程序

+   移动应用程序

+   其他供应商的移动应用程序

这已经是一个很长的列表，我们可以预期随着新设备的出现以及不同的使用模式，它将在未来不断增长。

### 六边形架构

那么，我们如何确保应用程序准备好发展？随着 Web 应用程序的出现和主导地位，开发人员意识到应用程序构建的处理过程与其使用的界面和技术之间存在分歧。这种分歧并不是一件坏事，因为它可以用来在这些点上建立 API，并封装核心概念领域驱动设计所关注的业务领域。实现这一点的一种可能的技术被称为**六边形架构**。

![六边形架构](img/B03704_03_02.jpg)

整个应用程序被视为一个六边形，业务领域位于其中。虽然业务领域只关心自己的语言和概念，但它使用端口与所需的任何内容进行通信。端口是与外部世界的接口，并为所需内容和提供方式建立了清晰的 API。另一方面，还有适配器，即提供 API 的元素。这提供了很大的灵活性，不仅允许您交换适配器，例如在测试期间，还可以更快地尝试不同的技术，以找到最合适的技术，而不是猜测，而是实际尝试应用。

## 应用模式

热心的读者会意识到，我们的地牢管理应用程序与刚刚描述的预订应用程序并没有太大的不同。此外，我们还希望将其与多个 UI 和其他应用程序集成。此外，我们的业务概念足够复杂，以至于我们需要领域驱动设计，因此六边形架构非常适合我们。但我们如何才能实现这一点呢？

首先要意识到的是，到目前为止，我们已经在为此进行设计。我们的核心功能在数据库或 Web 框架的上下文之外被理解。六边形架构和领域驱动设计的理念毕竟非常契合。我们现在继续前进，清晰地分离业务领域包含的内容和外部提供的内容。这也被称为**持久性无知**，因为我们希望我们的领域忽略处理保存和加载数据的层。作为这种模式的一部分，我们创建单独的对象或模块，封装我们领域的操作，并在将来需要时将其集成到 Web 框架中以及公开为 API。

抽象并不是免费的；根据应用程序的不同，过度抽象数据层可能会引入性能开销，这可能是无法应付的。另一方面，如果您的领域与数据层的交互频率如此之高，可能领域本身存在问题，您可能需要重新思考领域层中的聚合。我们必须像滑块一样思考这种模式，而不是布尔值；我们可以根据领域以及应用程序性能的需求增加和减少抽象。

## 插入一个框架

那么，我们如何让这对我们的应用程序起作用呢？我们将要构建的第一个版本旨在具有 Web UI，因此我们需要插入一个 Web 框架，这样我们就不必重新发明轮子。Node.js 提供了许多选项，最流行的是`express.js`，我们已经使用过了，所以我们想要的是让 express 做它最擅长的事情，即处理请求，而我们的核心领域处理这些请求的逻辑。

让我们看一个例子：

```js
app.post("/prisoner_transfer", function(req, res) {
  var dungeon = Dungeon.findById(req.params.dungeonId)
  var prisoner = Prisoner.findById(req.params.prisonerId)

  prisonerTransfer(prisoner, dungeon, function(err) {
    var message
    if(err) {
      res.statusCode = 400
      message = { error: err.message }
    } else {
      res.statusCode = 201
      message = { success: true }
    }
    res.end(JSON.stringify(message))
  })
})
```

管理囚犯转移的代码被很好地封装在自己的模块中，并且只与领域对象进行交互。另一个问题是代码应该放在哪里。在这个早期阶段，这样的代码可能仍然可以放在一个`index.js`文件中，提供接口，但随着项目的进展，我们可能会朝着一个包含将领域与 express 框架连接的粘合代码的更模块化的架构发展。在这个阶段，我们甚至可以创建一个中间件层，以自动注入我们需要的依赖关系。

# 总结

在本章中，我们已经开始了项目，并且进展顺利。我们已经做好了一切准备，使项目能够进展，并为随之而来的变化做好准备。再次强调，主要思想始终是关于隔离，并确保我们思考和解决领域的问题，而不会在这一过程中迷失在语言和框架的复杂性中。

大多数程序员都会同意，集成系统和建模数据是两项确实需要专注的任务，而通过这种设置，我们正在迈出实现这种集成的重要一步。与此同时，这种架构使我们能够继续对数据进行建模，就像我们之前开始的那样。

在下一章中，我们将更详细地讨论领域对象本身以及在领域驱动设计术语中对它们进行建模的含义。我们将介绍术语来对这些模型进行分类，并使用领域驱动设计与面向对象的方法来推动它们。
