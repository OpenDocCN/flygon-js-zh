# 第四章。建模参与者

我们现在已经准备好全力投入开发工作，我们已经建立了一个坚实的结构，以帮助我们处理即将出现的变化。是时候更多地考虑我们系统的不同组件以及它们是如何相互作用的了。

系统中的交互发生在多个层面。操作系统与语言运行时进行交互，运行时与我们的代码进行交互，然后在我们的代码内部，我们创建对象进行回调和调用其他进程等。我们已经看到我们的领域对象如何与底层框架进行交互，我们可以想象代码如何调用不同的库。在构建交互时，了解存在的接缝并在必要时创建新的接缝是很重要的。在调用其他代码时，很明显我们的代码在哪里结束，库代码在哪里开始。在创建代码时，很容易混淆责任，但我们能够更好地分离它们，我们就能更好地发展我们的代码。

几乎计算机科学的所有方面都以某种方式处理不同组件之间的交互，因此存在多种技术来确保这些交互良好地进行。在本章中，我们将重点关注系统的参与者及其交互，并将详细介绍：

+   使用面向对象编程技术来对领域参与者进行建模

+   在隔离中测试领域对象

+   在领域中识别和命名角色

# 巨人的肩膀

关于如何建模和处理交互的最著名的模型之一是描述网络堆栈中各层交互的 OSI/ISO 模型。它包括七层，每一层都有一个明确定义的接口，可以由上一层进行通信，并与下一层进行通信。此外，每一层都定义了一个协议，允许它与同一级别的层进行通信。有了这个，就有了一个非常清晰的 API 来与层进行通信，也清楚了层如何回调到系统，因此很容易替换系统的部分。下图显示了 OSI/ISO 模型中的描述。每一层都由一个协议定义，允许每一侧的实例在其层进行通信，随着堆栈的上升，协议由给定的实例进行包装和解包：

![巨人的肩膀](img/B03704_04_01.jpg)

当然，这种模型并没有被全面采用，TCP/IP 专注于五层，甚至有人说过分的分层可能是有害的。但即使那些不赞成 OSI/ISO 模型的人也认为基本思想是有价值的，隔离通信是使互联网运行的基础之一。每一层都是可替换的，无论是完全替换还是只针对特定情况，这对任何系统来说都是一件强大的事情。

将这一点引入到建模应用程序的世界意味着我们的对象应该在业务领域的层面进行通信。在领域驱动设计方面，允许一个聚合与其他聚合进行交互以实现其目的是可以的，但是一个服务在不考虑聚合的情况下直接访问实体是不可以的。在不考虑适当的 API 的情况下访问应用程序的不同部分会导致两个模型之间的耦合。在我们的地牢中，让外来地牢的地牢主直接与囚犯进行交流也是一个坏主意，这会让囚犯被标记为间谍并立即被杀害，这不仅会因为紧密耦合而导致问题，还会让应用程序暴露于安全问题。例如，由于模型访问数据库直接获取 HTTP 请求中传递的数据而没有层来减轻访问，曾经发生过许多 SQL 注入攻击的实例。

这样的通信，其中一个对象与对象图的另一部分进行通信，忽略了门控接口，这是一个众所周知的问题，并被确定为*迪米特法则*，该法则规定：

|   | *每个单元应该只对其他单元有限的了解：只有与当前单元“密切”相关的单元。* |   |
| --- | --- | --- |
|   | --*迪米特法则* |

通常这在面向对象的语言中被改述为一个方法只应该有一个点。例如，像兽人大师上的以下方法违反了这一点。以下代码显示了通过深入到地牢及其后代控制的对象中实现了一个获取地牢中可用武器的访问器：

```js
function weapons() {
  result = []
  dungeon.orcs.forEach(function (orc) {
    result.push(orc.weapon.type)
  })
  return result
}
```

在这种情况下，兽人大师通过其地牢直接接触每个兽人，并直接询问他的武器类型。这不仅将兽人大师绑定到地牢的内部实现，还绑定到兽人甚至武器本身；如果这些元素中的任何一个发生变化，方法也必须发生变化。这不仅使对象本身更难以改变，而且整个系统现在更加僵化，在重构下不太灵活。

像前面的代码一样，它在操作数据结构时是命令式的，而面向对象的代码则专注于更声明式的风格，以减少耦合的数量。声明式意味着代码告诉对象需要做什么，并让它们处理实现目标所需的操作：

|   | *过程式代码获取信息然后做决定。面向对象的代码告诉对象要做事情。* |   |
| --- | --- | --- |
|   | --*Alec Sharp* |

通信不应该随意跨越边界，而应该以明确定义和合理的方式保持软件的可塑性。这也意味着在开发软件时，我们需要意识到组件和接口，像我们已经做过的那样识别它们，并意识到新的组件和接口从我们正在编写的代码中出现。对于在我们的领域中发送的命令和事件代表的消息也是如此。

即使在非常集中地思考正在开发的软件并绘制像我们已经做过的那样的图表时，几乎不可避免地会错过某些在开发开始时变得清晰的抽象。我们编写的代码和测试应该使接口清晰，并利用这一事实的一种常见方式是尽早执行正在开发的代码，并让它“告诉”你关于它的依赖项。

# 开发的不同方法

现在我们正在编写代码来解决领域中的问题，我们可以以不同的方式来解决问题：一种方式是从我们迄今为止发现的最高级别开始，让这指导我们下到我们的较低级别对象和抽象，或者我们可以从我们识别的组件开始，完善它们并建立系统。这两种方法都是有效的，通常被称为“自外向内”或“自内向外”开发。自内向外的优势在于我们始终有一个运行的工作系统，因为我们首先构建依赖项并建立系统。缺点是很容易失去对整体情况的视野，并在细节中迷失方向。

这些方法的共同之处在于它们遵循基于测试驱动开发的风格。我们正在构建测试来指导设计，并在完成时向我们展示。我们首先使用我们的代码来感受它以后的行为，并实现我们认为行为应该是什么。这可以通过首先专注于小而容易理解的组件来获得对它们的信心，就像*自内向外*方法中所做的那样。另一种方法是在开始时提出重要问题，随着我们的深入，逐渐进入更多细节，就像*自外向内*方法中所做的那样。

对于这个项目，从外部开始可能更合适，因为我们探索并了解了利益相关者的需求，但对于确切的组件及其行为并不太清楚；毕竟我们处在一个我们并不完全熟悉的世界中。特别是在一个陌生的世界中，我们很容易开始构建我们从未需要过的部分。现在我们对例如地牢之间的消息系统了解不多。我们可以开始尝试在这里构建一个抽象，让我们尽可能地控制，但另一方面，结果可能是我们每周只发送一条消息，并且让地牢主人手动完成这个任务是完全合理的。在这种评估中，我们必须牢记我们的总体目标应始终是提供价值和节省金钱，这可能意味着*不*构建东西。那么我们如何在没有基础结构的情况下创建软件呢？

## 介绍模拟对象

在从外部建模系统时，需要让对象代表最终将成为较低级别实现的对象。这在每个级别上都会发生，而首先对 API 进行建模的概念会向下渗透到较低层。我们之前开始构建了囚犯转移服务，依赖于囚犯和地牢；这些又将有依赖项，当完善对象时，需要以类似的方式设计。

实现这一点的对象称为**模拟**；它们是提供某个概念的静态实现并断言它们是否被正确调用的对象。模拟实现了某个对象应该遵循的协议。在 JavaScript 这样的动态语言中，这既容易又困难。不同的 JavaScript 测试框架以不同的方式处理这个问题；有些使用如上所述的模拟对象，而有些提供间谍，它们调用真实对象但监视这些调用的正确性。这两种方法都很有效，各有优势。

### 提示

有关间谍的更多信息可以在[`derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/`](http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/)找到。

创建模拟可以很简单：

```js
var myMock = {
  called: false,
  aFunction: function () { myMock.called = true }
}
```

尽管这不是一个非常高级的模拟，但它包含了我们需要的内容。这个对象现在可以代替任何需要提供名为`aFunction`的特定 API 的东西。还可以通过在测试运行后检查调用变量来检查函数是否已被调用。这些检查可以使用运行时直接提供的`assert`库来完成，而无需额外的测试框架。在下面的代码中，我们使用我们上面创建的非常简单的模拟来断言在特定时间调用了一个函数：

```js
var assert = require("assert")

function test_my_mock() {
  mock = Object.create(myMock) // called on the mock is false
  mock.aFunction()
  assert(mock.called) // called on the mock is true
}

test_my_mock()
```

在这种情况下，我们使用`Object.create`方法创建一个新的`myMock`对象实例，对其进行操作，并验证其是否正常工作。

如何创建模拟对象非常具体，取决于需要它们的情况，多个库实现了它们的创建。一个非常常用的库是**Sinon.JS**，它提供了许多不同的方法来验证功能，实现存根、模拟和间谍。结合我们的测试框架 Mocha，我们可以通过创建我们想要模拟的对象，并让 Sinon.JS 来进行验证的繁重工作，来创建一个模拟测试。现在我们可以用 Mocha 的组合特性提供行为描述，使用 Sinon.JS 提供高级模拟和验证。以下是一个例子：

```js
var sinon = require("sinon")

var anApi = {
  foo: function () {
         return "123"
       }
}

describe("Implementing an API", function () {
  it("is a mock", function () {
    var mock = sinon.mock(anApi)
    mock.expects("foo").once()

    anApi.foo()
    mock.verify()
  })
})
```

模拟的概念表面上很简单，但它的使用可能很困难，因为很难发现模拟的正确位置在哪里。

### 提示

有关模拟的更多信息，请访问[`www.mockobjects.com/2009/09/brief-history-of-mock-objects.html`](http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html)。

## 模拟的原因和不模拟的原因

| | *我们最初的描述过于关注实现，关键的想法是该技术强调了对象在彼此之间扮演的角色。* | |
| --- | --- | --- |
| | --*模拟对象的简史-Steve Freeman* |

模拟对象在测试期间代替系统中的其他对象，有时甚至在开发期间也是如此。有多种原因可以这样做，例如底层结构尚未实现，或者调用在开发过程中的时间成本或者甚至是通过调用按调用次数收费的 API 而非常昂贵。对于开发人员来说，能够离线运行测试非常方便，还有更多的原因可以解释为什么有人不想调用真实系统而是调用其替代物。

这种做法通常被称为**stubbing out**外部依赖关系。当与对这种依赖关系进行断言相结合时，这个存根就成为了模拟对象，在开发过程中通常有助于确保某些代码在正确的时间被正确调用，当然也有助于测试。

很容易陷入创建非常具体的模拟对象的陷阱，模拟其他对象的内部依赖关系等。要牢记的重要事情是，模拟应始终代表系统中的一个角色。现实世界中的各种其他对象可以扮演这个角色，但它们可以在一个模拟中表示。在经典的面向对象术语中，这意味着我们模拟接口而不是类。在 JavaScript 中，没有接口，所以我们需要选择合适的对象进行模拟。我们的模拟对象或对象的一部分只需要表示测试所需的内容，而不需要其他。当我们通过测试驱动我们的设计时，这是很自然的，但随着软件的发展和变化，我们需要注意这一点，因为变化可能导致我们的测试通过模拟过度规定一个对象。

# 谁参与了囚犯的转移？

在前面的部分中，我们在领域中进行了大量探索，以了解使系统中的操作发生所必须做的事情。有了这些知识，我们现在可以清楚地概念化囚犯转移应该如何进行。我们之前创建的测试指定了一些行为和我们在领域中知道的协作者。我们将它们表示为基本的 JavaScript 对象，其中包含满足测试所需的属性；例如，我们知道地牢需要一个消息收件箱来通知，但我们还不知道囚犯的任何属性。以下代码提供了一些简单的函数，让我们描述我们正在使用的对象类型，随着代码的增长和我们对囚犯或地牢的了解得到巩固，我们可以填写这些内容，以继续在测试期间代表相应的对象。

```js
/* get a prisoner to transfer */
function getPrisonerForTransfer() { return {} }

/* get a dungeon to transfer to */
function getDungenonToTransfer() { return { inbox: [] } }
```

到目前为止，囚犯和地牢都是特定的 JavaScript 对象，只是为了代表我们此刻需要的东西。进一步了解细节，还涉及其他参与者，即在途中看守囚犯的兽人，以及转移马车。当然，这些又有依赖关系：马车由驾驶员、作为囚犯移动牢房的木制马车以及拉动它的马组成。所有这些部分都是我们需要获取的潜在稀缺资源。这就是域建模再次发挥作用的地方；在我们的应用程序的上下文中，我们可以不把它们看作独立的东西，因为如果其中任何一个缺失，整个对象将无法正常运行。我们可以专注于不同对象扮演的角色，并将它们作为聚合物获取，以符合我们的模型。

## 不同的对象及其角色

马车是其中一个描述的角色；我们现在不关心马车由什么组成，而是将其视为在我们的系统中实现某种目的的一个东西。马车作为一个整体是一个聚合体，我们现在只想从外部检查它，不太关心它的内部。在这里，马车的公共 API 显示了一个我们在建模时需要考虑的接缝。例如，我们可能会在以后关心马匹作为一个单独的东西，以建模一个信使，我们希望为马车和信使都分配马匹。

聚合体不是限制资源共享的一种方式，而是一个概念，使得处理包含的对象变得不那么复杂。这并不改变没有马匹的马车是无用的这一事实，也可能有其他东西需要获取马匹作为资源。马车是我们系统中的一个角色。它提供了一个公共 API，并处理自己的内部数据和依赖关系。它本身就是一个较小规模的聚合体。

发现这样的接缝是在构建使用模拟和存根的系统时的一个基本思想。通过在系统中模拟角色，我们可以在它真正存在之前与角色进行交互，并探索其功能，而不受内部实现的限制。

# 根据领域命名对象

| *在计算机科学中只有两件难事：缓存失效和命名事物。* |
| --- |
| --*Phil Karlton* |

在探索领域中的角色时，最复杂的事情往往是我们需要为系统中尝试建立的角色命名。当我们能够为一件事命名时，我们自然可以将其与它在系统中扮演的角色联系起来。在构建软件系统并能够通过给它们具体的名称指出角色时，我们使得每个在系统上工作的开发人员都能够知道在哪里放置与他们需要工作的部分相关的功能。

之前，我们介绍了马车的概念，包括马车本身、拉车的马匹和驾驶员。这是一个根据领域命名概念的例子。在兽人地牢的世界中，马车的概念非常清晰，运行所需的东西也很清晰。通过使用系统利益相关者的语言，我们增加了团队的语言能力，使所有利益相关者都能参与其中。在确定领域的部分时，我们确保继续增加语言，同时创建抽象。这使我们能够将某些细节隐藏在一个常见的角色后面。

## 常见名称陷阱，比如*Manager

我们介绍的马车概念是一个很好的抽象；然而，作为软件开发人员，我们很容易重复使用我们在其他应用程序中看到的元素。在命名角色时，很容易陷入一种模式。我们经常看到只是因为缺乏更好的名称而存在的`Manager`对象：

```js
var transportManager = new TransportManager(driver, horse, cart)
transportManager.initializeTransport(prisoner)
```

即使这个对象承担的责任与我们之前命名为“马车”的对象相同，但通过名称找出它的功能已不再明显。即使团队中的开发人员清楚这个对象的用途，其他利益相关者也会感到困惑。这会导致团队内部的分裂，并不会促进非开发人员参与开发过程。

将对象命名为经理通常意味着根据它目前的功能而不是它在系统中的角色来命名它。以这种方式命名对象使得很难将其中的细节抽象出来。了解`Manager`对象的功能总是意味着知道它在管理什么以及它的内部细节如何运作才能理解它。抽象泄漏到系统的其他部分，每个使用经理的人都会查看它所管理的部分和细节。

管理对象的痛苦在编写测试的情境中往往变得非常明显。当我们想要测试一个管理器，而我们看不到一个清晰的抽象时，我们需要关心内部依赖关系，因此需要在我们的测试中保持它们。这使得测试看起来复杂，设置开始超过实际的断言部分。通过以通用角色命名的对象，我们得到了为非常通用的角色提供服务的对象，因此远离了特定于领域的对象。这可能会带来痛苦，因为这些通用对象只能通过其内部实现来具体化，因此它们是应该扮演的角色的不良代表。

### 提示

当你在为一个对象想不出名字时，试着先给它取一个明显愚蠢的名字，然后让对领域的探索引导你找到一个更具体和有意义的名字。

## 方法名的可读性

在**面向对象编程**（**OOP**）中，对象保存数据，并负责与其保存的数据最密切相关的操作。操作数据的函数，如从对象的内部状态计算新数据的函数，称为查询。这样的函数的例子是计算复合数据的函数，例如根据其设置的名和姓计算兽人的全名：

```js
function Orc(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

Orc.prototype.fullName = function () {
  return this.firstName + " " + this.lastName
}
```

另一方面，如果对象不是不可变的，就需要有函数来修改其内部状态。改变对象内部状态的函数称为命令；它们允许外部对象向对象发送命令以改变其行为。以下是一个例子：

```js
function Orc(age) {
  this.age = age
  this.attacking = false
}

Orc.prototype.goToBattle = function () {
  if (age < 18) throw new Error("To young for battle")
  this.attacking = true
}
```

随着命令改变其内部状态，需要非常清楚地知道发生了什么，并且对象应尽可能多地控制在命令的情况下实际要做什么，因此命令告诉对象要做什么，而不是询问它的状态以修改它。实现这一点意味着我们希望指示对象完成任务，而不是检查其属性。相反的是检查对象属性，并基于这些属性做出决定，代替负责属性的对象。*告诉，不要问*原则是面向对象编程的重要原则。前面的例子遵循了这个概念，通过不创建一个 setter 来*attack*属性，我们确保`Orc`对象控制其内部状态。使特定于域的命令读起来像它们所做的那样，而不是创建大量的 setter/getter 方法，有助于可读性，同时确保状态得到良好管理。在面向对象的方法中，我们希望对象负责其状态和操作该状态的方法。

对象不仅是一致命名方案的一部分，允许我们对领域进行建模。当我们在建模功能时，希望它读起来清晰，我们还需要使方法名可读。在前面的例子中，`TransportManager`的唯一方法是`initializeTransport`，它或多或少地重复了对象的名称。当对象是`Managers`或`Executors`等时，这种模式非常常见，但它并不有助于可读性。这与创建在设置对象的上下文之外调用的 setter 方法一样。方法需要告诉命令做什么。

一个以系统中的角色命名的对象可以更好地提高方法的可读性。域名`Carriage`使方法名`transport`更容易理解，因为它自然地与领域中的马车概念联系在一起。

有了这一切，现在到了我们需要考虑如何对对象进行建模以便于测试和开发的时候了。

# 首先是对象

在构建地牢管理器时，我们致力于创建一个易于维护和可扩展的软件。面向对象编程的核心原则在处理对象时有助于我们，但是当涉及到面向对象编程时，JavaScript 是特殊的。

正如许多 JavaScript 程序员肯定已经听说的那样，JavaScript 使用原型继承，更重要的是，它实际上没有类的概念，只有实例。

### 提示

尽管 JavaScript 的下一个版本**ECMAScript 6**引入了`class`关键字，但核心语言设计并没有改变。类实际上只是 JavaScript 当前原型继承的一种语法糖。如果想了解更多关于 ES6 的信息，请关注 Alex Rauschmayer 的博客[`www.2ality.com/`](http://www.2ality.com/)，他密切描述和跟踪 JavaScript 语言的发展。

当然，这并不意味着 JavaScript 是执行我们试图实现的任务的最糟糕的语言，因为这种缺乏并不以任何方式限制语言的能力，而是使其真正成为经典面向对象语言的超集。

让我们首先快速回顾一下 JavaScript 中的对象导向是如何工作的，以及我们如何利用语言的力量来帮助我们建模到目前为止已经起草出来的系统。

## JavaScript 中对象的基础

在 Ruby 或者甚至 Java 等面向对象的语言中，对象是基于类的。尽管可能可以创建一个普通对象，但这并不是常态。以 Ruby 为例，要创建一个像我们的 carriage 这样的方法，你会写出类似这样的代码：

```js
class Carriage
  def transport prisoner
    # some work happens
  end
end

carriage = Carriage.new
carriage.transport(a_prisoner)
```

在 JavaScript 中，对于非常简单的对象，以及非常重要的测试，我们不需要先有一个类来创建这样的对象：

```js
var carriage = {
  transport: function(prisoner) {
    // do some work
  }
}

carriage.transport(aPrisoner)
```

前面的代码将在不必先创建类和对象的情况下执行相同的操作。这在建模新 API 时非常强大，因为它允许在开发阶段非常轻量地使用和生成。

除了通过`{}`构造的普通对象之外，JavaScript 还允许函数被用作对象。在 JavaScript 中使用函数作为对象构造函数意味着与经典对象导向中的类一样灵活。JavaScript 中的函数是封装其内部状态以及它们在创建时引用的任何变量的对象。由于这些属性，JavaScript 中的函数是用于创建对象的基本构建块，并且通过关键字`new`的特殊支持是语言的一部分：

```js
function Carriage() {}
Carriage.prototype.transport = function (prisoner) {
  // do some work
}

var carriage = new Carriage()
carriage.transport(aPrisoner)
```

这看起来很像 Ruby 代码，并且行为与其非常相似。构造函数在 JavaScript 中是一个特殊的存在，关于它们的使用或不使用已经有很多文章写过。在很多情况下，对象类的共同功能是一个很好的习惯用法，并且现代 JavaScript 引擎是以此为初衷构建的。所以不要害怕构造函数，但要注意它们对`new`关键字的特殊使用以及它们可能对新开发人员造成的困惑。

### 提示

关于 JavaScript 中`new`的问题已经有很多文章写过。要了解更多关于 JavaScript 语言内部的信息和最佳信息，请阅读《JavaScript: The Good Parts》，作者 Douglas Crockford，O'Reilly 出版社。

## 继承以及为什么你不需要它

当然，仅仅构建类和它们的使用只是成为面向对象语言的一部分。特别是在 Java 中，构建相当复杂的继承层次结构是非常常见的，允许共同功能在对象之间共享。

继承的基本概念是父类的所有方法也都可以在子类上使用。

## 建模模式超越继承

|   | *更倾向于'对象组合'而不是'类继承'。* |   |
| --- | --- | --- |
|   | --*《设计模式》1995:20* |

尽管在 JavaScript 中可以实现继承，但这并不一定是设计应用程序时最好的方法，就像《四人帮》中所说的那样。继承在父类和子类之间创建了非常强的联系；这本身意味着系统的某些部分泄漏了不应该知道的知识。继承是两个对象之间最强的耦合形式，耦合本身应该是一个非常慎重的选择。深层次的继承树很快会使软件变得非常难以改变，因为改变往往会在整个系统中产生连锁反应。还有一个更大的问题——由于 JavaScript 不会对接口和关系进行编译时检查，所以这些部分很容易不同步，导致系统中出现错误，而在更静态的语言中则不会出现这种情况。

出于这些原因，也由于在像 JavaScript 这样的动态语言中很少需要经典继承，继承几乎从不使用。已经有其他模式来对抗继承的需求。

### 对象组合

当我们不想通过继承共享功能时，最简单的方法是传递已经实现我们需要的功能的对象，并直接使用它，例如：

```js
function Notifications(store) {
  if (typeof(store) === 'undefined') {
    this.store = []
  } else {
    this.store = store
  }
}

Notifications.prototype.add = function (notification) {
  store.push(notifictation)
}
```

通知是一个非常简单的对象，它管理系统的一部分的通知；它并不关心通知如何保存以供以后处理，而只是将这个任务委托给默认情况下实现为数组的存储对象。

委托给原生类型通常会经常发生，但这对于程序员创建的所有其他对象来说都是如此。这种组合有一个很大的优势，特别是在依赖项被传入时，它可以很容易地进行测试，就像刚才给出的例子中，我们可以在测试中用确保正确调用的东西替换存储对象。

### 没有继承的多态性

|   | *当我看到一只走起来像鸭子、游泳像鸭子、嘎嘎叫的鸟时，我就称那只鸟为鸭子。* |   |
| --- | --- | --- |
|   | --*Michael Heim* |

在 Java 等语言中继承的另一个原因是多态性的需求。这个想法是一个方法在不同的对象中应该有不同的实现。在经典继承结合类型检查的情况下，这意味着调用方法的对象需要有一个共同的祖先或接口，因为否则类型检查器会抱怨：

```js
interface Orc {
    abstract public String kill(String attacker);
}

class SwordMaster implements Orc {
    public String kill(String name) {
        return "Slash " + name;
    }
}

class AxeMaster implements Orc {
    public String kill(String name) {
       return "Split " + name;
    }
}
```

现在我们可以将`SwordMaster`类或`AxeMaster`类传递给需要的人，以便兽人保护他们：

```js
class Master {
  Orc[] guards;
  public Master(Orc[] guards) {
    this.guards = guards;
  }

  public void figthOfAttack(String[] attackers) {
    for(int i = 0; i < attackers.length; i++) {
      System.out.println(guards[i].kill(attackers[i]));
    }
  }
}
```

在支持鸭子类型的语言中不需要这种开销。在 JavaScript 中，我们可以直接写这个，而不需要接口，两个兽人可以直接作为普通的 JavaScript 对象，就像下面的例子中所示：

```js
var axeMaster = {
  kill: function(name) { return "Hack " + name; }
}

var swordMaster = {
  kill: function(name) { return "Slash " + name; }
}
```

被守护的“大师”对象现在可以直接调用每个守卫所需的方法，而无需匹配类型：

```js
var Master = function (guards) { this.guards = guards }
Master.prototype.fightOfAttackers = function (attackers) {
  var self = this
  attackers.forEach(function (attacker, idx) {
    console.log(self.guards[idx].kill(attacker))
  })
}
```

鸭子类型意味着一个对象的定义取决于它能做什么，而不是它是什么。当构建我们自己的非常简单的模拟时，我们已经看到了这种行为。只要方法在对象上被定义，当我们调用它时，它的类型就不重要，因此没有必要有一个共同的祖先。

由于 JavaScript 的非常动态的特性和鸭子类型的可用性，继承的需求很大程度上被消除了。

# 将对象设计应用到领域中

在理解了概念性对象设计之后，我们需要将所有概念应用到我们的领域中。我们继续对我们开始的囚犯转移进行建模。到目前为止，我们有一个应用模块的入口点，最终将处理这个问题。从测试中，我们知道囚犯转移依赖于囚犯和地牢对象。

## 在简单对象上构建系统

因此，让我们来看看囚犯转移需要做什么，以及它的合作者是谁。之前，我们确定囚犯转移显然需要囚犯和目标地牢进行转移，而囚犯转移应该管理其他一切。重要的是要考虑从用户角度来看最小的输入是什么，以限制 API 的表面。

当然，囚犯转移，在领域驱动设计中是一个服务，需要更多的合作者来真正实现其目的。首先是参考本地地牢以获取资源，例如兽人充当看守，马车运送囚犯，可能还有其他资源。管理转移的目标还包括通知其他地牢，因此我们还需要通知它们的手段。

正如我们在前几章中发现的那样，通知的概念尚未被很好地理解，因此我们现在可以假设将有一个服务，允许我们向目标发送消息，出于特定的原因。我们可以针对消息服务的抽象进行编程，从而进一步指定我们将从系统中需要什么。将所有这些结合起来并加以完善，将我们带到了以下结论：

```js
prisonerTransfer = function (prisoner,
                             otherDungeon,
                             ourDungeon,
                             notifier,
                             callback) {
  var keeper = ourDungeon.getOrc()
  var carriage = ourDungeon.getCarriage()
  var transfer = prepareTransfer(carriage, keeper, prisoner)
  if (transfer) {
    notifier.message(dungeon, transfer)
    callback()
  } else {
    callback(new Error("Transfer initiation failed."))
  }
}
function prepareTransfer(carriage, keeper, prisoner) {
  return {}
}
```

所有调用都只是对对象的简单调用，在测试期间可以使用简单的普通 JavaScript 对象代替：

```js
it("notifies other dungeons of the transfer", function (done) {
  prisonerTransfer("prisoner",
                   getOtherDungeon(),
                   getLocalDungeon(),
                   getNotifier(),
                   function (err) {
      assert.ifError(err)
      assert.equal(dungeon.inbox.length, 1)
      done()
    })
})
```

返回具有所需功能的普通对象，最终我们将根据现在设计的模拟创建它们自己的模块，这就是创建合作者角色的全部内容。

```js
function getOtherDungeon() {
  return { inbox: [] }
}

function getLocalDungeon() {
  return {
    getOrc: function () { return {} },
      getCarriage: function () { return {} }
     }
   }

function getNotifier() {
  return {
    message: function (target, reason) { target.inbox.push({}) }
  }
}
```

这种顶层设计确实帮助我们创建基础功能。我们已经非常清楚地看到了我们从通知系统中需要什么，以及如何使转移本身执行其职责将告诉我们更多关于其他合作者的信息。

# 总结

阅读完本章后，您对我们如何在系统内建模囚犯转移有了坚实的基础。我们使用了非常简单的设计，尽可能减少了工具开销。我们的系统利用了 JavaScript 的动态特性，为我们尚未创建的对象创建了简单的存根，并且我们能够验证我们在先前研究中讨论的第一个理解。

在下一章中，我们将进一步探讨系统中的其他角色。我们将专注于用领域驱动设计术语对它们进行分类，以便我们可以重用空间中其他人探索的模式。我们还将更加关注语言，以促进进一步的沟通，以及如何与这些模式一起工作，以在领域中实现非常清晰的沟通。
