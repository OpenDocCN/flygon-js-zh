# 第十五章：更干净代码的工具

我们使用的工具对我们编写代码时养成的习惯有很大影响。在编码时，就像生活中一样，我们希望养成良好的习惯，避免坏习惯。良好习惯的一个例子是编写符合语法的 JavaScript。为了帮助我们强制执行这个良好习惯，我们可以使用代码检查工具在我们的代码无效时通知我们。我们应该以这种方式考虑每个工具。它激发了什么良好习惯？它又抑制了什么坏习惯？

如果我们回顾一下我们原始的清晰代码原则（*R.E.M.U*），我们可以看到各种工具如何帮助我们遵守这些原则。以下是一小部分对这四个原则有帮助的工具：

+   **可靠性**：测试工具、用户反馈、错误记录器、分析数据、代码检查工具、静态类型工具和语言

+   **效率**：性能测量、分析数据、用户反馈、用户体验评估、生态成本（例如*碳足迹*）

+   **可维护性**：格式化程序、代码检查工具、文档生成器、自动化构建和持续集成

+   **可用性**：分析数据、用户反馈、文档生成器、可访问性检查器、用户体验评估和*走廊测试*

激发良好习惯的工具通过增强我们的*反馈循环*。反馈循环是最终让您意识到需要做出改变的任何事物。也许您引入了一个导致错误日志的错误。也许您的实现不清晰，同事抱怨了。如果工具能及早捕捉到这些情况，那么它可以加快我们的反馈循环，使我们能够更快地工作并达到更高的质量水平。在下图中，我们说明了**我们的反馈循环**，以及它是如何在开发的每个阶段接收来自工具的信息的：

![](img/ab23a961-0c64-451d-9f3d-cbf75064f16b.png)

在我们的开发阶段，有许多反馈渠道。有代码检查工具告诉我们语法有问题，静态类型检查器确认我们正确使用类型，测试确认我们的期望。即使在部署后，这种反馈仍在继续。我们有错误日志指示失败，分析数据告诉我们用户行为，以及来自最终用户和其他个人的反馈，告诉我们有关故障或改进的领域。

不同的项目将以不同的方式运作。您可能是一个独立的程序员，或者是专门从事特定项目的 100 名程序员之一。无论如何，可能会有各种开发阶段，并且在每个阶段都存在反馈的可能性。工具和沟通对于有效的反馈循环至关重要。

在本章中，我们将介绍一小部分可以帮助我们养成良好习惯和积极反馈循环的工具。具体来说，我们将介绍以下内容：

+   代码检查和格式化工具

+   静态类型

+   端到端测试工具

+   自动化构建和持续集成

# 代码检查和格式化工具

**代码检查工具**是一种用于分析代码并发现错误、语法错误、风格不一致和可疑结构的工具。JavaScript 的流行代码检查工具包括 *ESLint*、*JSLint* 和 *JSHint*。

大多数代码检查工具允许我们指定我们想要查找的错误或不一致的类型。例如，*ESLint* 将允许我们为给定代码库指定全局配置在根级别的 `.eslintrc`（或 `.eslintrc.json`）文件中。在其中，我们可以指定我们正在使用的语言版本，我们正在使用的功能，以及我们想要强制执行的代码检查规则。以下是一个示例 `.eslintrc.json` 文件：

```js
{
  "parserOptions": {
    "ecmaVersion": 6,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
     }
  },
  "extends": "eslint:recommended",
  "rules": {
    "semi": "error",
    "quotes": "single"
  }
}
```

以下是我们配置的解释：

+   `ecmaVersion`：在这里，我们指定我们的代码基于 ECMAScript 6（2016）版本的 JavaScript 编写。这意味着如果 linter 发现您正在使用 ES6 特性，它不会抱怨。但是，如果您使用 ES7/8 特性，它会抱怨，这是您所期望的。

+   `sourceType`：这指定了我们正在使用 ES 模块（导入和导出）。

+   `ecmaFeatures`: 这告诉 ESLint 我们希望使用 JSX，这是一种允许我们指定类似 XML 的层次结构的语法扩展（这在像 React 这样的组件框架中被广泛使用）。

+   `extends`: 在这里，我们指定了一个默认的规则集`"eslint:recommended"`，这意味着我们愿意让 ESLint 强制执行一组推荐的规则。如果没有这个，ESLint 只会执行我们指定的规则。

+   `rules`: 最后，我们正在配置我们希望在推荐配置之上设置的具体规则：

+   `semi`: 这个规则涉及到分号；在我们的覆盖中，我们指定如果缺少分号则产生错误而不是仅仅警告。

+   `quotes`: 这个规则涉及到引号，并指定我们希望强制使用单引号，这意味着 linter 会在我们的代码中看到双引号时发出警告。

我们可以通过编写一个故意违反规则的代码片段来尝试我们的配置：

```js
const message = "hello"
const another = `what`

if (true) {}
```

如果我们在这段代码上安装并运行 ESLint（在 bash 中：`> eslint example.js`），那么我们将收到以下内容：

```js
/Users/me/code/example.js
 1:7 error 'message' is assigned a value but never used 
 1:17 error Strings must use singlequote 
 1:24 error Missing semicolon
 2:7 error 'another' is assigned a value but never used
 2:17 error Strings must use singlequote
 2:23 error Missing semicolon
 4:5 error Unexpected constant condition 
 4:11 error Empty block statement

 8 problems (8 errors, 0 warnings)
 4 errors and 0 warnings potentially fixable with the `--fix` option.
```

这详细说明了根据我们配置的规则的所有语法错误。正如你所看到的，它详细说明了被违反的规则以及发现问题的行。ESLint 和其他 linting 工具在发现难以发现的语法错误方面非常有帮助，其中一些如果不加以处理，可能会导致将来难以调试的功能性错误。Linting 还使代码更加一致，使程序员感到熟悉，并减少认知负担，就像在一个具有许多不同语法约定的代码库中一样。

ESLint 还包括一个通过其`--fix`选项修复这些语法错误子集的功能，尽管您可能已经注意到只有一部分错误可以通过这种方式修复。其他错误需要手动修复。不过，值得庆幸的是，有许多更高级的工具可用来帮助我们。格式化工具，如 **Prettier** 和 **Standard JS**，将采用我们的语法偏好并对我们的代码进行积极的更改，以确保它保持一致。这意味着程序员不必为特定的语法规则负担，也不必无休止地更改代码以响应 linters。他们可以按照自己的意愿编写代码，完成后，格式化程序将更改代码以符合约定的语法约定，或者在出现严重或无效的语法错误时警告程序员。

为了说明，让我们用默认配置在一个简单的代码片段上运行 Prettier：

```js
function reverse( str ) {
  return ( String( str ).split( '' ).reverse().join( '' ) );
}
```

当在 Prettier 上运行上述代码时，我们会收到以下内容：

```js
function reverse(str) {
  return String(str)
    .split("")
    .reverse()
    .join("");
}
```

正如我们所看到的，Prettier 已经删除并更改了我们的语法习惯以符合其配置的约定。换句话说，它已经将单引号换成双引号，删除了多余的括号，并对空格进行了重大更改。格式化工具的魔力在于它们帮助程序员摆脱痛苦。它们会纠正一些微小的语法习惯，让程序员可以自由地进行更重要的工作。行业的一般趋势是远离简单的 linters，转向更全面的工具，将 linting 和格式化结合在一起。

遵守哪种语法约定的决定是可配置的，完全取决于你。关于这个问题有很多坚定的观点，但最重要的原则是一致性。例如，我个人更喜欢单引号而不是双引号，但如果我在一个已经建立了双引号约定的代码库中工作，那么我会毫不犹豫地改变我的习惯。大多数时候，语法偏好只是主观的和传统的规范，所以重要的不是我们使用哪种规范，而是我们是否都遵守它。

我们已经习惯了 JavaScript 语言中的许多规范，这些规范是由其动态类型的特性引导的。例如，我们已经习惯了必须手动检查特定类型，以便在接口中提供有意义的警告或错误。对许多人来说，这些规范很难适应，他们渴望对他们使用的类型有更高的信心。因此，人们将各种静态类型工具和语言扩展引入了 JavaScript。接下来我们将探讨这些内容，同时注意这些静态类型工具如何改变或改进您的个人开发反馈循环。

# 静态类型

正如我们长时间探讨的那样，JavaScript 是一种动态类型语言。如果小心使用，这可能是一个巨大的好处，可以让您快速工作，并允许您的代码具有一定的灵活性，使同事能够更轻松地使用它。然而，动态类型可能会在某些情况下导致程序员的认知负担和不必要的 bug 可能性。静态类型编译语言，如 Java 或 Scala，强制程序员在声明的时候指定他们期望的类型（或者根据使用方式推断类型，以便在执行之前）。

静态类型具有以下潜在的好处：

+   程序员可以**对他们将要处理的类型有信心**，因此可以对他们的值的能力和特性做出一些安全的假设，从而简化开发。

+   代码可以在执行之前进行静态类型检查，这意味着**潜在的 bug 可以轻松地被捕捉到**，并且不会受到特定（和意外的）类型排列的影响。

+   代码的维护者和用户（或其 API）有一个**更清晰的期望集**，并且不会猜测可能会或可能不会起作用。类型的规范本身可以作为一种文档。

尽管 JavaScript 是动态类型的，但已经有努力为 JavaScript 程序员提供静态类型系统的好处。其中两个相关的例子是 Flow 和 TypeScript：

+   **Flow** ([`flow.org/`](https://flow.org/)) 是 JavaScript 的静态类型检查器和语言扩展。它允许您使用自己特定的语法注释类型，尽管它不被认为是一种独立的语言。

+   **TypeScript** ([`www.typescriptlang.org/`](http://www.typescriptlang.org/)) 是由微软开发的 JavaScript 的超集语言（这意味着有效的 JavaScript 始终是有效的 TypeScript）。它是一种独立的语言，具有自己的类型注释语法。

Flow 和 TypeScript 都允许您声明正在声明的类型，可以是变量声明或函数内的参数声明。以下是一个接受`productName`（`string`）和`rating`（`number`）的函数声明的示例：

```js
function addRating(productName: string, rating: number) {
  console.log(
    `Adding rating for product ${productName} of ${rating}`
  );
}
```

Flow 和 TypeScript 通常允许在声明标识符后注释类型，形式为`IDENTIFIER: TYPE`，其中`TYPE`可以是`number`、`string`、`boolean`等。但它们在许多方面有所不同，因此重要的是要对两者进行调查。当然，Flow 和 TypeScript 以及 JavaScript 的大多数其他静态类型检查技术都需要*构建*或*编译*步骤才能工作，因为它们包括语法扩展。

请注意，静态类型并不是一种灵丹妙药。我们代码的整洁程度不仅仅限于其避免与类型相关的错误和困难的能力。我们必须*放大*我们的视角，记得考虑用户以及他们通过我们的软件试图实现的目标。很常见看到热情的程序员迷失在他们的语法细节中，但忽略了更大的画面。因此，为了稍微改变方向，我们现在将探讨*端到端测试工具*，因为端到端测试对代码质量的影响可能与我们使用的类型系统或语法一样重要，甚至更重要！

# 端到端测试工具

在过去的几章中，我们探讨了测试的好处和类型，包括端到端测试的概述。我们通常用于构建测试套件和进行断言的测试库很少包括端到端测试功能，因此我们需要为此找到自己的工具。

端到端测试的目的是模拟用户在我们的应用程序上的行为，并在用户交互的各个阶段对应用程序的状态进行断言。通常，端到端测试将测试特定的用户流程，例如*用户可以注册新帐户*或*用户可以登录并购买产品*。无论我们是在服务器端还是客户端使用 JavaScript，如果我们正在构建一个网络应用程序，进行这样的测试将是非常有益的。为此，我们需要使用一个可以人为创建用户环境的工具。在网络应用程序的情况下，用户环境是浏览器。幸运的是，有大量的工具可以模拟或运行真实（或*无头**s*）浏览器，我们可以通过 JavaScript 访问和控制。

**无头**浏览器是一个没有图形用户界面的网络浏览器。想象一下 Chrome 或 Firefox 浏览器，但没有任何可见的 UI，完全可以通过 CLI 或 JavaScript 库进行控制。无头浏览器允许我们加载我们的网络应用程序并对其进行断言，而无需无谓地消耗硬件能力来渲染 GUI（这意味着我们可以在我们自己的计算机上或*在云端*作为我们*持续集成/部署*过程的一部分来运行这些测试）。

这样一个工具的例子是**Puppeteer**，这是一个 Node.js 库，提供了一个控制 Chrome（或 Chromium）的 API。它可以在无头或非无头模式下运行。以下是一个示例，我们在其中打开一个页面并记录其`<title>`：

```js
import puppeteer from 'puppeteer';

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('https://example.com');

  const titleElement = await page.$('title');
  const title = await page.evaluate(el => el.textContent, titleElement);

  console.log('Title of example.com is ', title);

  await browser.close();
})();
```

Puppeteer 提供了一个高级 API，允许创建和导航浏览器页面。在这个上下文中，使用`page`实例，我们可以通过`evaluate()`方法评估特定的客户端 JavaScript。传递给此方法的任何代码将在文档的上下文中运行，并且因此可以访问 DOM 和其他浏览器 API。

这就是我们如何能够检索`<title>`元素的`textContent`属性。您可能已经注意到，Puppeteer 的 API 大部分是异步的，这意味着我们必须使用`Promise#then`或`await`来等待每个指令的完成。这可能有些麻烦，但考虑到代码正在运行和控制整个网络浏览器，一些任务是异步的是有道理的。

端到端测试很少被接受，因为它被认为很难。虽然这种看法曾经是准确的，但现在不再是这样。有了像 Puppeteer 这样的 API，我们可以轻松地启动我们的网络应用程序，触发特定的操作，并对结果进行断言。以下是使用 Jest（一个测试库）与 Puppeteer 对`https://google.com`的`<title>`元素中的文本进行断言的示例：

```js
import puppeteer from 'puppeteer';

describe('Google.com', () => {

  let page;

  beforeAll(async () => {
      const browser = await puppeteer.launch();
      page = await browser.newPage();
      await page.goto('https://google.com');
  });

  afterAll(async () => await browser.close());

  it('has a <title> of "Google"', async () => {
    const titleElement = await page.$('title');
    const title = await page.evaluate(el => el.textContent, titleElement);
    expect(title).toBe('Google');
  });
});
```

获取页面、解析其 HTML，并生成我们可以进行断言的 DOM 是一个非常复杂的过程。浏览器在这方面非常有效，因此在我们的测试过程中利用它们是有意义的。毕竟，决定最终用户看到的是浏览器看到的内容。端到端测试为我们提供了对潜在故障的真实见解，现在编写或运行它们也不再困难。对于干净的代码编写者来说，它们尤其强大，因为它们让我们从更加用户导向的角度看到我们代码的可靠性。

与我们探索过的许多工具一样，端到端测试可能最好通过自动化集成到我们的开发体验中。我们现在简要探讨一下这一点。

# 自动化构建和持续集成

正如我们所强调的，有大量的工具可用于帮助我们编写干净的代码。这些工具通常可以通过**命令行界面**（**CLI**）手动激活，有时也可以在我们的集成开发环境中激活。然而，通常情况下，将它们作为我们开发的各个阶段的一部分运行是明智的。如果使用源代码控制，那么这个过程将包括*提交*或*暂存*过程，然后是*推送*或*检入*过程。这些事件，与简单地对文件进行更改相结合，代表了我们的工具可以用来生成它们的输出的三个重要开发阶段。

+   在对文件进行更改时：通常在这个阶段会发生 JavaScript（或 CSS）的转译或编译。例如，如果你正在编写包含 JSX 语言扩展（React）的 JS，那么你可能会依赖*Babel*来不断地将你的 JS 混合编译为有效的 ECMAScript（参见 Babel 的`--watch`命令标志）。当文件发生变化时，进行代码检查或其他代码格式化也很常见。

+   在提交时：通常在提交前或提交后阶段会进行代码检查、测试或其他代码验证。这很有用，因为任何无效或损坏的代码都可以在推送之前被标记出来。在这个阶段进行资源生成或编译也并不罕见（例如，从 SASS 生成有效的 CSS，一种替代样式表语言）。

+   在推送时：当新代码被推送到特性分支或主分支时，通常会在远程机器上发生所有过程（代码检查、测试、编译、资源生成等）。这被称为**持续集成**，它允许程序员在部署到生产环境之前看到他们的代码与同事的代码结合后会如何运行。用于持续集成的工具和服务的例子包括**TravisCI**、**Jenkins**和**CircleCI**。

自动激活工具可以极大地简化开发，但这并不是必需的。你可以通过命令行进行代码检查、运行测试、转译 CSS，或生成压缩的资源，而无需费心自动化。然而，这样做可能会更慢，如果没有将工具标准化为一组自动化工具，那么你的团队中可能会出现工具使用不一致的情况。例如，你的同事可能总是在将 SCSS 转译为 CSS 之前运行测试，而你可能倾向于相反的方式。这可能导致不一致的 bug 和“在我的机器上可以运行”的情况。

# 总结

在本章中，我们已经发现了工具的用处，突出了它改进我们的反馈循环的能力，以及它如何赋予我们编写更干净代码的能力。我们还探索了一些具体的库和实用工具，让我们对存在的工具类型和以编程者的能力和习惯可以被增强的各种方式有了一些了解。我们尝试了代码检查器、格式化程序、静态类型检查器和端到端测试工具，并且我们已经看到了工具在开发的每个阶段的优点。

下一章开始我们的合作艺术和科学之旅；这对于想要编写清晰代码的人来说是至关重要的要素。我们将从探讨如何编写清晰易懂的文档开始。
