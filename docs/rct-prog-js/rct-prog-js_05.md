# 第五章：学习函数式编程-基础知识

JavaScript 是一种多范式语言，对于它触及的任何范式都不完美，但它具有其主要范式的有趣特性。它是一种面向对象的语言，尽管面向对象的定义在面向对象的语言之间有所不同。有人建议，它的原型继承对于面向对象编程可能不如演示如何创建无类对象重要，而不是在开始时就把分类搞对的困难任务。面向对象的定义在具有面向对象特性的多范式语言之间也有所不同。例如，Python 动态允许向现有对象添加成员，而 Java 要求在类中定义成员。JavaScript 的面向对象特性是有用和有趣的，但特别是在过去几年里，它们一直是其他面向对象语言的程序员的挫折之源，他们被告知 JavaScript 是面向对象的，但没有足够的信息来解释 JavaScript 如何通过与其他主要语言根本不同的方法来实现面向对象。

同样，对于函数式编程，JavaScript 具有函数式编程支持，或者至少有一些支持。但是像整个 JavaScript 一样，函数式 JavaScript 并不完全符合*好的部分*。函数式编程语言的一个普遍特征（虽然不是普遍的）是尾调用优化，它表示只在末尾递归的递归函数在内部被转换为更常见的循环样式，速度更快，并且可以在不耗尽调用堆栈空间的情况下进行非常深的递归。这种优化计划在 ECMAScript 6 中实施，但在撰写本书时，它尚未在常见浏览器中实施，这不仅提供了较慢的性能，还限制了递归深度在大约 10,000 到 20,000 次之间。

在这个限制内可以做很多事情，但是结构化程序编写者如果他们的`for`循环不能实现远远超过 20,000 次的迭代，就会感到不满。这里的重点不是指定 JavaScript 不总是支持尾调用优化的最佳解决方案，而是指出这个困难目前存在，并且这是 JavaScript 不直接支持标准函数语言特性的少数几种方式之一（例如，计算从 1 加到 1,000,000 或更高的所有整数并不是特别有趣，但它在教程中作为标准示例）。

关于 JavaScript 是否应该被称为函数式语言，文献意见不一；它肯定不是像 Haskell 那样的纯函数式语言（但 OCaml 也不是）。JavaScript 被称为一种已知函数式语言 Scheme 的 C 语言版本，并且它的基本函数式特性并不是事后添加的东西。也许这反映了他的偏好，但是道格拉斯·克罗克福德在评判 JavaScript 语言的哪些部分是好主意时，从*JavaScript：好的部分*到*更好的部分*，他从 ECMAScript 6 开始的偏好之一是停止使用命令式风格的`for`和`while`循环，而是使用利用尾调用优化的递归。也许 JavaScript 具有函数式内核的最有力的主张可以在语言的哪个特性是中心的问题上看出来。有人建议，在 Java 中，中心特性是对象。在 C 中，是指针。在 JavaScript 中，是函数。

JavaScript 的函数具有一流的地位，这意味着（高阶）函数可以作用于其他函数并作为参数传递，甚至可以动态构建并作为结果返回。

在本章中，我们将涵盖：

+   自定义排序函数

+   映射、减少和过滤

+   愚人的金子-改变其他人原型的行为

+   闭包和信息隐藏

# 自定义排序函数-函数式 JavaScript 和一级函数的第一个示例

为了打破僵局，让我们来看看如何对 JavaScript 的数组进行排序。JavaScript 的数组有一个内置的`sort()`函数，至少可以说是一个合理的默认值。例如，如果我们创建一个包含π的前六位数字的数组，我们可以对其进行排序：

```js
var digits = [3, 1, 4, 1, 5, 9];
digits.sort();
console.log(digits);
```

Chrome 的调试器在控制台上显示了一个数组，我们可以访问：

```js
Array[6]
   0: 1
   1: 1
   2: 3
   3: 4
   4: 5
   5: 9
   length: 6
     __proto__: Array[0]
```

这很好。让我们再进一步，尝试混合整数和浮点小数（浮点数）。请注意，在 JavaScript 中，有一种数值类型，它的行为类似于整数（并保持整洁）对于在 Firefox 中介于-(253-1)或-9007199254740991 和 253-1 或 9007199254740991 之间的整数。这种数值类型也存储浮点数。它们具有更大的范围，当然，对于较小的数字，有更精细的值。为了进一步扩展范围，让我们创建一个包含整数和浮点数混合的数组：

```js
var mixed_numbers = [3, Math.PI, 1, Math.E, 4, Math.sqrt(2), 1,
  Math.sqrt(3), 5, Math.sqrt(5), 9];
```

在这些数字中，`Math.PI`大约是 3.14，`Math.E`大约是 2.72，`Math.sqrt(2)`大约是 1.41，`Math.sqrt(3)`大约是 1.73，`Math.sqrt(5)`大约是 2.24。让我们像其他数组一样对其进行排序并记录这些值：

```js
[1, 1, 1.4142135623730951, 1.7320508075688772, 2.23606797749979, 2.718281828459045, 3, 3.141592653589793, 4, 5, 9]
```

Chrome 的调试器，出于某种原因，这次表现不同，显示的是一个字符串数组，而不是一个带有向左的下钻三角形的数组。然而，数组被正确排序，所有值都按升序排列，整数和浮点值显示正确。

让我们在字符串上试一试。假设我们有以下数组：

```js
var fruits = ['apple', 'durian', 'banana', 'canteloupe'];
```

当我们对其进行排序时，得到了这个：

```js
["apple", "banana", "canteloupe", "durian"]
```

这是有序的，很好。让我们在数组中间添加一点内容：

```js
var words = ['apple', 'durian', 'Alpha', 'Bravo', 'Charlie',
  'Delta', 'banana', 'canteloupe'];
```

我们对其进行排序，得到了以下结果：

```js
  ["Alpha", "Bravo", "Charlie", "Delta", "apple", "banana",
    "canteloupe", "durian"]
```

这是什么？所有新单词都在开头，所有旧单词都在结尾！也许在它们自己之间排序，但是由大小写分隔。

这是因为字符串排序是根据 Unicode 值的字典顺序，这与 ASCII 编码相同，对于 ASCII 的一部分字符。在 ASCII 中，所有大写字母都排在所有小写字母之前。在这里，大写字母在大写字母内部被正确排序，小写字母在小写字母内部被正确排序，但这两者是分开的。如果我们希望所有的'A'都排在所有的'B'之前，我们需要更具体地说明我们想要什么。

我们可以通过提供一个比较函数来实现这一点-一个将比较两个元素并告诉`Array.sort()`哪个应该先的函数。让我们为这些单词制作一个不区分大小写的排序：

```js
var case_insensitive_comparison = function(first, second) {
  if (first.toLowerCase() < second.toLowerCase()) {
    return -1;
  } else if (first.toLowerCase() > second.toLowerCase()) {
    return 1;
  } else {
    return 0;
  }
}
```

然后我们对数组进行排序并指定比较函数：

```js
words.sort(case_insensitive_comparison);
```

当我们记录排序后的数组时，我们看到了一个不区分大小写的字母顺序：

```js
["Alpha", "apple", "banana", "Bravo", "canteloupe", "Charlie",
  "Delta", "durian"] 
```

如果我们希望大写字母作为一个决定因素，并且大写字母会在其小写字母等价物之前放置，该怎么办？这是我们比较器的一个简单修改：

```js
var mostly_case_insensitive_comparison = function(first, second) {
  if (first.toLowerCase() < second.toLowerCase()) {
    return -1;
  } else if (first.toLowerCase() > second.toLowerCase()) {
    return 1;
  } else {
    if (first < second) {
      return -1;
    } else if (second < first) {
      return 1;
    } else {
      return 0;
    }
  }
}
```

让我们在字符串列表的末尾添加'ALPHA'和'alpha'，然后重新排序：

```js
["ALPHA", "Alpha", "alpha", "apple", "banana", "Bravo",
  "canteloupe", "Charlie", "Delta", "durian"]
```

成功了！

这可能需要，也可能不需要仅仅是字符串比较，但是如果服务器运行了数据库查询并为我们打包了 JSON 结果呢？一旦在客户端解析，结果可能是具有相同结构的对象数组。电子客户联系信息可能包括以下内容：

```js
{
  "email": {
    "personal": "jsmith@gmail.com",
    "work": "john.smith@company.com"
  },
  "name": {
    "first": "John",
    "last": "Smith"
  },
  "skype": {
    "personal": "JohnASmith",
    "work": "JASCompany"
  }
}
```

这种记录结构可能不是 JavaScript 本能地推断出我们希望看到的排序方式，但这并不真正伤害我们。如果我们构建一个比较函数，它可以完全访问要比较的项目的字段或其他细节。这意味着我们可以先比较一个字段，然后再比较另一个字段，然后再比较第三个字段。这也意味着我们可以按不同的标准进行比较；在某个时候，我们可以按名称比较，而在另一个时候，我们可以按地理位置比较。如果我们的服务器存储（或查找）地址的 GPS 坐标，我们可以按离特定位置最近的人进行搜索。

## 这引出了数组.filter()

在函数式语言中，诸如映射、减少和过滤等功能是日常使用的基本功能。它们操作列表，在更多功能性、以列表为中心的语言中，列表可以是有限的，也可以是无限的。在这个意义上，列表可能更像 JavaScript 数组或生成器，一种函数，它不是返回单个值，而是产生零个或多个值，并且在理论上可能产生无限数量的值。与数组不同，任何给定的生成器可能永远不会耗尽，即使它实际上从不产生无限数量的值。生成器是一个很棒的功能，但在撰写本书时，它们在浏览器中的支持并不稳定，这意味着我们更可能在（有限的）数组上而不是在生成器上使用映射、减少和过滤。

但在我们放弃生成器这个话题之前，让我们给出两个生成器的例子，这两个例子都会在不久之后溢出，但它们都是在像 Haskell 这样的语言中可能被认为是一个数学序列的无限列表的例子，而不是仅包含第一个*n*成员的数组。我们将使用 ECMA6 提议的生成器语法来查看 2 的幂和斐波那契数的生成器，如[`wiki.ecmascript.org/doku.php?id=harmony:generators`](http://wiki.ecmascript.org/doku.php?id=harmony:generators)中所讨论的：

```js
function* powers_of_two_generator() {
  var power = 1;
  while (true) {
    yield power;
    power *= 2;
  }
}

function* fibonacci_generator() {
  var first = 0;
  var second = 1;
  var sum;
  yield second;
  while (true) {
    sum = first + second;
    yield sum;
    first = second;
    second = sum;
  }
}
```

将这些示例与使用标准递归方法计算 2 的 n 次幂（这实际上并不需要，因为 JavaScript 的算术处理指数，但为了完整起见，还包括了这一点）以及计算第 n 个斐波那契数的天真实现进行对比。这两种方法都是所谓的尾递归，并且如果浏览器提供了尾调用优化，它们将受益匪浅：

```js
function power_of_two_recursive(n) {
  if (n === 0) {
    return 1;
  } else {
    return 2 * power_of_two_recursive(n – 1);
  }
}

function fibonacci_recursive(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return (fibonacci_recursive(n – 2) +
      fibonacci_recursive(n – 1));
  }
}
```

这两个函数都假设参数为非负整数。第二个函数的性能特征也很糟糕，尽管内存使用并不特别糟糕。然而，函数调用的次数与返回的值相当，因此计算第 100 个斐波那契数，除了整数溢出的问题，可能比宇宙的年龄还要长。正如 Donald Knuth 所说，“过早的优化是万恶之源”，但这是一个不需要过早优化的情况。

请注意函数式编程的另一个特性，称为**记忆化**——这意味着保留中间计算的结果，而不是反复从头开始重新生成它们，从而完全避免了性能瓶颈。考虑下面递归斐波那契函数的记忆化：

```js
var calculated_fibonacci_numbers = [];

function fibonacci_memoized(n) {
  if (calculated_fibonacci_numbers.length > n) {
    return calculated_fibonacci_numbers[n];
  } else {
    if (n === 0 || n === 1) {
      result = 1;
    } else {
      result = (fibonacci_memoized(n – 2) +
      fibonacci_memoized(n – 1));
    }
    calculated_fibonacci_numbers[n] = result;
    return result;
  }
}
```

## 幻觉主义，映射，减少和过滤

在我小时候，我对幻术非常感兴趣，我现在还有一个幻术师的道具——里面有（或曾经有）一些东西，比如一个假拇指和一个戏法杯——还有一些幻术书。我记得的一个戏法是把一根绳子绕在大腿上，然后再绕在手上。如果一个人的腿放松，绳子看起来很紧，但如果一个人抬起腿，绳子就松了很多，从而给人一种被牢牢捆绑的印象，而实际上很容易解开一个或两个手。

我从来不擅长业余魔术表演的一面，这实际上是这门手艺的核心。资深的魔术师在指导他们的后辈或有抱负的人时，往往会说诸如“取悦观众并欺骗他们，但要知道哪个先来”。我记得很长一段时间以来，我一直认为我不懂（技术方面的）真正的魔术，因为我技术上知道如何做几个戏法，但我不知道如何去做我看到的那些事情。

后来，在我公司的派对上有一个魔术师，我因为一个不寻常的原因而着迷。他做了一些对我来说新奇的戏法，但在大约 70％或 80％的时间里，他花了很多精力利用我小时候学到的绳索戏法。而且效果非常好。他有精湛的表演技巧，而我的着迷并不是想知道他是如何技术上完成这个戏法的，而是对这样一个擅长的表演者能够利用一个孩子都能做的两个戏法来取悦观众感到惊叹。

Map，reduce 和 filter（这里，“reduce”包括右折叠和左折叠）在函数式编程中有些类似。Map 接受并将其应用于列表的所有成员。Reduce 接受一个操作，并从右侧或左侧开始，将其应用于每个成员，并得到一个中间结果。Filter 接受一个函数和一个列表，并创建一个由函数为真的项目组成的新列表。这些概念将在本章中进行进一步解释和说明。Map，reduce 和 filter 并不是特别困难的概念，但是可以从中获得很多收益。让我们来看看数组的 map，reduce 和 filter，暂时不考虑生成器和 Haskell 等语言提供的潜在无限列表。我们将向您展示如何使用 JavaScript 的数组内置版本的 map，reduce 和 filter。我们还将研究使用核心 JavaScript 来实现这些函数，不是为了让人们可以在 IE8（及更早版本）中使用这些函数，而是为了让人们了解这些功能的工作原理。

在警告了愚人金之后，我们将探讨一种有点非函数式风格的实现。它们使用`for`循环，在纯函数式语言中，首选的解决方案可能是尾递归实现。选择这种方式的理由是为了以一种对 JavaScript 的管道操作效果最佳的方式提供函数式特性支持，并且不会在（非尾调用优化的）JavaScript 递归在极少数情况下达到极限时失败。

## 愚人金 - 扩展 Array.prototype

需要注意的是，一个吸引人的解决方案，而且可以很容易地实现，是扩展（这里）`Array.prototype`或其他对象的原型，包括`Object.prototype`。不要这样做。

扩展`Array.prototype`及其相关内容会破坏其他人软件的平衡；这就好像在没有看到其他人的代码的情况下重写其他人的代码。扩展基本原型的最佳用例可能是填充（使用可用功能重新实现当前环境中不可用的功能），但即使在这种情况下，如果存在竞争的填充，也只有一个可以胜出。现在，你的填充不太可能像主要浏览器制造商一样对错误兼容性进行测试。这为微妙的错误留下了空间。在我们的情况下，为了支持稀疏矩阵，我们忽略了未定义的条目，但不是 null。我认为在这种情况下这是合理的，但远非唯一可能的智者（或不那么聪明的人）会如何处理这个问题。JavaScript 有两个 null 值，`null`和`undefined`，对于这两个不同的 null 值应该如何处理，可能会有不止一个观点。如果对我们有意义的语义并不是对其他人明显的语义，我们想要打开滑动的 heisenbugs 之门吗？

有一个简单而好的替代方案：编写自己的函数，最好是在闭包内定义的匿名函数，并存储在一个变量中。如果需要，这些函数可以检查是否存在浏览器的内置函数，比如`Array.prototype.map()`，如果找到，则可以回退到内置函数。它几乎可以完成通过扩展`Array.prototype`实现的任何工作。但它展现了良好的习惯，不会给其他人带来困扰。

### 注意

JavaScript 中的*匿名函数*一词并不排除存储在命名变量中的函数。它只是意味着它们是在没有函数名称的情况下定义的。换句话说，它们是这样定义的：`function()`、`var foo = function()`或其他替代方法，但不是在函数关键字和开括号之间有一个名称，即`function bar()`。通常，我们将使用匿名函数，无论它们是否存储在变量中，但是有一个与调试相关的原因，即使我们从不使用它，也可能会给函数命名：调试器的堆栈跟踪可能会更详细地提到函数，即使从未使用过这些名称。出于这个目的，写`var quux = function quux()`是有意义的。

关于我们可能在私下开发的事情，有一点需要注意：令人惊讶的是，许多 Unix 实用程序最初是作为解决不同人的本地问题的私人黑客行为而诞生的。像野火一样传播的东西通常不是被设计成像野火一样传播的东西，比如 Web、JavaScript 和 5.0 版本之前的 PHP。在它们的第一个版本中，它们做了一些特定的事情，并让人们努力以更完整的方式运行。

HTTP 的无状态性是一个精心选择的特性，但在那个时候，大部分的 Web 编程都在尝试支持无状态 HTTP 变得非常痛苦的用例。5 MB 的 HTML5 键值存储和 4096 字节的 cookie 上限可能存在差异，但它们在提供适当的有状态行为的钩子时都提供了更或多或少优雅的容纳：Web 是建立起来的，不是为了使动态内容成为今天所有 Web 内容的主要部分。JavaScript 有它的优点和缺点，它的缺点可能是任何一个非常成功的语言中最糟糕的，但它之所以广受成功和名声显赫并不是因为它的优点或缺点。它成功是因为它在 Web 迅速传播的时候被包含在浏览器中。JavaScript 和 Web 都有人试图修复它们的限制和缺点，以便在它们迅速传播后做好多种事情，而实际上它们只擅长做一件事。

“这只是一个角落里的东西，我们不需要考虑维护或互操作性”这种心态非常非常危险。也许现在你的软件不会因为微妙地重新定义对象或数组的行为而破坏任何东西，但永远不会吗？甚至在未来的任何决定中？即使有人意识到，在解决 X 的同时，你为 Y 创造了一个可以节省大量工作的强大引擎？客户端 JavaScript 是一些最快成为开源的代码（毕竟，即使是关心保持专有内容的律师也知道你的整个系统可以交付给从 Web 登录到系统的任何人），假设某种标准行为的重新定义只是未来的保证是危险的。

对前面问题的一个简短回答是：不要重新定义其他人构建的任何东西，包括重新定义`Object.prototype`、`Array.prototype`、`Function.prototype`等部分。尽可能选择自己的实现，但不要（强制性地）为每个人安装它。

## 避免全局污染

最好的做法也是尽量减少对全局命名空间的侵入。你添加的全局变量越多，就越容易与其他工具发生冲突。当雅虎宣布 YUI 时，基本礼貌上，他们只使用了一个全局变量——YUI。有一个完整的库可用，但你不会在浏览器的全局命名空间中看到一页页的项目；每次调用 YUI().use()或其他内容都完全包含在 YUI 对全局命名空间的一个侵入中。jQuery 使用的全局命名空间比他们宣传的要多一点，但原则上，他们只要求我们使用`jQuery`和`$`。此外，他们试图使第二个变量完全可协商，因为`jQuery`承认其他框架需要`$`，而`jQuery`旨在与其他框架友好相处。

然而，你实际上可以走得更远，通过立即调用的函数表达式，包括 ReactJS Web 应用程序在第八章中探讨的，*在 JavaScript 中演示函数式响应式编程 - 实时示例*到第十一章，*在 JavaScript 中演示函数式响应式编程 - 实时示例第四部分 - 添加一个草稿并把它全部放在一起*。你可以在不触及全局变量的情况下实现相当多的功能。也许库应该有一些全局变量作为公共面向其他人的接口，但完全可以制作一个不触及全局变量的 Web 应用程序。

## map、reduce 和 filter 工具箱 - map

地图接受一个数组和一个函数，并返回一个将该函数应用于其所有元素的新数组。例如，让我们创建一个包含 1 到 10 的数字的数组，并使用地图创建一个新数组，其中包含它们的平方。（请注意，JavaScript 在数组选项修改数组原地、返回修改后的数组或两者都做方面有些不一致。数组的`map()`、`reduce()`和`filter()`函数都创建一个新数组，保持原始数组不变和不受影响。）

```js
var one_to_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var squares = one_to_ten.map(function(x) {return x * x});
```

`squares`变量现在包含`[1, 4, 9, 16, 25, 36, 49, 84, 81, 100]`。

`map()`的一个实现可能如下所示：

```js
var map = function(arr, func) {
  var result = [];
  for(var index = 0; index < arr.length; ++index) {
    if (typeof arr[index] !== 'undefined') {
      result[index] = func(arr[index]);
    }
  }
  return result;
};
```

## 减少函数

减少函数的作用是，它接受一个操作，并逐步将其应用于数组中的元素。你可能在学校学过无限（和有限）级数，也许有这样的符号：

![减少函数](img/B04108_05_01.jpg)

在这种操作中，大写希腊字母 sigma（**Σ**，大致相当于希腊字母中的“S”）用于求和，较少地使用大写希腊字母 pi（Π，大致相当于希腊字母中的“P”）用于乘积。它们都反复将算术运算符应用于一系列有限（或无限）的数字，并且它们按照与`reduce()`相同的基本原理工作。

这种类型的符号所说的是，“对于这一系列数字，如果我们将它们相加，也就是说，用加法函数减少它们，取第一个数字和第二个数字，计算它们的和，然后将其添加到第三个数字，依此类推，我们会得到什么？”

如果我们希望将数组的内容相加，我们可以使用加法函数来减少它（作为一个小的实现细节，我们不使用裸的`+`运算符，因为我们不能直接将运算符作为常规函数传递）。

```js
var sum = one_to_ten.reduce(function(x, y) {return x + y});
// returns 55
```

在学校教授的有限和无限级数通常是和；我们也可以使用其他级数。例如，如果我们想计算 10!，我们可以通过乘法而不是加法来减少我们提供的函数的项：

```js
var factorial = one_to_ten.reduce(function(x, y) {return x * y});
// returns 3628800
```

减少不需要是数学性质的；这只是给我们一个快速演示它的方法。我们还可以使用 reduce 来连接字符串数组，其中`+`运算符用于字符串连接而不是数值相加：

```js
var message1 = ['H', 'e', 'l', 'l', 'o', ',', ' ',
  'w', 'o', 'r', 'l', 'd', '!'].reduce(function(x, y)
  {return x + y});
var message2 = ['Hello', ', ', 'world', '!'].reduce(
  function(x, y) {return x + y});
// Both invocations return, 'Hello, world!'
```

然而，JavaScript 内置函数没有为我们解决的一个基本困难。有时我们需要做出选择，并进一步指定我们真正想要的是什么。数值相加、乘法和字符串连接都是可结合的，这基本上意味着你可以在任何地方放括号，遵循括号的标准规则，得到相同的答案。在数值相加中，以下是等价的：

```js
1 + (2 + (3 + 4))
((1 + 2) + 3) + 4
```

这两个计算都得到`10`，如果我们乘以而不是相加，两者都给出`24`的乘积。但是，如果我们对非常略微不同的值使用指数运算符会发生什么：

```js
Math.pow(2, Math.pow(3, 4))
Math.pow(Math.pow(2, 3), 4)
```

这与我们刚刚看到的代码是相同类型的东西，尽管显然使用了一个更丑陋的命名空间函数而不是中缀运算符。在非 JavaScript 符号中，使用一个脱字符（`^`），我们得到以下伪 JavaScript，它重新陈述了前面的计算：

```js
2 ^ (3 ^ 4)
(2 ^ 3) ^ 4
```

如果我们使用`console.log()`和刚刚看到的`Math.pow()`计算，我们会得到这个：

```js
2.4178516392292583e+24
4096
```

这里有一个细微的差别。一个结果是一个四位整数；另一个用科学计数法表示，比四位数多得多。那么，有多少东西真的像指数运算的特殊情况？

这个问题的答案有点棘手，部分原因是我欺骗性地构造了这个问题，以说明一个危险的误解。指数，括号的添加方式很重要，可能更像一般情况。存在一些情况，括号的位置并不重要，它们甚至更常见地成为`reduce()`的候选项，但在一般情况下，我们不应该假设这两者是等价的。我们将给出`fold_left()`和`fold_right()`函数；这不是唯一的两个选项（如果它们都不是你想要的，你可以手动操作），但它们分别计算数组一到十的和如下：

```js
((((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9) + 10
1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 10))))))))
```

两者并不一定有优劣之分，但差异可能很重要。JavaScript 内置的`reduce()`函数是一个左折叠，从左到右开始，如前两个表达式中所示（这可能是一个合理的默认值）。

如果我们定义`fold_left()`和`fold_right()`，它可能看起来像下面这样。我在这里使用了缩写，因为全拼看起来太接近保留字；例如，array 不会与 Array 冲突，但它们之间有令人困惑的相似之处（如果变量命名为 function，也会有类似的冲突）：

```js
function fold_left(arr, fun) {
  var accumulator;
  for(var index = 0; index < arr.length; ++index) {
    if (typeof arr[index] !== 'undefined') {
      if (typeof accumulator === 'undefined') {
        accumulator = arr[index];
      } else {
        accumulator = fun(accumulator, arr[index]);
      }
    }
  }
  return accumulator;
}

function fold_right(arr, fun) {
  var accumulator;
  for(var index = arr.length - 1; index >= 0; --index) {
    if (typeof arr[index] !== 'undefined') {
      if (typeof accumulator === 'undefined') {
        accumulator = arr[index];
      } else {
        accumulator = fun(arr[index], accumulator);
      }
    }
  }
  return accumulator;
}
```

## 最后一个核心工具——过滤器

过滤器通过数组筛选出符合某些标准的值。例如，我们可以过滤出仅为正值的内容，如下所示：

```js
var positive_and_negative = [-4, -3, -2, -1, 0, 1, 2, 3, 4];
var positive_only = positive_and_negative.filter(
  function(x) {return x > 0;});
```

`positive_and_negative`过滤器，在此运行后，如声明的那样；`positive_only`的数组值为`[1, 2, 3, 4]`。

过滤对于缩小数组的内容很有用。如果我们有一个数组，如前面的一个，包含了 Smith 先生的联系信息，我们可以访问字段，缩小到可能符合我们兴趣的内容。我们可以声明我们只想要一个州，或者需要一个特定电话区号的电话号码，或者对函数能够告诉的任何内容陈述其他标准。如果我们的记录包括 GPS 坐标，我们可以过滤内容，只包括特定中心点半径内的结果。我们只需要一个函数，对于我们想要包括的记录返回 true，对于我们不想要的记录返回 false。

# JavaScript 中信息隐藏的概述

一般来说——意味着任何编程语言、客户端、服务器端、非网络、移动应用程序，几乎任何其他东西，甚至可能是微控制器（现在可以运行精简版的 Python）——都有不同的方法论，通常都有各自的优势和劣势。Steve McConnell 的《代码大全：软件构建的实用手册》（[`tinyurl.com/reactjs-code-complete`](http://tinyurl.com/reactjs-code-complete)）讨论了不同的方法论，比如，面向对象编程的优势在于比过程式编程更适合大型项目。对于大多数方法论，他的建议是它们都有各自的优势、劣势和适用范围，在 X 和 Y 条件下，你应该考虑方法论 Z。但有一个例外——信息隐藏。他对何时使用信息隐藏的简单建议是“尽可能多地使用”。

程序化或结构化编程可能很容易被忽视，使用其优势并不是在突破界限。但是假设我们看看它最初发布时的情况，它的函数/过程，if-then-else，`for`/`while`循环和过程体不对外开放。现在，如果我们将其与直接的汇编或机器代码进行比较，使用了 Dijkstra 风格的 goto，甚至不假装模拟结构化控制流，那么我们就会明白，程序化或结构化编程真的是非常惊人的。此外，今天这显而易见的事实是因为它在很大程度上取得了成功，使每个人受益。流程图曾经是理解复杂系统的必备救生工具，现在已经成为一种新奇物品。它们出现在杯子上，在 XKCD 漫画中展示了如何提供出色的技术支持，或者在其他幽默的用途中，因为它们不再需要提供任何一种路线图来帮助一些人——找到他们穿过意大利面的方法。

现在，一个大型系统可能比旧的、流程图导航的程序所能容纳的要复杂得多，也要大得多，但是程序化编程已经有效地驱逐了那个幽灵。此外，软件工程范式中的新迭代，如面向对象编程，已经减少了理解大型系统的难度。在这两种情况下，很大一部分好处是一种推进信息隐藏的实用方式。通过结构化编程，您可以在源代码中导航，而无需跟踪汇编或机器语言呈现跳转（即 goto）的每个点。结构化和面向对象编程在历史上都允许开发人员前所未有地将更多的程序视为封闭的黑匣子，您只需要打开和检查其中的一小部分。它们提供了信息隐藏。

![JavaScript 中信息隐藏的概述](img/B04108_05_02.jpg)

前面的流程图是来自[`xkcd.com/627/`](http://xkcd.com/627/)的新奇流程图。我从未见过有人谈论的程序的真正流程图。

在经典的 Java 中，信息隐藏的标准教科书例子可能是这样的：

```js
class ObjectWithPrivateMember {
  private int counter;
  public ObjectWithPrivateMember() {
    counter = 0;
  }
  public void increment() {
    counter += 1;
  }
  public void decrement() {
    counter -= 1;
  }
  public void get_counter() {
    return counter;
  }
}
```

与生产中的 Java 类的一个好例子不同，这个类有一个私有成员和四个公共成员。通常的目标是尽可能隐藏有趣的重要工作，并向世界展示一个简化的外观。这就是 Java 面向对象编程提供信息隐藏的方式，尽管面向对象语言之间在处理对象的方式和方法上有重要的区别，但这是 Java 的一大优势。对象方法不仅应该按过程方式编写——作为具有定义输入和输出的黑匣子——而且它们还封装在对象中，多个较小的黑匣子可以被包含在一个较大的黑匣子下。在这种情况下，我们看到了信息隐藏的另一个好处：我们在很大程度上受到外部保护，并且可以自由地进行任何内部更改，而不会破坏外部使用，只要我们保持相同的行为。假设我们决定保留计数器何时更改以及更改为何值的日志。这至少是另一个私有字段和对代表公共接口的方法的内部更改，但我们可以进行这些更改而不改变任何访问这个类的任何类的任何细节。现在假设我们想要更多的日志记录，我们希望我们的日志记录完整的堆栈跟踪。在内部，我们需要使用诸如`Thread.currentThread.getStackTrace()`这样的东西，但在外部，没有人需要知道或关心我们的重构。在一个更大的类中，我们可能会发现一个瓶颈，通过切换到另一个等效算法可以显著改进。由于 Java 面向对象编程提供信息隐藏的方式，我们可以进行大量的更改而不会打扰其他人，他们可以使用我们的工作而不必为除了我们的公共接口之外的任何事情而烦恼。

## 使用 JavaScript 闭包进行信息隐藏

我们需要进一步观察信息隐藏的模式。在 Java 中，你会很快学到信息隐藏的语言特性，并且会被鼓励使用诸如“特权的吝啬是伪装下的善意”这样的安全最大化原则，以便在声明事物为非公开时出错。在 JavaScript 中，可能会有一些未来保留的关键词，比如`public`、`private`和`protected`（Douglas Crockford 建议这些关键词可能是为了让 Java 程序员更容易理解 JavaScript 而牺牲了 JavaScript 更好的一面），但现在并没有同样明显的机制。对象的所有成员，无论是函数还是其他，都是公开的。JSON——另一种像野火一样传播开来的东西，但没有人因其简单而诅咒——没有提供任何标记任何东西为非公开的机制。

然而，在一些函数式语言的特性中有一种叫做闭包的技术，可以创建私有字段。这并不是一种简单存在于语言中的创建信息隐藏的技术，但它允许我们创建包含非公开信息的对象。为了移植前面的例子的功能，包括非公开状态，我们可以有如下所示的东西：

```js
var factory_for_objects_with_private_member = function() {
  var counter = 0;
  return {
    'increment': function() {
      counter += 1;
    },
    'decrement': function() {
      counter -= 1;
    },
    'get_count': function() {
      return counter;
    }
  }
};
```

这里给出的例子建议了我们如何扩展它。一个更复杂的例子可能有更多的`var`函数存储字段和函数，并返回一个将公共接口暴露出来的字典。但我们不要简单地跳到那一步；在这条路上有一些有趣的事情。

在函数式语言中，函数可以包含其他函数。事实上，鉴于 JavaScript 的语法——其中函数是第一类实体，可以存储在变量中，作为参数传递等等——如果函数不能嵌套甚至两层深，那将是令人惊讶的。因此，以下语法是合法的：

```js
var a = 1;
var inner = function() {
  var b = 2;
  return a + b;
}
```

但同样的东西可以合法地包装在一个函数中，如下所示：

```js
var outer = function() {
  var a = 1;
  var inner = function() {
    var b = 2;
    return a + b;
  }
}
```

这是功能语言的基本特性，包括 JavaScript 的传统，内部函数可以访问外部函数的变量；因此`a`和`b`对`inner`函数同样可用。

现在如果我们将`outer`函数改为返回`inner`函数会发生什么？然后我们有以下内容：

```js
var outer = function() {
  var a = 1;
  var inner = function() {
    var b = 2;
    return a + b;
  }
  return inner;
}
var result = outer();
```

当函数执行完成时，它的变量已经超出了范围。JavaScript 现在具有函数范围的`var`变量，并且正在过程中获得块范围的`let`变量，但是在`outer`函数中以任何方式声明的变量已不再可用。然而，有趣的事情发生了；`inner`函数在`outer`函数结束后仍然存在，但以一种逻辑一致的方式。`inner`函数应该并且确实可以访问它的执行上下文。我们有了一个闭包。

这种现象可以用于信息隐藏，信息隐藏很重要。然而，可以争论的是这里最有趣的不是它可以包含非公共变量，潜在地包括函数，而是只要有东西可以访问它，执行上下文作为一个整体就会被保留下来。这留下了一个有趣的领域可以探索。一个 StackOverflow 成员曾评论说，“对象是穷人的闭包”，对象和闭包都有有趣的可能性，超出了关于如何使用它们的特性进行信息隐藏的 FAQ 条目。即使是《代码大全》，它可能会强烈支持信息隐藏，也从未说过，“尽可能使用信息隐藏，但不要使用其他东西。”

也许责怪功能语言纯粹主义者说，“JavaScript 必须等到它成为 20 年历史才能实现尾调用优化，而不是惩罚标准的函数式编程使用递归——就像美国法律下的一个新生儿成长为成年人一样。”然而，不管功能程序员对 JavaScript 可能感到不满的其他方面如何，JavaScript 从一开始就足够正确地实现了闭包，以至于保留执行上下文的闭包在 JavaScript 中一直是一个重要的特性。而 20 年后，它们仍然是大多数浏览器中的主要，可能是唯一的信息隐藏资源。

# 摘要

在本章中，我们涉及了 JavaScript 与功能编程的一些注解。我们主要关注了三个主题。自定义排序函数提供了一个简单而有用的窥视，我们如何将一个辅助函数传递给一个高阶函数，以获得比默认更有用的行为。Map、reduce 和 filter 是与数组相关的功能编程的三个主要工具。通过闭包和信息隐藏，我们看了一种在负责任的软件开发中提供一些核心兴趣的功能方式。

JavaScript 是一种具有功能根源和一些功能语言优势的多范式语言，尽管功能语言纯粹主义者将 JavaScript 与命令式多范式语言一起归类可能是不常见的。JavaScript 没有像一些功能语言那样对赋值或纯不可变数据结构进行永久绑定。

所有语言都有好坏不同的地方，但 JavaScript 将优秀的部分和糟糕的部分如此明显地结合在一起，以至于 Crockford 的《JavaScrpt: The Good Parts》和《The Better Parts》的基本方法在优秀的开发人员中没有受到严肃质疑（我想知道为什么还没有人将 Kernigan 和 Ritchie 的《C 程序设计语言》第二版销售为《C++: The Good Parts》）。认为默认将事物倾倒在全局对象上是开发 Web 应用的好主意，这种观点可能会引起争议，甚至令人讨厌。这也适用于 JavaScript 的功能方面。JavaScript 是第一种主流语言，允许使用匿名函数或 lambda，这在函数式编程中已经成为基本要素，大约自 LISP 出现 50 多年以来。即使现在连 Java 也加入了这一潮流，但它在主流语言中的存在是受 JavaScript 的影响。JavaScript 从一开始就有闭包。就一些糟糕的地方而言，JavaScript 似乎花了几十年的时间才应用尾调用优化，以及使用尾递归而不受惩罚，而不是使用 for 和`while`循环来构建迭代工作的函数式编程风格。

函数式编程是一个有趣的话题，你可以无限地探索（也就是说，函数式编程的有趣方面的列表是一个无限的列表，尽管在具体情况下，人们只能从列表的左边取出有限数量的项目）。在不试图解决 JavaScript 是否应该被视为函数式语言的问题的情况下，最好将 JavaScript 理解为与函数式编程根源相关，并且学习在函数式语言/范式中更好地编程应该是在 JavaScript 中更好编程的基础。JavaScript 可能会载入历史，不仅作为 Web 的语言，也许是程序员必须了解的最关键的语言，还是功能性语言的优点不再被视为（如 Scheme）“你永远不会使用的最好的语言”的桥梁语言。也许，功能性语言的优势会被视为严肃、主流的多范式语言构建的不可妥协的部分。

让我们继续看看函数式响应式编程。
